<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-112417276-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    
    
    <title>JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map) | Recall Hyx | Your star</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#FFC107">
    
    
    <meta name="keywords" content="javascript">
    <meta name="description" content="Symbol—使用方法，Symbol.for()、Symbol.keyFor()使用方法ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)">
<meta property="og:url" content="https://recallhyx.github.io/2018/02/07/ES6（3）/index.html">
<meta property="og:site_name" content="Recall Hyx">
<meta property="og:description" content="Symbol—使用方法，Symbol.for()、Symbol.keyFor()使用方法ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-02-08T06:39:24.959Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)">
<meta name="twitter:description" content="Symbol—使用方法，Symbol.for()、Symbol.keyFor()使用方法ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Recall HYX</h5>
          <a href="mailto:quce.hu@qq.com" title="quce.hu@qq.com" class="mail">quce.hu@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/recallhyx" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-02-07T03:16:15.000Z" itemprop="datePublished" class="page-time">
  2018-02-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Symbol—使用方法，Symbol-for-、Symbol-keyFor"><span class="post-toc-number">1.</span> <span class="post-toc-text">Symbol—使用方法，Symbol.for()、Symbol.keyFor()</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用方法"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">使用方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Symbol-for-、Symbol-keyFor"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Symbol.for()、Symbol.keyFor()</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Set-和-Map"><span class="post-toc-number">2.</span> <span class="post-toc-text">Set 和 Map</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Set"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Set</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Set-实例的属性和方法"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Set 实例的属性和方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#WeakSet"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">WeakSet</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Map"><span class="post-toc-number">3.</span> <span class="post-toc-text">Map</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map实例的属性和操作方法"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Map实例的属性和操作方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map遍历方法"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Map遍历方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map与其他数据结构的互相转换"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Map与其他数据结构的互相转换</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#WeakMap"><span class="post-toc-number">4.</span> <span class="post-toc-text">WeakMap</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#WeakMap-的语法"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">WeakMap 的语法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#WeakMap-的用途"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">WeakMap 的用途</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-ES6（3）"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-02-07 11:16:15" datetime="2018-02-07T03:16:15.000Z"  itemprop="datePublished">2018-02-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="Symbol—使用方法，Symbol-for-、Symbol-keyFor"><a href="#Symbol—使用方法，Symbol-for-、Symbol-keyFor" class="headerlink" title="Symbol—使用方法，Symbol.for()、Symbol.keyFor()"></a>Symbol—使用方法，Symbol.for()、Symbol.keyFor()</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、对象（<code>Object</code>）。</p>
<p><code>Symbol</code> 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 <code>Symbol</code> 类型。凡是属性名属于 <code>Symbol</code> 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 <code>Symbol</code> 数据类型，而不是字符串之类的其他类型。</p>
<p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 <code>Symbol</code>是一个原始类型的值，不是对象。也就是说，由于 <code>Symbol</code> 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 <code>Symbol</code> 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>s1</code>和<code>s2</code>是两个 <code>Symbol</code> 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 <code>Symbol</code> 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 <code>Symbol</code> 值。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，<code>Symbol</code>函数的参数只是表示对当前 <code>Symbol</code> 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p><code>Symbol</code> 值不能与其他类型的值进行运算，会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure></p>
<p>但是，<code>Symbol</code> 值可以显式转为字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure></p>
<p>另外，<code>Symbol</code> 值也可以转为布尔值，但是不能转为数值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Symbol-for-、Symbol-keyFor"><a href="#Symbol-for-、Symbol-keyFor" class="headerlink" title="Symbol.for()、Symbol.keyFor()"></a>Symbol.for()、Symbol.keyFor()</h3><p>有时，我们希望重新使用同一个 <code>Symbol</code> 值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s<span class="number">1</span> = Symbol.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s<span class="number">2</span> = Symbol.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s<span class="number">1</span> === s<span class="number">2</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是 <code>Symbol</code> 值，但是它们都是同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 <code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 <code>Symbol</code> 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 <code>Symbol</code> 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 <code>Symbol</code> 值。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor</code>方法返回一个已登记的 <code>Symbol</code> 类型值的<code>key</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>s2</code>属于未登记的 <code>Symbol</code> 值，所以返回<code>undefined</code>。</p>
<p>需要注意的是，<code>Symbol.for</code>为 <code>Symbol</code> 值登记的名字，是全局环境的，可以在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.<span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>iframe</code> 窗口生成的 <code>Symbol</code> 值，可以在主页面得到。</p>
<p>总的来说，由于以<code>symbol</code>值作为名称的属性，不会被常规方法（<code>for...in</code>、<code>for...of</code>循环，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回）遍历得到。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 <code>Symbol</code> 属性名。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法，这就是<code>symbol</code>的主要用法之一。</p>
<h2 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>ES6 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code> 本身是一个构造函数，用来生成 <code>Set</code> 数据结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码通过<code>add</code>方法向 <code>Set</code> 结构加入成员，结果表明 <code>Set</code> 结构不会添加重复的值。</p>
<p><code>Set</code> 函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.size <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line">function divs () &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="built_in">document</span>.<span class="built_in">querySelectorAll</span>(<span class="string">'div'</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>(divs());</span><br><span class="line"><span class="keyword">set</span>.size <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line">divs().forEach(div =&gt; <span class="keyword">set</span>.add(div));</span><br><span class="line"><span class="keyword">set</span>.size <span class="comment">// 56</span></span><br><span class="line">上面代码中，例一和例二都是<span class="built_in">Set</span>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</span><br><span class="line"></span><br><span class="line">上面代码中，也展示了一种去除数组重复成员的方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure></p>
<p>向 <code>Set</code> 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。<code>Set</code> 内部判断两个值是否不同，使用的算法叫做“<code>Same-value equality</code>”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set();</span><br><span class="line"><span class="keyword">let</span> a = NaN;</span><br><span class="line"><span class="keyword">let</span> b = NaN;</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(a);</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(b);</span><br><span class="line"><span class="keyword">set</span> <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码向 <code>Set</code> 实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在 <code>Set</code> 内部，两个<code>NaN</code>是相等。</p>
<p>另外，两个对象总是不相等的。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">set</span> = new <span class="comment">Set()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size //<span class="comment"> 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size //<span class="comment"> 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li>
<li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li>
</ul>
<p><code>Set</code> 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法。</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p><code>Array.from</code>方法可以将 <code>Set</code> 结构转为数组。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="keyword">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">array</span> = <span class="keyword">Array</span>.from(items);</span><br></pre></td></tr></table></figure></p>
<p>这就提供了去除数组重复成员的另一种方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<p><code>keys()</code>：返回键名的遍历器<br><code>values()</code>：返回键值的遍历器<br><code>entries()</code>：返回键值对的遍历器<br><code>forEach()</code>：使用回调函数遍历每个成员<br>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 <code>Set</code> 保存一个回调函数列表，调用时就能保证按照添加顺序调用。<br>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 <code>Set</code> 结构。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">set</span> = <span class="literal">new</span> <span class="built_in">Set</span>(<span class="meta">[</span><span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span><span class="meta">]</span>);</span><br><span class="line">let arr = <span class="meta">[</span><span class="params">...</span><span class="built_in">set</span><span class="meta">]</span>;</span><br><span class="line">// <span class="meta">[</span><span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span><span class="meta">]</span></span><br></pre></td></tr></table></figure></p>
<p>扩展运算符和 <code>Set</code> 结构相结合，就可以去除数组的重复成员。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line">let unique = [...new Set(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure></p>
<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 <code>Set</code> 了。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([...<span class="keyword">set</span>].map(x =&gt; x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line">let <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([...<span class="keyword">set</span>].filter(x =&gt; (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>因此使用 <code>Set</code> 可以很容易地实现并集（<code>Union</code>）、交集（<code>Intersect</code>）和差集（<code>Difference</code>）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果想在遍历操作中，同步改变原来的 <code>Set</code> 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 <code>Set</code> 结构映射出一个新的结构，然后赋值给原来的 <code>Set</code> 结构；另一种是利用<code>Array.from</code>方法。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">let <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([...<span class="keyword">set</span>].map(val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">let <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>(Array.from(<span class="keyword">set</span>, val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 <code>Set</code> 结构。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。但是，它与 <code>Set</code> 有两个区别。</p>
<p>首先，<code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WeakSet();</span><br><span class="line">ws.<span class="keyword">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.<span class="keyword">add</span>(Symbol())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码试图向 <code>WeakSet</code> 添加一个数值和<code>Symbol</code>值，结果报错，因为 <code>WeakSet</code>只能放置对象。</p>
<p>其次，<code>WeakSet</code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。<code>WeakSet</code> 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，<code>WeakSet</code> 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 <code>WeakSet</code> 里面的引用就会自动消失。</p>
<p>由于上面这个特点，<code>WeakSet</code> 的成员是不适合引用的，因为它会随时消失。另外，由于 <code>WeakSet</code> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet</code> 不可遍历。</p>
<p>这些特点同样适用于本章后面要介绍的 <code>WeakMap</code> 结构。</p>
<p>WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>JavaScript 的对象（<code>Object</code>），本质上是键值对的集合（<code>Hash</code> 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">'metadata'</span>;</span><br><span class="line">data[<span class="string">'[object HTMLDivElement]'</span>] <span class="comment">// "metadata"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码原意是将一个 <code>DOM</code> 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>
<p>为了解决这个问题，ES6 提供了 <code>Map</code> 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，<code>Object</code> 结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的 <code>Hash</code> 结构实现。如果你需要“键值对”的数据结构，<code>Map</code> 比 <code>Object</code> 更合适。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;p: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.<span class="keyword">set</span>(o, <span class="string">'content'</span>)</span><br><span class="line">m.<span class="keyword">get</span>(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码使用 <code>Map</code> 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>
<p>上面的例子展示了如何向 <code>Map</code> 添加成员。作为构造函数，<code>Map</code> 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">size</span> <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">map</span>.has(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">'name'</span>) <span class="comment">// "张三"</span></span><br><span class="line"><span class="built_in">map</span>.has(<span class="string">'title'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">'title'</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码在新建 <code>Map</code> 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>
<p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  ([<span class="built_in">key</span>, value]) =&gt; <span class="built_in">map</span>.<span class="built_in">set</span>(<span class="built_in">key</span>, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>事实上，不仅仅是数组，任何具有 <code>Iterator</code> 接口、且每个成员都是一个双元素的数组的数据结构都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 <code>Map</code>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">'bar'</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="keyword">set</span>);</span><br><span class="line">m1.<span class="keyword">get</span>(<span class="string">'foo'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'baz'</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>(m2);</span><br><span class="line">m3.<span class="keyword">get</span>(<span class="string">'baz'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，我们分别使用 <code>Set</code> 对象和 <code>Map</code> 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 <code>Map</code> 对象。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span></span><br><span class="line">.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">'aaa'</span>)</span><br><span class="line">.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="number">1</span>) <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>
<p>如果读取一个未知的键，则返回<code>undefined</code>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().<span class="keyword">get</span>(<span class="string">'asfddfsasadf'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>注意，只有对同一个对象的引用，<code>Map</code> 结构才将其视为同一个键。这一点要非常小心。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>同理，同样的值的两个实例，在 <code>Map</code> 结构中被视为两个键。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span></span><br><span class="line">.<span class="built_in">set</span>(k1, <span class="number">111</span>)</span><br><span class="line">.<span class="built_in">set</span>(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(k1) <span class="comment">// 111</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 <code>Map</code> 结构中被视为两个键。</p>
<p>由上可知，<code>Map</code> 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（<code>clash</code>）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 <code>Map</code> 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，<code>Map</code> 将其视为一个键，比如0和-0就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 <code>Map</code> 将其视为同一个键。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">-0</span>, <span class="number">123</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="keyword">true</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'true'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="keyword">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(undefined, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="keyword">null</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(undefined) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(NaN, <span class="number">123</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(NaN) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Map实例的属性和操作方法"><a href="#Map实例的属性和操作方法" class="headerlink" title="Map实例的属性和操作方法"></a>Map实例的属性和操作方法</h3><p><code>Map</code> 结构的实例有以下属性和操作方法。</p>
<ul>
<li>size：<code>size</code>属性返回 <code>Map</code> 结构的成员总数。</li>
<li>set(key, value)：<code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。<code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</li>
<li>get(key)：<code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li>
<li>has(key)：<code>has</code>方法返回一个布尔值，表示某个键是否在当前 <code>Map</code> 对象之中。</li>
<li>delete(key)：<code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li>
<li><p>clear()：<code>clear</code>方法清除所有成员，没有返回值。</p>
<h3 id="Map遍历方法"><a href="#Map遍历方法" class="headerlink" title="Map遍历方法"></a>Map遍历方法</h3><p><code>Map</code> 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
</li>
<li><p>keys()：返回键名的遍历器。</p>
</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 <code>Map</code> 的所有成员。</li>
</ul>
<p>需要特别注意的是，<code>Map</code> 的遍历顺序就是插入顺序。<br><code>Map</code> 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const map = new <span class="symbol">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">// [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line">// [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line">// [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line">// [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</span><br></pre></td></tr></table></figure></p>
<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 <code>Map</code> 的遍历和过滤（<code>Map</code> 本身没有<code>map</code>和<code>filter</code>方法）。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .<span class="keyword">set</span>(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .<span class="keyword">set</span>(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .<span class="keyword">set</span>(<span class="number">3</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].filter(([k, v]) =&gt; k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].map(([k, v]) =&gt; [k * <span class="number">2</span>, <span class="string">'_'</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>此外，<code>Map</code> 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.forEach(function(value, <span class="built_in">key</span>, <span class="built_in">map</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">"Key: %s, Value: %s"</span>, <span class="built_in">key</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line">forEach方法还可以接受第二个参数，用来绑定<span class="keyword">this</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  report: function(<span class="built_in">key</span>, value) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Key: %s, Value: %s"</span>, <span class="built_in">key</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.forEach(function(value, <span class="built_in">key</span>, <span class="built_in">map</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.report(<span class="built_in">key</span>, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>
<h3 id="Map与其他数据结构的互相转换"><a href="#Map与其他数据结构的互相转换" class="headerlink" title="Map与其他数据结构的互相转换"></a>Map与其他数据结构的互相转换</h3><p>（1）Map 转为数组</p>
<p>前面已经提过，<code>Map</code> 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const myMap = <span class="literal">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .<span class="built_in">set</span>(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">  .<span class="built_in">set</span>(&#123;foo: <span class="number">3</span>&#125;, <span class="meta">[</span><span class="string">'abc'</span><span class="meta">]</span>);</span><br><span class="line"><span class="meta">[</span><span class="params">...</span>myMap<span class="meta">]</span></span><br><span class="line">// <span class="meta">[</span> <span class="meta">[</span> <span class="literal">true</span>, <span class="number">7</span> <span class="meta">]</span>, <span class="meta">[</span> &#123; foo: <span class="number">3</span> &#125;, <span class="meta">[</span> <span class="string">'abc'</span> <span class="meta">]</span> ] ]</span><br></pre></td></tr></table></figure></p>
<p>（2）数组 转为 Map</p>
<p>将数组传入 <code>Map</code> 构造函数，就可以转为 <code>Map</code>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="keyword">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;foo: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; ['abc']</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>（3）Map 转为对象</p>
<p>如果所有 <code>Map</code> 的键都是字符串，它可以转为对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">'yes'</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>（4）对象转为 Map<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>（5）Map 转为 JSON</p>
<p><code>Map</code> 转为 <code>JSON</code> 要区分两种情况。一种情况是，<code>Map</code> 的键名都是字符串，这时可以选择转为对象 <code>JSON</code>。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">strMapToJson</span>(strMap) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">JSON.stringify(strMapToObj(strMap))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = <span class="keyword">new</span> Map().set(<span class="symbol">'yes</span>', <span class="literal">true</span>).set(<span class="symbol">'no</span>', <span class="literal">false</span>);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// '&#123;<span class="string">"yes"</span>:<span class="literal">true</span>,<span class="string">"no"</span>:<span class="literal">false</span>&#125;'</span><br></pre></td></tr></table></figure></p>
<p>另一种情况是，<code>Map</code> 的键名有非字符串，这时可以选择转为数组 <code>JSON</code>。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(map) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">JSON.stringify([...map])</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = <span class="keyword">new</span> Map().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123;foo: <span class="number">3</span>&#125;, [<span class="symbol">'abc</span>']);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// '[[<span class="literal">true</span>,<span class="number">7</span>],[&#123;<span class="string">"foo"</span>:<span class="number">3</span>&#125;,[<span class="string">"abc"</span>]]]'</span><br></pre></td></tr></table></figure></p>
<p>（6）JSON 转为 Map</p>
<p><code>JSON</code> 转为 <code>Map</code>，正常情况下，所有键名都是字符串。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(jsonStr) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">objToStrMap(JSON.parse(jsonStr))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap('&#123;<span class="string">"yes"</span>: <span class="literal">true</span>, <span class="string">"no"</span>: <span class="literal">false</span>&#125;')</span><br><span class="line">// Map &#123;<span class="symbol">'yes</span>' =&gt; <span class="literal">true</span>, <span class="symbol">'no</span>' =&gt; <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，有一种特殊情况，整个 <code>JSON</code> 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 <code>Map</code>。这往往是 <code>Map</code> 转为数组 <code>JSON</code> 的逆操作。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">jsonToMap</span>(jsonStr) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">new</span> Map(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap('[[<span class="literal">true</span>,<span class="number">7</span>],[&#123;<span class="string">"foo"</span>:<span class="number">3</span>&#125;,[<span class="string">"abc"</span>]]]')</span><br><span class="line">// Map &#123;<span class="literal">true</span> =&gt; <span class="number">7</span>, Object &#123;foo: <span class="number">3</span>&#125; =&gt; [<span class="symbol">'abc</span>']&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。<code>WeakMap</code>与<code>Map</code>的区别有两点。</p>
<p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，<code>WeakMap</code> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 <code>WeakMap</code>。一个典型应用场景是，在网页的 <code>DOM</code> 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 <code>DOM</code> 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> WeakMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="keyword">set</span>(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.<span class="keyword">get</span>(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，先新建一个 <code>Weakmap</code> 实例。然后，将一个 <code>DOM</code> 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 <code>WeakMap</code> 里面。这时，<code>WeakMap</code> 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 <code>DOM</code> 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。<code>Weakmap</code> 保存的这个键值对，也会自动消失。</p>
<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>注意，<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> WeakMap();</span><br><span class="line">let <span class="built_in">key</span> = &#123;&#125;;</span><br><span class="line">let obj = &#123;foo: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.<span class="built_in">set</span>(<span class="built_in">key</span>, obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">wm.<span class="built_in">get</span>(<span class="built_in">key</span>)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 <code>WeakMap</code> 外部消除了<code>obj</code>的引用，<code>WeakMap</code> 内部的引用依然存在。</p>
<h3 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h3><p><code>WeakMap</code> 与 <code>Map</code> 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>key()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>前文说过，<code>WeakMap</code> 应用的典型场合就是 <code>DOM</code> 节点作为键名。下面是一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>myElement</code>是一个 <code>DOM</code> 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 <code>WeakMap</code> 里，对应的键名就是<code>myElement</code>。一旦这个 <code>DOM</code> 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p><code>WeakMap</code> 的另一个用处是部署私有属性。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> WeakMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Countdown</span> &#123;</span><br><span class="line">  constructor(counter, action) &#123;</span><br><span class="line">    _counter.<span class="keyword">set</span>(<span class="keyword">this</span>, counter);</span><br><span class="line">    _action.<span class="keyword">set</span>(<span class="keyword">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  dec() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.<span class="keyword">get</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.<span class="keyword">set</span>(<span class="keyword">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.<span class="keyword">get</span>(<span class="keyword">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; console.log(<span class="string">'DONE'</span>));</span><br><span class="line"></span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<blockquote>
<p>参考：阮一峰<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ECMAScript 6 入门》</a></p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="https://recallhyx.github.io">
            <img src="/img/avatar.jpg" alt="Recall HYX">
            Recall HYX
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://recallhyx.github.io/2018/02/07/ES6（3）/&title=《JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)》 — Recall Hyx&pic=https://recallhyx.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://recallhyx.github.io/2018/02/07/ES6（3）/&title=《JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)》 — Recall Hyx&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://recallhyx.github.io/2018/02/07/ES6（3）/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)》 — Recall Hyx&url=https://recallhyx.github.io/2018/02/07/ES6（3）/&via=https://recallhyx.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://recallhyx.github.io/2018/02/07/ES6（3）/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/02/14/this的用法/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JavaScript this的用法</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/02/07/ES6（2）/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JavaScript ES6一些有用的语法特性(函数的扩展、数组的扩展)</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'recallhyx';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Recall HYX &copy; 2017 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://recallhyx.github.io/2018/02/07/ES6（3）/&title=《JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)》 — Recall Hyx&pic=https://recallhyx.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://recallhyx.github.io/2018/02/07/ES6（3）/&title=《JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)》 — Recall Hyx&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://recallhyx.github.io/2018/02/07/ES6（3）/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)》 — Recall Hyx&url=https://recallhyx.github.io/2018/02/07/ES6（3）/&via=https://recallhyx.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://recallhyx.github.io/2018/02/07/ES6（3）/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMElEQVR42u3aS27jMBAFwNz/0h5gdoFH8utuJgNSxVUgxxJLC7p/X1/xev1d71fu1/t37//n/frihYGBsS2jupX3b93fJ38RCfuSioGB8QDG/SFb3VD10Mzxl9cxMDAwgo2+iisJQzEwMDB6B24P1tsiBgYGRjWJzRPXe9h/zsUxMDA2ZFQbA7/59w/2NzAwMDZhvAar2uBc+/Rvd8bAwDiacZVq5ufbJGXNkdFBjIGBcSjjKl3sJZBV3rwV+u13AwMD48GM3hBYNd9MnngZjGJgYDyAkWPyklyvDdAMXjEwMI5mREMMrdAtH6SYhIxRWouBgbE5Y5LE9oLIasMyGfLAwMB4DmNV2JePdlVDVQwMDIzqSEQyVBFtIhg++/ApBgbG0Yy8HJ/fNM+bJ0W3f9wTAwPjUEaeQFYBkxJe/qzyAzAwMDZk5G3L/HithobzF4GBgfEcxj0gD/V6h/gkZMTAwDibkZfv863nLc9eI6FQaMPAwDiCMZogax3iq5oBl3vDwMA4lJEnsataCPnhWwgWMTAwHsCYJLHlAK5452RMDQMD42zGpHk5KZ/1Qs9yHREDA2Nzxqu4VrU/ey/o8j4YGBhHM1aVz3LkvMTW/A3BwMDYnNFLJidF/HwgoxnPYmBgHMroVdrzRsI8t/7Aw8DAwBg0D1Yd3x9eDQYGBkbctpyPUzQPcQwMjAcw8nGKpMSWv6ZqcrsgF8fAwNiQ0atl5Qdu8iJ+vBiHgYGxK+MPiXFgvoIT7FQAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>










</body>
</html>
